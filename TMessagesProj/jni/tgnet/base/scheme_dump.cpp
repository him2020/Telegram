// WARNING! All changes made in this file will be lost!
// Created from 'mtproto.tl', 'api.tl' by 'generate.py'
//
#include <vector>
#include <map>
#include "scheme_flags.h"
#include "mtp_dump.h"
#include "scheme_dump.h"

namespace {

using Types = std::vector<mtpTypeId>;
using Stages = std::vector<int32>;
using Flags = std::vector<int64>;

bool Serialize_resPQ(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ resPQ");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pq: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  server_public_key_fingerprints: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_p_q_inner_data(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ p_q_inner_data");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pq: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  p: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  new_nonce: "); ++stages.back(); types.push_back(mtpc_int256+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_p_q_inner_data_dc(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ p_q_inner_data_dc");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pq: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  p: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  new_nonce: "); ++stages.back(); types.push_back(mtpc_int256+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  dc: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_p_q_inner_data_temp(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ p_q_inner_data_temp");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pq: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  p: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  new_nonce: "); ++stages.back(); types.push_back(mtpc_int256+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  expires_in: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_p_q_inner_data_temp_dc(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ p_q_inner_data_temp_dc");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pq: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  p: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  new_nonce: "); ++stages.back(); types.push_back(mtpc_int256+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  dc: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  expires_in: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_bind_auth_key_inner(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ bind_auth_key_inner");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  temp_auth_key_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  perm_auth_key_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  temp_session_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  expires_at: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_server_DH_params_fail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ server_DH_params_fail");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  new_nonce_hash: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_server_DH_params_ok(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ server_DH_params_ok");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  encrypted_answer: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_server_DH_inner_data(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ server_DH_inner_data");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  g: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  dh_prime: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  g_a: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  server_time: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_client_DH_inner_data(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ client_DH_inner_data");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  retry_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  g_b: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_dh_gen_ok(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dh_gen_ok");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  new_nonce_hash1: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_dh_gen_retry(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dh_gen_retry");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  new_nonce_hash2: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_dh_gen_fail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dh_gen_fail");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  new_nonce_hash3: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_destroy_auth_key_ok(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ destroy_auth_key_ok }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_destroy_auth_key_none(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ destroy_auth_key_none }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_destroy_auth_key_fail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ destroy_auth_key_fail }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_msgs_ack(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ msgs_ack");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_ids: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_bad_msg_notification(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ bad_msg_notification");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  bad_msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bad_msg_seqno: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  error_code: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_bad_server_salt(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ bad_server_salt");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  bad_msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bad_msg_seqno: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  error_code: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  new_server_salt: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_msgs_state_req(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ msgs_state_req");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_ids: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_msgs_state_info(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ msgs_state_info");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  req_msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  info: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_msgs_all_info(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ msgs_all_info");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_ids: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  info: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_msg_detailed_info(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ msg_detailed_info");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  answer_msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  status: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_msg_new_detailed_info(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ msg_new_detailed_info");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  answer_msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  status: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_msg_resend_req(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ msg_resend_req");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_ids: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_rpc_error(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ rpc_error");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  error_code: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  error_message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_rpc_answer_unknown(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ rpc_answer_unknown }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_rpc_answer_dropped_running(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ rpc_answer_dropped_running }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_rpc_answer_dropped(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ rpc_answer_dropped");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  seq_no: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_future_salt(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ future_salt");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  valid_since: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  valid_until: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  salt: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_future_salts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ future_salts");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  req_msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  now: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  salts: "); ++stages.back(); types.push_back(mtpc_vector); vtypes.push_back(mtpc_future_salt); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pong(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pong");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  ping_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_destroy_session_ok(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ destroy_session_ok");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  session_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_destroy_session_none(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ destroy_session_none");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  session_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_new_session_created(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ new_session_created");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  first_msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  unique_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  server_salt: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_http_wait(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ http_wait");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  max_delay: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  wait_after: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  max_wait: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_ipPort(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ ipPort");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  ipv4: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  port: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_ipPortSecret(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ ipPortSecret");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  ipv4: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  port: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  secret: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_accessPointRule(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ accessPointRule");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_prefix_rules: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  ips: "); ++stages.back(); types.push_back(mtpc_vector); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_configSimple(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_configSimple");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  rules: "); ++stages.back(); types.push_back(mtpc_vector); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_tlsClientHello(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ tlsClientHello");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  blocks: "); ++stages.back(); types.push_back(mtpc_vector); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_tlsBlockString(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ tlsBlockString");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  data: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_tlsBlockRandom(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ tlsBlockRandom");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_tlsBlockZero(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ tlsBlockZero");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_tlsBlockDomain(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ tlsBlockDomain }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_tlsBlockGrease(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ tlsBlockGrease");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  seed: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_tlsBlockPublicKey(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ tlsBlockPublicKey }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_tlsBlockScope(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ tlsBlockScope");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  entries: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_boolFalse(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ boolFalse }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_boolTrue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ boolTrue }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_true(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ true }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_error(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ error");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  code: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_null(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ null }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPeerEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPeerEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPeerSelf(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPeerSelf }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPeerChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPeerChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPeerUser(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPeerUser");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPeerChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPeerChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPeerUserFromMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPeerUserFromMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPeerChannelFromMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPeerChannelFromMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputUserEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputUserEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputUserSelf(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputUserSelf }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputUser(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputUser");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputUserFromMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputUserFromMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPhoneContact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPhoneContact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  client_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  first_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  last_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  parts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  md5_checksum: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputFileBig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputFileBig");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  parts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMediaEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMediaUploadedPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputMediaUploadedPhoto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaUploadedPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  stickers: "); ++stages.back(); if (flag & MTPDinputMediaUploadedPhoto::Flag::f_stickers) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  ttl_seconds: "); ++stages.back(); if (flag & MTPDinputMediaUploadedPhoto::Flag::f_ttl_seconds) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputMediaPhoto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  ttl_seconds: "); ++stages.back(); if (flag & MTPDinputMediaPhoto::Flag::f_ttl_seconds) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaGeoPoint(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaGeoPoint");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  geo_point: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaContact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaContact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  first_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  last_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  vcard: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaUploadedDocument(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputMediaUploadedDocument::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaUploadedDocument");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  nosound_video: "); ++stages.back(); if (flag & MTPDinputMediaUploadedDocument::Flag::f_nosound_video) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 2: to.add("  force_file: "); ++stages.back(); if (flag & MTPDinputMediaUploadedDocument::Flag::f_force_file) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 3: to.add("  file: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  thumb: "); ++stages.back(); if (flag & MTPDinputMediaUploadedDocument::Flag::f_thumb) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  mime_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  attributes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  stickers: "); ++stages.back(); if (flag & MTPDinputMediaUploadedDocument::Flag::f_stickers) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 8: to.add("  ttl_seconds: "); ++stages.back(); if (flag & MTPDinputMediaUploadedDocument::Flag::f_ttl_seconds) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaDocument(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputMediaDocument::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaDocument");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  ttl_seconds: "); ++stages.back(); if (flag & MTPDinputMediaDocument::Flag::f_ttl_seconds) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  query: "); ++stages.back(); if (flag & MTPDinputMediaDocument::Flag::f_query) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaVenue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaVenue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  geo_point: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  address: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  provider: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  venue_id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  venue_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaPhotoExternal(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputMediaPhotoExternal::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaPhotoExternal");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  ttl_seconds: "); ++stages.back(); if (flag & MTPDinputMediaPhotoExternal::Flag::f_ttl_seconds) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaDocumentExternal(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputMediaDocumentExternal::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaDocumentExternal");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  ttl_seconds: "); ++stages.back(); if (flag & MTPDinputMediaDocumentExternal::Flag::f_ttl_seconds) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaGame(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaGame");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaInvoice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputMediaInvoice::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaInvoice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  description: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  photo: "); ++stages.back(); if (flag & MTPDinputMediaInvoice::Flag::f_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  invoice: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  payload: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  provider: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  provider_data: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  start_param: "); ++stages.back(); if (flag & MTPDinputMediaInvoice::Flag::f_start_param) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaGeoLive(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputMediaGeoLive::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaGeoLive");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  stopped: "); ++stages.back(); if (flag & MTPDinputMediaGeoLive::Flag::f_stopped) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  geo_point: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  heading: "); ++stages.back(); if (flag & MTPDinputMediaGeoLive::Flag::f_heading) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  period: "); ++stages.back(); if (flag & MTPDinputMediaGeoLive::Flag::f_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  proximity_notification_radius: "); ++stages.back(); if (flag & MTPDinputMediaGeoLive::Flag::f_proximity_notification_radius) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaPoll(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputMediaPoll::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaPoll");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  poll: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  correct_answers: "); ++stages.back(); if (flag & MTPDinputMediaPoll::Flag::f_correct_answers) { types.push_back(0); vtypes.push_back(mtpc_bytes+0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  solution: "); ++stages.back(); if (flag & MTPDinputMediaPoll::Flag::f_solution) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  solution_entities: "); ++stages.back(); if (flag & MTPDinputMediaPoll::Flag::f_solution_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMediaDice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMediaDice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  emoticon: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputChatPhotoEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputChatPhotoEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputChatUploadedPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputChatUploadedPhoto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputChatUploadedPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file: "); ++stages.back(); if (flag & MTPDinputChatUploadedPhoto::Flag::f_file) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  video: "); ++stages.back(); if (flag & MTPDinputChatUploadedPhoto::Flag::f_video) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  video_start_ts: "); ++stages.back(); if (flag & MTPDinputChatUploadedPhoto::Flag::f_video_start_ts) { types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputChatPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputChatPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputGeoPointEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputGeoPointEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputGeoPoint(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputGeoPoint::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputGeoPoint");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  lat: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  long: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  accuracy_radius: "); ++stages.back(); if (flag & MTPDinputGeoPoint::Flag::f_accuracy_radius) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPhotoEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPhotoEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  file_reference: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputFileLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputFileLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  volume_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  local_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  secret: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  file_reference: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputEncryptedFileLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputEncryptedFileLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputDocumentFileLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputDocumentFileLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  file_reference: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  thumb_size: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputSecureFileLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputSecureFileLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputTakeoutFileLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputTakeoutFileLocation }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPhotoFileLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPhotoFileLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  file_reference: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  thumb_size: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPhotoLegacyFileLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPhotoLegacyFileLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  file_reference: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  volume_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  local_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  secret: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPeerPhotoFileLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputPeerPhotoFileLocation::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPeerPhotoFileLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  big: "); ++stages.back(); if (flag & MTPDinputPeerPhotoFileLocation::Flag::f_big) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  photo_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputStickerSetThumb(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputStickerSetThumb");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  thumb_version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputGroupCallStream(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputGroupCallStream::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputGroupCallStream");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  time_ms: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  scale: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  video_channel: "); ++stages.back(); if (flag & MTPDinputGroupCallStream::Flag::f_video_channel) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  video_quality: "); ++stages.back(); if (flag & MTPDinputGroupCallStream::Flag::f_video_quality) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_peerUser(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ peerUser");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_peerChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ peerChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_peerChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ peerChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_storage_fileUnknown(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ storage_fileUnknown }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_storage_filePartial(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ storage_filePartial }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_storage_fileJpeg(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ storage_fileJpeg }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_storage_fileGif(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ storage_fileGif }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_storage_filePng(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ storage_filePng }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_storage_filePdf(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ storage_filePdf }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_storage_fileMp3(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ storage_fileMp3 }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_storage_fileMov(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ storage_fileMov }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_storage_fileMp4(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ storage_fileMp4 }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_storage_fileWebp(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ storage_fileWebp }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_userEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ userEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_user(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDuser::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ user");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  self: "); ++stages.back(); if (flag & MTPDuser::Flag::f_self) { to.add("YES [ BY BIT 10 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 2: to.add("  contact: "); ++stages.back(); if (flag & MTPDuser::Flag::f_contact) { to.add("YES [ BY BIT 11 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 3: to.add("  mutual_contact: "); ++stages.back(); if (flag & MTPDuser::Flag::f_mutual_contact) { to.add("YES [ BY BIT 12 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	case 4: to.add("  deleted: "); ++stages.back(); if (flag & MTPDuser::Flag::f_deleted) { to.add("YES [ BY BIT 13 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 5: to.add("  bot: "); ++stages.back(); if (flag & MTPDuser::Flag::f_bot) { to.add("YES [ BY BIT 14 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 6: to.add("  bot_chat_history: "); ++stages.back(); if (flag & MTPDuser::Flag::f_bot_chat_history) { to.add("YES [ BY BIT 15 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	case 7: to.add("  bot_nochats: "); ++stages.back(); if (flag & MTPDuser::Flag::f_bot_nochats) { to.add("YES [ BY BIT 16 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 16 IN FIELD flags ]"); } break;
	case 8: to.add("  verified: "); ++stages.back(); if (flag & MTPDuser::Flag::f_verified) { to.add("YES [ BY BIT 17 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 17 IN FIELD flags ]"); } break;
	case 9: to.add("  restricted: "); ++stages.back(); if (flag & MTPDuser::Flag::f_restricted) { to.add("YES [ BY BIT 18 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 18 IN FIELD flags ]"); } break;
	case 10: to.add("  min: "); ++stages.back(); if (flag & MTPDuser::Flag::f_min) { to.add("YES [ BY BIT 20 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 20 IN FIELD flags ]"); } break;
	case 11: to.add("  bot_inline_geo: "); ++stages.back(); if (flag & MTPDuser::Flag::f_bot_inline_geo) { to.add("YES [ BY BIT 21 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 21 IN FIELD flags ]"); } break;
	case 12: to.add("  support: "); ++stages.back(); if (flag & MTPDuser::Flag::f_support) { to.add("YES [ BY BIT 23 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 23 IN FIELD flags ]"); } break;
	case 13: to.add("  scam: "); ++stages.back(); if (flag & MTPDuser::Flag::f_scam) { to.add("YES [ BY BIT 24 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 24 IN FIELD flags ]"); } break;
	case 14: to.add("  apply_min_photo: "); ++stages.back(); if (flag & MTPDuser::Flag::f_apply_min_photo) { to.add("YES [ BY BIT 25 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 25 IN FIELD flags ]"); } break;
	case 15: to.add("  fake: "); ++stages.back(); if (flag & MTPDuser::Flag::f_fake) { to.add("YES [ BY BIT 26 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 26 IN FIELD flags ]"); } break;
	case 16: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 17: to.add("  access_hash: "); ++stages.back(); if (flag & MTPDuser::Flag::f_access_hash) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 18: to.add("  first_name: "); ++stages.back(); if (flag & MTPDuser::Flag::f_first_name) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 19: to.add("  last_name: "); ++stages.back(); if (flag & MTPDuser::Flag::f_last_name) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 20: to.add("  username: "); ++stages.back(); if (flag & MTPDuser::Flag::f_username) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 21: to.add("  phone: "); ++stages.back(); if (flag & MTPDuser::Flag::f_phone) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 22: to.add("  photo: "); ++stages.back(); if (flag & MTPDuser::Flag::f_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 23: to.add("  status: "); ++stages.back(); if (flag & MTPDuser::Flag::f_status) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 24: to.add("  bot_info_version: "); ++stages.back(); if (flag & MTPDuser::Flag::f_bot_info_version) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 25: to.add("  restriction_reason: "); ++stages.back(); if (flag & MTPDuser::Flag::f_restriction_reason) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 18 IN FIELD flags ]"); } break;
	case 26: to.add("  bot_inline_placeholder: "); ++stages.back(); if (flag & MTPDuser::Flag::f_bot_inline_placeholder) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 19 IN FIELD flags ]"); } break;
	case 27: to.add("  lang_code: "); ++stages.back(); if (flag & MTPDuser::Flag::f_lang_code) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 22 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_userProfilePhotoEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ userProfilePhotoEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_userProfilePhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDuserProfilePhoto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ userProfilePhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  has_video: "); ++stages.back(); if (flag & MTPDuserProfilePhoto::Flag::f_has_video) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  photo_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  stripped_thumb: "); ++stages.back(); if (flag & MTPDuserProfilePhoto::Flag::f_stripped_thumb) { types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_userStatusEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ userStatusEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_userStatusOnline(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ userStatusOnline");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_userStatusOffline(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ userStatusOffline");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  was_online: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_userStatusRecently(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ userStatusRecently }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_userStatusLastWeek(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ userStatusLastWeek }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_userStatusLastMonth(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ userStatusLastMonth }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_chatEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchat::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  creator: "); ++stages.back(); if (flag & MTPDchat::Flag::f_creator) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  kicked: "); ++stages.back(); if (flag & MTPDchat::Flag::f_kicked) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  left: "); ++stages.back(); if (flag & MTPDchat::Flag::f_left) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  deactivated: "); ++stages.back(); if (flag & MTPDchat::Flag::f_deactivated) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 5: to.add("  call_active: "); ++stages.back(); if (flag & MTPDchat::Flag::f_call_active) { to.add("YES [ BY BIT 23 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 23 IN FIELD flags ]"); } break;
	case 6: to.add("  call_not_empty: "); ++stages.back(); if (flag & MTPDchat::Flag::f_call_not_empty) { to.add("YES [ BY BIT 24 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 24 IN FIELD flags ]"); } break;
	case 7: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  participants_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  migrated_to: "); ++stages.back(); if (flag & MTPDchat::Flag::f_migrated_to) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 14: to.add("  admin_rights: "); ++stages.back(); if (flag & MTPDchat::Flag::f_admin_rights) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 15: to.add("  default_banned_rights: "); ++stages.back(); if (flag & MTPDchat::Flag::f_default_banned_rights) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 18 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatForbidden(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatForbidden");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchannel::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  creator: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_creator) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  left: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_left) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 3: to.add("  broadcast: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_broadcast) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 4: to.add("  verified: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_verified) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 5: to.add("  megagroup: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_megagroup) { to.add("YES [ BY BIT 8 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 6: to.add("  restricted: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_restricted) { to.add("YES [ BY BIT 9 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 7: to.add("  signatures: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_signatures) { to.add("YES [ BY BIT 11 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 8: to.add("  min: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_min) { to.add("YES [ BY BIT 12 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	case 9: to.add("  scam: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_scam) { to.add("YES [ BY BIT 19 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 19 IN FIELD flags ]"); } break;
	case 10: to.add("  has_link: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_has_link) { to.add("YES [ BY BIT 20 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 20 IN FIELD flags ]"); } break;
	case 11: to.add("  has_geo: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_has_geo) { to.add("YES [ BY BIT 21 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 21 IN FIELD flags ]"); } break;
	case 12: to.add("  slowmode_enabled: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_slowmode_enabled) { to.add("YES [ BY BIT 22 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 22 IN FIELD flags ]"); } break;
	case 13: to.add("  call_active: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_call_active) { to.add("YES [ BY BIT 23 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 23 IN FIELD flags ]"); } break;
	case 14: to.add("  call_not_empty: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_call_not_empty) { to.add("YES [ BY BIT 24 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 24 IN FIELD flags ]"); } break;
	case 15: to.add("  fake: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_fake) { to.add("YES [ BY BIT 25 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 25 IN FIELD flags ]"); } break;
	case 16: to.add("  gigagroup: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_gigagroup) { to.add("YES [ BY BIT 26 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 26 IN FIELD flags ]"); } break;
	case 17: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 18: to.add("  access_hash: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_access_hash) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 19: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 20: to.add("  username: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_username) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 21: to.add("  photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 22: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 23: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 24: to.add("  restriction_reason: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_restriction_reason) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 25: to.add("  admin_rights: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_admin_rights) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 26: to.add("  banned_rights: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_banned_rights) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	case 27: to.add("  default_banned_rights: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_default_banned_rights) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 18 IN FIELD flags ]"); } break;
	case 28: to.add("  participants_count: "); ++stages.back(); if (flag & MTPDchannel::Flag::f_participants_count) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 17 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelForbidden(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchannelForbidden::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelForbidden");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  broadcast: "); ++stages.back(); if (flag & MTPDchannelForbidden::Flag::f_broadcast) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 2: to.add("  megagroup: "); ++stages.back(); if (flag & MTPDchannelForbidden::Flag::f_megagroup) { to.add("YES [ BY BIT 8 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 3: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  until_date: "); ++stages.back(); if (flag & MTPDchannelForbidden::Flag::f_until_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 16 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatFull(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchatFull::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatFull");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  can_set_username: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_can_set_username) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 2: to.add("  has_scheduled: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_has_scheduled) { to.add("YES [ BY BIT 8 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 3: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  about: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  participants: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  chat_photo: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_chat_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 7: to.add("  notify_settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  exported_invite: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_exported_invite) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 9: to.add("  bot_info: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_bot_info) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 10: to.add("  pinned_msg_id: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_pinned_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 11: to.add("  folder_id: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 12: to.add("  call: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_call) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	case 13: to.add("  ttl_period: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_ttl_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 14: to.add("  groupcall_default_join_as: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_groupcall_default_join_as) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	case 15: to.add("  theme_emoticon: "); ++stages.back(); if (flag & MTPDchatFull::Flag::f_theme_emoticon) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 16 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelFull(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchannelFull::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelFull");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  can_view_participants: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_can_view_participants) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 2: to.add("  can_set_username: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_can_set_username) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 3: to.add("  can_set_stickers: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_can_set_stickers) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 4: to.add("  hidden_prehistory: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_hidden_prehistory) { to.add("YES [ BY BIT 10 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 5: to.add("  can_set_location: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_can_set_location) { to.add("YES [ BY BIT 16 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 16 IN FIELD flags ]"); } break;
	case 6: to.add("  has_scheduled: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_has_scheduled) { to.add("YES [ BY BIT 19 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 19 IN FIELD flags ]"); } break;
	case 7: to.add("  can_view_stats: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_can_view_stats) { to.add("YES [ BY BIT 20 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 20 IN FIELD flags ]"); } break;
	case 8: to.add("  blocked: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_blocked) { to.add("YES [ BY BIT 22 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 22 IN FIELD flags ]"); } break;
	case 9: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  about: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  participants_count: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_participants_count) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 12: to.add("  admins_count: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_admins_count) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 13: to.add("  kicked_count: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_kicked_count) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 14: to.add("  banned_count: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_banned_count) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 15: to.add("  online_count: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_online_count) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 16: to.add("  read_inbox_max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 17: to.add("  read_outbox_max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 18: to.add("  unread_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 19: to.add("  chat_photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 20: to.add("  notify_settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 21: to.add("  exported_invite: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_exported_invite) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 23 IN FIELD flags ]"); } break;
	case 22: to.add("  bot_info: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 23: to.add("  migrated_from_chat_id: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_migrated_from_chat_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 24: to.add("  migrated_from_max_id: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_migrated_from_max_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 25: to.add("  pinned_msg_id: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_pinned_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 26: to.add("  stickerset: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_stickerset) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 27: to.add("  available_min_id: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_available_min_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 28: to.add("  folder_id: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 29: to.add("  linked_chat_id: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_linked_chat_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 30: to.add("  location: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_location) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	case 31: to.add("  slowmode_seconds: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_slowmode_seconds) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 17 IN FIELD flags ]"); } break;
	case 32: to.add("  slowmode_next_send_date: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_slowmode_next_send_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 18 IN FIELD flags ]"); } break;
	case 33: to.add("  stats_dc: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_stats_dc) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	case 34: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 35: to.add("  call: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_call) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 21 IN FIELD flags ]"); } break;
	case 36: to.add("  ttl_period: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_ttl_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 24 IN FIELD flags ]"); } break;
	case 37: to.add("  pending_suggestions: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_pending_suggestions) { types.push_back(0); vtypes.push_back(mtpc_string+0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 25 IN FIELD flags ]"); } break;
	case 38: to.add("  groupcall_default_join_as: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_groupcall_default_join_as) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 26 IN FIELD flags ]"); } break;
	case 39: to.add("  theme_emoticon: "); ++stages.back(); if (flag & MTPDchannelFull::Flag::f_theme_emoticon) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 27 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatParticipant(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatParticipant");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  inviter_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatParticipantCreator(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatParticipantCreator");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatParticipantAdmin(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatParticipantAdmin");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  inviter_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatParticipantsForbidden(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchatParticipantsForbidden::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatParticipantsForbidden");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  self_participant: "); ++stages.back(); if (flag & MTPDchatParticipantsForbidden::Flag::f_self_participant) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  participants: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatPhotoEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ chatPhotoEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_chatPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchatPhoto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  has_video: "); ++stages.back(); if (flag & MTPDchatPhoto::Flag::f_has_video) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  photo_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  stripped_thumb: "); ++stages.back(); if (flag & MTPDchatPhoto::Flag::f_stripped_thumb) { types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageEmpty::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  peer_id: "); ++stages.back(); if (flag & MTPDmessageEmpty::Flag::f_peer_id) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_message(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ message");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  out: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_out) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  mentioned: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_mentioned) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 3: to.add("  media_unread: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_media_unread) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 4: to.add("  silent: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_silent) { to.add("YES [ BY BIT 13 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 5: to.add("  post: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_post) { to.add("YES [ BY BIT 14 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 6: to.add("  from_scheduled: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_from_scheduled) { to.add("YES [ BY BIT 18 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 18 IN FIELD flags ]"); } break;
	case 7: to.add("  legacy: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_legacy) { to.add("YES [ BY BIT 19 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 19 IN FIELD flags ]"); } break;
	case 8: to.add("  edit_hide: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_edit_hide) { to.add("YES [ BY BIT 21 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 21 IN FIELD flags ]"); } break;
	case 9: to.add("  pinned: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_pinned) { to.add("YES [ BY BIT 24 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 24 IN FIELD flags ]"); } break;
	case 10: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  from_id: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_from_id) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 12: to.add("  peer_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  fwd_from: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_fwd_from) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 14: to.add("  via_bot_id: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_via_bot_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 15: to.add("  reply_to: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_reply_to) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 16: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 17: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 18: to.add("  media: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_media) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 19: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 20: to.add("  entities: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 21: to.add("  views: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_views) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 22: to.add("  forwards: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_forwards) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 23: to.add("  replies: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_replies) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 23 IN FIELD flags ]"); } break;
	case 24: to.add("  edit_date: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_edit_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	case 25: to.add("  post_author: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_post_author) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 16 IN FIELD flags ]"); } break;
	case 26: to.add("  grouped_id: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_grouped_id) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 17 IN FIELD flags ]"); } break;
	case 27: to.add("  restriction_reason: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_restriction_reason) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 22 IN FIELD flags ]"); } break;
	case 28: to.add("  ttl_period: "); ++stages.back(); if (flag & MTPDmessage::Flag::f_ttl_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 25 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageService(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageService::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageService");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  out: "); ++stages.back(); if (flag & MTPDmessageService::Flag::f_out) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  mentioned: "); ++stages.back(); if (flag & MTPDmessageService::Flag::f_mentioned) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 3: to.add("  media_unread: "); ++stages.back(); if (flag & MTPDmessageService::Flag::f_media_unread) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 4: to.add("  silent: "); ++stages.back(); if (flag & MTPDmessageService::Flag::f_silent) { to.add("YES [ BY BIT 13 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 5: to.add("  post: "); ++stages.back(); if (flag & MTPDmessageService::Flag::f_post) { to.add("YES [ BY BIT 14 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 6: to.add("  legacy: "); ++stages.back(); if (flag & MTPDmessageService::Flag::f_legacy) { to.add("YES [ BY BIT 19 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 19 IN FIELD flags ]"); } break;
	case 7: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  from_id: "); ++stages.back(); if (flag & MTPDmessageService::Flag::f_from_id) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 9: to.add("  peer_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  reply_to: "); ++stages.back(); if (flag & MTPDmessageService::Flag::f_reply_to) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 11: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  action: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  ttl_period: "); ++stages.back(); if (flag & MTPDmessageService::Flag::f_ttl_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 25 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messageMediaEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messageMediaPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageMediaPhoto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  photo: "); ++stages.back(); if (flag & MTPDmessageMediaPhoto::Flag::f_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  ttl_seconds: "); ++stages.back(); if (flag & MTPDmessageMediaPhoto::Flag::f_ttl_seconds) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaGeo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaGeo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  geo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaContact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaContact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  first_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  last_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  vcard: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaUnsupported(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messageMediaUnsupported }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messageMediaDocument(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageMediaDocument::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaDocument");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  document: "); ++stages.back(); if (flag & MTPDmessageMediaDocument::Flag::f_document) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  ttl_seconds: "); ++stages.back(); if (flag & MTPDmessageMediaDocument::Flag::f_ttl_seconds) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaWebPage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaWebPage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  webpage: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaVenue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaVenue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  geo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  address: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  provider: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  venue_id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  venue_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaGame(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaGame");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  game: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaInvoice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageMediaInvoice::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaInvoice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  shipping_address_requested: "); ++stages.back(); if (flag & MTPDmessageMediaInvoice::Flag::f_shipping_address_requested) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  test: "); ++stages.back(); if (flag & MTPDmessageMediaInvoice::Flag::f_test) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 3: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  description: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  photo: "); ++stages.back(); if (flag & MTPDmessageMediaInvoice::Flag::f_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  receipt_msg_id: "); ++stages.back(); if (flag & MTPDmessageMediaInvoice::Flag::f_receipt_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 7: to.add("  currency: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  total_amount: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  start_param: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaGeoLive(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageMediaGeoLive::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaGeoLive");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  geo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  heading: "); ++stages.back(); if (flag & MTPDmessageMediaGeoLive::Flag::f_heading) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  period: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  proximity_notification_radius: "); ++stages.back(); if (flag & MTPDmessageMediaGeoLive::Flag::f_proximity_notification_radius) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaPoll(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaPoll");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  poll: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  results: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageMediaDice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageMediaDice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  value: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  emoticon: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messageActionEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messageActionChatCreate(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionChatCreate");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionChatEditTitle(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionChatEditTitle");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionChatEditPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionChatEditPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionChatDeletePhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messageActionChatDeletePhoto }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messageActionChatAddUser(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionChatAddUser");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionChatDeleteUser(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionChatDeleteUser");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionChatJoinedByLink(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionChatJoinedByLink");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  inviter_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionChannelCreate(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionChannelCreate");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionChatMigrateTo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionChatMigrateTo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionChannelMigrateFrom(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionChannelMigrateFrom");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionPinMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messageActionPinMessage }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messageActionHistoryClear(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messageActionHistoryClear }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messageActionGameScore(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionGameScore");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  game_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  score: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionPaymentSentMe(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageActionPaymentSentMe::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionPaymentSentMe");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  currency: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  total_amount: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  payload: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  info: "); ++stages.back(); if (flag & MTPDmessageActionPaymentSentMe::Flag::f_info) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  shipping_option_id: "); ++stages.back(); if (flag & MTPDmessageActionPaymentSentMe::Flag::f_shipping_option_id) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 6: to.add("  charge: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionPaymentSent(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionPaymentSent");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  currency: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  total_amount: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionPhoneCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageActionPhoneCall::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionPhoneCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  video: "); ++stages.back(); if (flag & MTPDmessageActionPhoneCall::Flag::f_video) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 2: to.add("  call_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  reason: "); ++stages.back(); if (flag & MTPDmessageActionPhoneCall::Flag::f_reason) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  duration: "); ++stages.back(); if (flag & MTPDmessageActionPhoneCall::Flag::f_duration) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionScreenshotTaken(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messageActionScreenshotTaken }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messageActionCustomAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionCustomAction");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionBotAllowed(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionBotAllowed");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  domain: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionSecureValuesSentMe(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionSecureValuesSentMe");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  values: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  credentials: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionSecureValuesSent(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionSecureValuesSent");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  types: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionContactSignUp(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messageActionContactSignUp }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messageActionGeoProximityReached(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionGeoProximityReached");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  from_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  to_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  distance: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageActionGroupCall::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  duration: "); ++stages.back(); if (flag & MTPDmessageActionGroupCall::Flag::f_duration) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionInviteToGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionInviteToGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionSetMessagesTTL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionSetMessagesTTL");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  period: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionGroupCallScheduled(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionGroupCallScheduled");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  schedule_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageActionSetChatTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageActionSetChatTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  emoticon: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_dialog(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDdialog::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dialog");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pinned: "); ++stages.back(); if (flag & MTPDdialog::Flag::f_pinned) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 2: to.add("  unread_mark: "); ++stages.back(); if (flag & MTPDdialog::Flag::f_unread_mark) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 3: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  top_message: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  read_inbox_max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  read_outbox_max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  unread_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  unread_mentions_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  notify_settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  pts: "); ++stages.back(); if (flag & MTPDdialog::Flag::f_pts) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 11: to.add("  draft: "); ++stages.back(); if (flag & MTPDdialog::Flag::f_draft) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 12: to.add("  folder_id: "); ++stages.back(); if (flag & MTPDdialog::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_dialogFolder(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDdialogFolder::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dialogFolder");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pinned: "); ++stages.back(); if (flag & MTPDdialogFolder::Flag::f_pinned) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 2: to.add("  folder: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  top_message: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  unread_muted_peers_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  unread_unmuted_peers_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  unread_muted_messages_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  unread_unmuted_messages_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photoEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photoEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDphoto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  has_stickers: "); ++stages.back(); if (flag & MTPDphoto::Flag::f_has_stickers) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  file_reference: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  sizes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  video_sizes: "); ++stages.back(); if (flag & MTPDphoto::Flag::f_video_sizes) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 8: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photoSizeEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photoSizeEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photoSize(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photoSize");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  w: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  h: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  size: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photoCachedSize(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photoCachedSize");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  w: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  h: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photoStrippedSize(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photoStrippedSize");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photoSizeProgressive(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photoSizeProgressive");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  w: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  h: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  sizes: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photoPathSize(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photoPathSize");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_geoPointEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ geoPointEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_geoPoint(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDgeoPoint::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ geoPoint");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  long: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  lat: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  accuracy_radius: "); ++stages.back(); if (flag & MTPDgeoPoint::Flag::f_accuracy_radius) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_sentCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDauth_sentCode::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_sentCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  phone_code_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  next_type: "); ++stages.back(); if (flag & MTPDauth_sentCode::Flag::f_next_type) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  timeout: "); ++stages.back(); if (flag & MTPDauth_sentCode::Flag::f_timeout) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_authorization(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDauth_authorization::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_authorization");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  tmp_sessions: "); ++stages.back(); if (flag & MTPDauth_authorization::Flag::f_tmp_sessions) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  user: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_authorizationSignUpRequired(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDauth_authorizationSignUpRequired::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_authorizationSignUpRequired");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  terms_of_service: "); ++stages.back(); if (flag & MTPDauth_authorizationSignUpRequired::Flag::f_terms_of_service) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_exportedAuthorization(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_exportedAuthorization");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputNotifyPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputNotifyPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputNotifyUsers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputNotifyUsers }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputNotifyChats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputNotifyChats }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputNotifyBroadcasts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputNotifyBroadcasts }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPeerNotifySettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputPeerNotifySettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPeerNotifySettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  show_previews: "); ++stages.back(); if (flag & MTPDinputPeerNotifySettings::Flag::f_show_previews) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  silent: "); ++stages.back(); if (flag & MTPDinputPeerNotifySettings::Flag::f_silent) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  mute_until: "); ++stages.back(); if (flag & MTPDinputPeerNotifySettings::Flag::f_mute_until) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  sound: "); ++stages.back(); if (flag & MTPDinputPeerNotifySettings::Flag::f_sound) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_peerNotifySettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpeerNotifySettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ peerNotifySettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  show_previews: "); ++stages.back(); if (flag & MTPDpeerNotifySettings::Flag::f_show_previews) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  silent: "); ++stages.back(); if (flag & MTPDpeerNotifySettings::Flag::f_silent) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  mute_until: "); ++stages.back(); if (flag & MTPDpeerNotifySettings::Flag::f_mute_until) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  sound: "); ++stages.back(); if (flag & MTPDpeerNotifySettings::Flag::f_sound) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_peerSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpeerSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ peerSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  report_spam: "); ++stages.back(); if (flag & MTPDpeerSettings::Flag::f_report_spam) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  add_contact: "); ++stages.back(); if (flag & MTPDpeerSettings::Flag::f_add_contact) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  block_contact: "); ++stages.back(); if (flag & MTPDpeerSettings::Flag::f_block_contact) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  share_contact: "); ++stages.back(); if (flag & MTPDpeerSettings::Flag::f_share_contact) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  need_contacts_exception: "); ++stages.back(); if (flag & MTPDpeerSettings::Flag::f_need_contacts_exception) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  report_geo: "); ++stages.back(); if (flag & MTPDpeerSettings::Flag::f_report_geo) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 7: to.add("  autoarchived: "); ++stages.back(); if (flag & MTPDpeerSettings::Flag::f_autoarchived) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 8: to.add("  invite_members: "); ++stages.back(); if (flag & MTPDpeerSettings::Flag::f_invite_members) { to.add("YES [ BY BIT 8 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 9: to.add("  geo_distance: "); ++stages.back(); if (flag & MTPDpeerSettings::Flag::f_geo_distance) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_wallPaper(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDwallPaper::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ wallPaper");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  creator: "); ++stages.back(); if (flag & MTPDwallPaper::Flag::f_creator) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  default: "); ++stages.back(); if (flag & MTPDwallPaper::Flag::f_default) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  pattern: "); ++stages.back(); if (flag & MTPDwallPaper::Flag::f_pattern) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  dark: "); ++stages.back(); if (flag & MTPDwallPaper::Flag::f_dark) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  slug: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  document: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  settings: "); ++stages.back(); if (flag & MTPDwallPaper::Flag::f_settings) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_wallPaperNoFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDwallPaperNoFile::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ wallPaperNoFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  default: "); ++stages.back(); if (flag & MTPDwallPaperNoFile::Flag::f_default) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  dark: "); ++stages.back(); if (flag & MTPDwallPaperNoFile::Flag::f_dark) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 4: to.add("  settings: "); ++stages.back(); if (flag & MTPDwallPaperNoFile::Flag::f_settings) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputReportReasonSpam(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputReportReasonSpam }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputReportReasonViolence(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputReportReasonViolence }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputReportReasonPornography(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputReportReasonPornography }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputReportReasonChildAbuse(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputReportReasonChildAbuse }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputReportReasonOther(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputReportReasonOther }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputReportReasonCopyright(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputReportReasonCopyright }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputReportReasonGeoIrrelevant(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputReportReasonGeoIrrelevant }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputReportReasonFake(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputReportReasonFake }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_userFull(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDuserFull::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ userFull");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  blocked: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_blocked) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  phone_calls_available: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_phone_calls_available) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 3: to.add("  phone_calls_private: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_phone_calls_private) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 4: to.add("  can_pin_message: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_can_pin_message) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 5: to.add("  has_scheduled: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_has_scheduled) { to.add("YES [ BY BIT 12 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	case 6: to.add("  video_calls_available: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_video_calls_available) { to.add("YES [ BY BIT 13 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 7: to.add("  user: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  about: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_about) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 9: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  profile_photo: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_profile_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 11: to.add("  notify_settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  bot_info: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_bot_info) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 13: to.add("  pinned_msg_id: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_pinned_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 14: to.add("  common_chats_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 15: to.add("  folder_id: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 16: to.add("  ttl_period: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_ttl_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 17: to.add("  theme_emoticon: "); ++stages.back(); if (flag & MTPDuserFull::Flag::f_theme_emoticon) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  mutual: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_importedContact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ importedContact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  client_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contactStatus(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contactStatus");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  status: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_contactsNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ contacts_contactsNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_contacts_contacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_contacts");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  contacts: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  saved_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_importedContacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_importedContacts");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  imported: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  popular_invites: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  retry_contacts: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_blocked(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_blocked");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  blocked: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_blockedSlice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_blockedSlice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  blocked: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_dialogs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_dialogs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  dialogs: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_dialogsSlice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_dialogsSlice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  dialogs: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_dialogsNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_dialogsNotModified");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_messages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_messages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_messagesSlice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessages_messagesSlice::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_messagesSlice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  inexact: "); ++stages.back(); if (flag & MTPDmessages_messagesSlice::Flag::f_inexact) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  next_rate: "); ++stages.back(); if (flag & MTPDmessages_messagesSlice::Flag::f_next_rate) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  offset_id_offset: "); ++stages.back(); if (flag & MTPDmessages_messagesSlice::Flag::f_offset_id_offset) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_channelMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessages_channelMessages::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_channelMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  inexact: "); ++stages.back(); if (flag & MTPDmessages_channelMessages::Flag::f_inexact) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  offset_id_offset: "); ++stages.back(); if (flag & MTPDmessages_channelMessages::Flag::f_offset_id_offset) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_messagesNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_messagesNotModified");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_chats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_chats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_chatsSlice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_chatsSlice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_chatFull(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_chatFull");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  full_chat: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_affectedHistory(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_affectedHistory");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMessagesFilterEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterPhotos(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterPhotos }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterVideo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterVideo }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterPhotoVideo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterPhotoVideo }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterDocument(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterDocument }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterUrl(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterUrl }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterGif(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterGif }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterVoice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterVoice }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterMusic(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterMusic }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterChatPhotos(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterChatPhotos }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterPhoneCalls(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputMessagesFilterPhoneCalls::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMessagesFilterPhoneCalls");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  missed: "); ++stages.back(); if (flag & MTPDinputMessagesFilterPhoneCalls::Flag::f_missed) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMessagesFilterRoundVoice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterRoundVoice }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterRoundVideo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterRoundVideo }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterMyMentions(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterMyMentions }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterGeo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterGeo }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterContacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterContacts }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessagesFilterPinned(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagesFilterPinned }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updateNewMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateNewMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateMessageID(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateMessageID");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateDeleteMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateDeleteMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateUserTyping(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateUserTyping");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  action: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChatUserTyping(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChatUserTyping");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  from_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  action: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChatParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChatParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  participants: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateUserStatus(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateUserStatus");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  status: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateUserName(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateUserName");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  first_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  last_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  username: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateUserPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateUserPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  previous: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateNewEncryptedMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateNewEncryptedMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  qts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateEncryptedChatTyping(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateEncryptedChatTyping");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateEncryption(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateEncryption");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateEncryptedMessagesRead(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateEncryptedMessagesRead");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  max_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChatParticipantAdd(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChatParticipantAdd");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  inviter_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChatParticipantDelete(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChatParticipantDelete");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateDcOptions(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateDcOptions");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  dc_options: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateNotifySettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateNotifySettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  notify_settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateServiceNotification(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateServiceNotification::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateServiceNotification");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  popup: "); ++stages.back(); if (flag & MTPDupdateServiceNotification::Flag::f_popup) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  inbox_date: "); ++stages.back(); if (flag & MTPDupdateServiceNotification::Flag::f_inbox_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  media: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  entities: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatePrivacy(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatePrivacy");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  key: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  rules: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateUserPhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateUserPhone");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateReadHistoryInbox(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateReadHistoryInbox::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateReadHistoryInbox");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  folder_id: "); ++stages.back(); if (flag & MTPDupdateReadHistoryInbox::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  still_unread_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateReadHistoryOutbox(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateReadHistoryOutbox");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateWebPage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateWebPage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  webpage: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateReadMessagesContents(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateReadMessagesContents");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChannelTooLong(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateChannelTooLong::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChannelTooLong");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts: "); ++stages.back(); if (flag & MTPDupdateChannelTooLong::Flag::f_pts) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateNewChannelMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateNewChannelMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateReadChannelInbox(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateReadChannelInbox::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateReadChannelInbox");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  folder_id: "); ++stages.back(); if (flag & MTPDupdateReadChannelInbox::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  still_unread_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateDeleteChannelMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateDeleteChannelMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChannelMessageViews(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChannelMessageViews");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  views: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChatParticipantAdmin(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChatParticipantAdmin");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  is_admin: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateNewStickerSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateNewStickerSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateStickerSetsOrder(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateStickerSetsOrder::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateStickerSetsOrder");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  masks: "); ++stages.back(); if (flag & MTPDupdateStickerSetsOrder::Flag::f_masks) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  order: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateStickerSets(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updateStickerSets }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updateSavedGifs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updateSavedGifs }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updateBotInlineQuery(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateBotInlineQuery::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateBotInlineQuery");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  query: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  geo: "); ++stages.back(); if (flag & MTPDupdateBotInlineQuery::Flag::f_geo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  peer_type: "); ++stages.back(); if (flag & MTPDupdateBotInlineQuery::Flag::f_peer_type) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 6: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateBotInlineSend(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateBotInlineSend::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateBotInlineSend");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  query: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  geo: "); ++stages.back(); if (flag & MTPDupdateBotInlineSend::Flag::f_geo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  msg_id: "); ++stages.back(); if (flag & MTPDupdateBotInlineSend::Flag::f_msg_id) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateEditChannelMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateEditChannelMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateBotCallbackQuery(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateBotCallbackQuery::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateBotCallbackQuery");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  chat_instance: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  data: "); ++stages.back(); if (flag & MTPDupdateBotCallbackQuery::Flag::f_data) { types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 7: to.add("  game_short_name: "); ++stages.back(); if (flag & MTPDupdateBotCallbackQuery::Flag::f_game_short_name) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateEditMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateEditMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateInlineBotCallbackQuery(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateInlineBotCallbackQuery::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateInlineBotCallbackQuery");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  msg_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  chat_instance: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  data: "); ++stages.back(); if (flag & MTPDupdateInlineBotCallbackQuery::Flag::f_data) { types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  game_short_name: "); ++stages.back(); if (flag & MTPDupdateInlineBotCallbackQuery::Flag::f_game_short_name) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateReadChannelOutbox(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateReadChannelOutbox");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateDraftMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateDraftMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  draft: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateReadFeaturedStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updateReadFeaturedStickers }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updateRecentStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updateRecentStickers }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updateConfig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updateConfig }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updatePtsChanged(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updatePtsChanged }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updateChannelWebPage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChannelWebPage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  webpage: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateDialogPinned(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateDialogPinned::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateDialogPinned");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pinned: "); ++stages.back(); if (flag & MTPDupdateDialogPinned::Flag::f_pinned) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  folder_id: "); ++stages.back(); if (flag & MTPDupdateDialogPinned::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatePinnedDialogs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdatePinnedDialogs::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatePinnedDialogs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  folder_id: "); ++stages.back(); if (flag & MTPDupdatePinnedDialogs::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  order: "); ++stages.back(); if (flag & MTPDupdatePinnedDialogs::Flag::f_order) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateBotWebhookJSON(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateBotWebhookJSON");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  data: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateBotWebhookJSONQuery(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateBotWebhookJSONQuery");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  data: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  timeout: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateBotShippingQuery(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateBotShippingQuery");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  payload: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  shipping_address: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateBotPrecheckoutQuery(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateBotPrecheckoutQuery::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateBotPrecheckoutQuery");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  payload: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  info: "); ++stages.back(); if (flag & MTPDupdateBotPrecheckoutQuery::Flag::f_info) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  shipping_option_id: "); ++stages.back(); if (flag & MTPDupdateBotPrecheckoutQuery::Flag::f_shipping_option_id) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 6: to.add("  currency: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  total_amount: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatePhoneCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatePhoneCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateLangPackTooLong(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateLangPackTooLong");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateLangPack(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateLangPack");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  difference: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateFavedStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updateFavedStickers }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updateChannelReadMessagesContents(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChannelReadMessagesContents");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateContactsReset(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updateContactsReset }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updateChannelAvailableMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChannelAvailableMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  available_min_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateDialogUnreadMark(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateDialogUnreadMark::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateDialogUnreadMark");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  unread: "); ++stages.back(); if (flag & MTPDupdateDialogUnreadMark::Flag::f_unread) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateMessagePoll(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateMessagePoll::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateMessagePoll");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  poll_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  poll: "); ++stages.back(); if (flag & MTPDupdateMessagePoll::Flag::f_poll) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  results: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChatDefaultBannedRights(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChatDefaultBannedRights");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  default_banned_rights: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateFolderPeers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateFolderPeers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  folder_peers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatePeerSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatePeerSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatePeerLocated(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatePeerLocated");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateNewScheduledMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateNewScheduledMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateDeleteScheduledMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateDeleteScheduledMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  theme: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateGeoLiveViewed(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateGeoLiveViewed");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateLoginToken(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updateLoginToken }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updateMessagePollVote(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateMessagePollVote");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  poll_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  options: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_bytes+0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  qts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateDialogFilter(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateDialogFilter::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateDialogFilter");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  filter: "); ++stages.back(); if (flag & MTPDupdateDialogFilter::Flag::f_filter) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateDialogFilterOrder(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateDialogFilterOrder");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  order: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateDialogFilters(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updateDialogFilters }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updatePhoneCallSignalingData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatePhoneCallSignalingData");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_call_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  data: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChannelMessageForwards(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChannelMessageForwards");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  forwards: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateReadChannelDiscussionInbox(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateReadChannelDiscussionInbox::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateReadChannelDiscussionInbox");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  top_msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  read_max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  broadcast_id: "); ++stages.back(); if (flag & MTPDupdateReadChannelDiscussionInbox::Flag::f_broadcast_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  broadcast_post: "); ++stages.back(); if (flag & MTPDupdateReadChannelDiscussionInbox::Flag::f_broadcast_post) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateReadChannelDiscussionOutbox(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateReadChannelDiscussionOutbox");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  top_msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  read_max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatePeerBlocked(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatePeerBlocked");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  blocked: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChannelUserTyping(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateChannelUserTyping::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChannelUserTyping");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  top_msg_id: "); ++stages.back(); if (flag & MTPDupdateChannelUserTyping::Flag::f_top_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  from_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  action: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatePinnedMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdatePinnedMessages::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatePinnedMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pinned: "); ++stages.back(); if (flag & MTPDupdatePinnedMessages::Flag::f_pinned) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatePinnedChannelMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdatePinnedChannelMessages::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatePinnedChannelMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pinned: "); ++stages.back(); if (flag & MTPDupdatePinnedChannelMessages::Flag::f_pinned) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateGroupCallParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateGroupCallParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  participants: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatePeerHistoryTTL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdatePeerHistoryTTL::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatePeerHistoryTTL");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  ttl_period: "); ++stages.back(); if (flag & MTPDupdatePeerHistoryTTL::Flag::f_ttl_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChatParticipant(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateChatParticipant::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChatParticipant");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  actor_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  prev_participant: "); ++stages.back(); if (flag & MTPDupdateChatParticipant::Flag::f_prev_participant) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  new_participant: "); ++stages.back(); if (flag & MTPDupdateChatParticipant::Flag::f_new_participant) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 7: to.add("  invite: "); ++stages.back(); if (flag & MTPDupdateChatParticipant::Flag::f_invite) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 8: to.add("  qts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateChannelParticipant(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateChannelParticipant::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateChannelParticipant");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  actor_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  prev_participant: "); ++stages.back(); if (flag & MTPDupdateChannelParticipant::Flag::f_prev_participant) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  new_participant: "); ++stages.back(); if (flag & MTPDupdateChannelParticipant::Flag::f_new_participant) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 7: to.add("  invite: "); ++stages.back(); if (flag & MTPDupdateChannelParticipant::Flag::f_invite) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 8: to.add("  qts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateBotStopped(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateBotStopped");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  stopped: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  qts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateGroupCallConnection(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateGroupCallConnection::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateGroupCallConnection");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  presentation: "); ++stages.back(); if (flag & MTPDupdateGroupCallConnection::Flag::f_presentation) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  params: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateBotCommands(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateBotCommands");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bot_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  commands: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates_state(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates_state");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  qts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  seq: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  unread_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates_differenceEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates_differenceEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  seq: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates_difference(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates_difference");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  new_messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_encrypted_messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  other_updates: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  state: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates_differenceSlice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates_differenceSlice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  new_messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_encrypted_messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  other_updates: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  intermediate_state: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates_differenceTooLong(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates_differenceTooLong");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatesTooLong(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updatesTooLong }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updateShortMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateShortMessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateShortMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  out: "); ++stages.back(); if (flag & MTPDupdateShortMessage::Flag::f_out) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  mentioned: "); ++stages.back(); if (flag & MTPDupdateShortMessage::Flag::f_mentioned) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 3: to.add("  media_unread: "); ++stages.back(); if (flag & MTPDupdateShortMessage::Flag::f_media_unread) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 4: to.add("  silent: "); ++stages.back(); if (flag & MTPDupdateShortMessage::Flag::f_silent) { to.add("YES [ BY BIT 13 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 5: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  fwd_from: "); ++stages.back(); if (flag & MTPDupdateShortMessage::Flag::f_fwd_from) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 12: to.add("  via_bot_id: "); ++stages.back(); if (flag & MTPDupdateShortMessage::Flag::f_via_bot_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 13: to.add("  reply_to: "); ++stages.back(); if (flag & MTPDupdateShortMessage::Flag::f_reply_to) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 14: to.add("  entities: "); ++stages.back(); if (flag & MTPDupdateShortMessage::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 15: to.add("  ttl_period: "); ++stages.back(); if (flag & MTPDupdateShortMessage::Flag::f_ttl_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 25 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateShortChatMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateShortChatMessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateShortChatMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  out: "); ++stages.back(); if (flag & MTPDupdateShortChatMessage::Flag::f_out) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  mentioned: "); ++stages.back(); if (flag & MTPDupdateShortChatMessage::Flag::f_mentioned) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 3: to.add("  media_unread: "); ++stages.back(); if (flag & MTPDupdateShortChatMessage::Flag::f_media_unread) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 4: to.add("  silent: "); ++stages.back(); if (flag & MTPDupdateShortChatMessage::Flag::f_silent) { to.add("YES [ BY BIT 13 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 5: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  from_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  fwd_from: "); ++stages.back(); if (flag & MTPDupdateShortChatMessage::Flag::f_fwd_from) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 13: to.add("  via_bot_id: "); ++stages.back(); if (flag & MTPDupdateShortChatMessage::Flag::f_via_bot_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 14: to.add("  reply_to: "); ++stages.back(); if (flag & MTPDupdateShortChatMessage::Flag::f_reply_to) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 15: to.add("  entities: "); ++stages.back(); if (flag & MTPDupdateShortChatMessage::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 16: to.add("  ttl_period: "); ++stages.back(); if (flag & MTPDupdateShortChatMessage::Flag::f_ttl_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 25 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateShort(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateShort");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  update: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updatesCombined(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updatesCombined");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  updates: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  seq_start: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  seq: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  updates: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  seq: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updateShortSentMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdateShortSentMessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updateShortSentMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  out: "); ++stages.back(); if (flag & MTPDupdateShortSentMessage::Flag::f_out) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  media: "); ++stages.back(); if (flag & MTPDupdateShortSentMessage::Flag::f_media) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 7: to.add("  entities: "); ++stages.back(); if (flag & MTPDupdateShortSentMessage::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 8: to.add("  ttl_period: "); ++stages.back(); if (flag & MTPDupdateShortSentMessage::Flag::f_ttl_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 25 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photos_photos(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photos_photos");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  photos: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photos_photosSlice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photos_photosSlice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  photos: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photos_photo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photos_photo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_file(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_file");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  mtime: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_fileCdnRedirect(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_fileCdnRedirect");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file_token: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  encryption_key: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  encryption_iv: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  file_hashes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_dcOption(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDdcOption::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dcOption");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  ipv6: "); ++stages.back(); if (flag & MTPDdcOption::Flag::f_ipv6) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  media_only: "); ++stages.back(); if (flag & MTPDdcOption::Flag::f_media_only) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  tcpo_only: "); ++stages.back(); if (flag & MTPDdcOption::Flag::f_tcpo_only) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  cdn: "); ++stages.back(); if (flag & MTPDdcOption::Flag::f_cdn) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  static: "); ++stages.back(); if (flag & MTPDdcOption::Flag::f_static) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  ip_address: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  port: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  secret: "); ++stages.back(); if (flag & MTPDdcOption::Flag::f_secret) { types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_config(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDconfig::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ config");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phonecalls_enabled: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_phonecalls_enabled) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  default_p2p_contacts: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_default_p2p_contacts) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 3: to.add("  preload_featured_stickers: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_preload_featured_stickers) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 4: to.add("  ignore_phone_entities: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_ignore_phone_entities) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 5: to.add("  revoke_pm_inbox: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_revoke_pm_inbox) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 6: to.add("  blocked_mode: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_blocked_mode) { to.add("YES [ BY BIT 8 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 7: to.add("  pfs_enabled: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_pfs_enabled) { to.add("YES [ BY BIT 13 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 8: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  test_mode: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  this_dc: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  dc_options: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  dc_txt_domain_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 14: to.add("  chat_size_max: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 15: to.add("  megagroup_size_max: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 16: to.add("  forwarded_count_max: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 17: to.add("  online_update_period_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 18: to.add("  offline_blur_timeout_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 19: to.add("  offline_idle_timeout_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 20: to.add("  online_cloud_timeout_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 21: to.add("  notify_cloud_delay_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 22: to.add("  notify_default_delay_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 23: to.add("  push_chat_period_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 24: to.add("  push_chat_limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 25: to.add("  saved_gifs_limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 26: to.add("  edit_time_limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 27: to.add("  revoke_time_limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 28: to.add("  revoke_pm_time_limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 29: to.add("  rating_e_decay: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 30: to.add("  stickers_recent_limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 31: to.add("  stickers_faved_limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 32: to.add("  channels_read_media_period: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 33: to.add("  tmp_sessions: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_tmp_sessions) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 34: to.add("  pinned_dialogs_count_max: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 35: to.add("  pinned_infolder_count_max: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 36: to.add("  call_receive_timeout_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 37: to.add("  call_ring_timeout_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 38: to.add("  call_connect_timeout_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 39: to.add("  call_packet_timeout_ms: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 40: to.add("  me_url_prefix: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 41: to.add("  autoupdate_url_prefix: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_autoupdate_url_prefix) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 42: to.add("  gif_search_username: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_gif_search_username) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 43: to.add("  venue_search_username: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_venue_search_username) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 44: to.add("  img_search_username: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_img_search_username) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 45: to.add("  static_maps_provider: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_static_maps_provider) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	case 46: to.add("  caption_length_max: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 47: to.add("  message_length_max: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 48: to.add("  webfile_dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 49: to.add("  suggested_lang_code: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_suggested_lang_code) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 50: to.add("  lang_pack_version: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_lang_pack_version) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 51: to.add("  base_lang_pack_version: "); ++stages.back(); if (flag & MTPDconfig::Flag::f_base_lang_pack_version) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_nearestDc(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ nearestDc");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  country: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  this_dc: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  nearest_dc: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_appUpdate(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDhelp_appUpdate::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_appUpdate");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  can_not_skip: "); ++stages.back(); if (flag & MTPDhelp_appUpdate::Flag::f_can_not_skip) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  version: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  entities: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  document: "); ++stages.back(); if (flag & MTPDhelp_appUpdate::Flag::f_document) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 7: to.add("  url: "); ++stages.back(); if (flag & MTPDhelp_appUpdate::Flag::f_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 8: to.add("  sticker: "); ++stages.back(); if (flag & MTPDhelp_appUpdate::Flag::f_sticker) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_noAppUpdate(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_noAppUpdate }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_inviteText(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_inviteText");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_encryptedChatEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ encryptedChatEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_encryptedChatWaiting(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ encryptedChatWaiting");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  admin_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  participant_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_encryptedChatRequested(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDencryptedChatRequested::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ encryptedChatRequested");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  folder_id: "); ++stages.back(); if (flag & MTPDencryptedChatRequested::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  admin_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  participant_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  g_a: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_encryptedChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ encryptedChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  admin_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  participant_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  g_a_or_b: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  key_fingerprint: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_encryptedChatDiscarded(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDencryptedChatDiscarded::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ encryptedChatDiscarded");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  history_deleted: "); ++stages.back(); if (flag & MTPDencryptedChatDiscarded::Flag::f_history_deleted) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputEncryptedChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputEncryptedChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_encryptedFileEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ encryptedFileEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_encryptedFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ encryptedFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  size: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  key_fingerprint: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputEncryptedFileEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputEncryptedFileEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputEncryptedFileUploaded(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputEncryptedFileUploaded");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  parts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  md5_checksum: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  key_fingerprint: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputEncryptedFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputEncryptedFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputEncryptedFileBigUploaded(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputEncryptedFileBigUploaded");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  parts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  key_fingerprint: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_encryptedMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ encryptedMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  file: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_encryptedMessageService(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ encryptedMessageService");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_dhConfigNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_dhConfigNotModified");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  random: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_dhConfig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_dhConfig");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  g: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  p: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  random: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sentEncryptedMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sentEncryptedMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sentEncryptedFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sentEncryptedFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputDocumentEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputDocumentEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputDocument(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputDocument");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  file_reference: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_documentEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ documentEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_document(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDdocument::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ document");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  file_reference: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  mime_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  size: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  thumbs: "); ++stages.back(); if (flag & MTPDdocument::Flag::f_thumbs) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 8: to.add("  video_thumbs: "); ++stages.back(); if (flag & MTPDdocument::Flag::f_video_thumbs) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 9: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  attributes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_support(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_support");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_notifyPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ notifyPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_notifyUsers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ notifyUsers }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_notifyChats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ notifyChats }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_notifyBroadcasts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ notifyBroadcasts }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_sendMessageTypingAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ sendMessageTypingAction }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_sendMessageCancelAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ sendMessageCancelAction }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_sendMessageRecordVideoAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ sendMessageRecordVideoAction }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_sendMessageUploadVideoAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ sendMessageUploadVideoAction");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  progress: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_sendMessageRecordAudioAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ sendMessageRecordAudioAction }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_sendMessageUploadAudioAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ sendMessageUploadAudioAction");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  progress: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_sendMessageUploadPhotoAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ sendMessageUploadPhotoAction");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  progress: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_sendMessageUploadDocumentAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ sendMessageUploadDocumentAction");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  progress: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_sendMessageGeoLocationAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ sendMessageGeoLocationAction }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_sendMessageChooseContactAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ sendMessageChooseContactAction }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_sendMessageGamePlayAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ sendMessageGamePlayAction }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_sendMessageRecordRoundAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ sendMessageRecordRoundAction }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_sendMessageUploadRoundAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ sendMessageUploadRoundAction");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  progress: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_speakingInGroupCallAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ speakingInGroupCallAction }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_sendMessageHistoryImportAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ sendMessageHistoryImportAction");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  progress: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_sendMessageChooseStickerAction(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ sendMessageChooseStickerAction }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_contacts_found(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_found");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  my_results: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  results: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPrivacyKeyStatusTimestamp(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyKeyStatusTimestamp }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyKeyChatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyKeyChatInvite }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyKeyPhoneCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyKeyPhoneCall }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyKeyPhoneP2P(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyKeyPhoneP2P }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyKeyForwards(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyKeyForwards }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyKeyProfilePhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyKeyProfilePhoto }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyKeyPhoneNumber(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyKeyPhoneNumber }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyKeyAddedByPhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyKeyAddedByPhone }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyKeyStatusTimestamp(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyKeyStatusTimestamp }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyKeyChatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyKeyChatInvite }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyKeyPhoneCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyKeyPhoneCall }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyKeyPhoneP2P(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyKeyPhoneP2P }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyKeyForwards(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyKeyForwards }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyKeyProfilePhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyKeyProfilePhoto }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyKeyPhoneNumber(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyKeyPhoneNumber }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyKeyAddedByPhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyKeyAddedByPhone }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyValueAllowContacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyValueAllowContacts }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyValueAllowAll(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyValueAllowAll }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyValueAllowUsers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPrivacyValueAllowUsers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPrivacyValueDisallowContacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyValueDisallowContacts }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyValueDisallowAll(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputPrivacyValueDisallowAll }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputPrivacyValueDisallowUsers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPrivacyValueDisallowUsers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPrivacyValueAllowChatParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPrivacyValueAllowChatParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPrivacyValueDisallowChatParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPrivacyValueDisallowChatParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_privacyValueAllowContacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyValueAllowContacts }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyValueAllowAll(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyValueAllowAll }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyValueAllowUsers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ privacyValueAllowUsers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_privacyValueDisallowContacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyValueDisallowContacts }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyValueDisallowAll(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ privacyValueDisallowAll }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_privacyValueDisallowUsers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ privacyValueDisallowUsers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_privacyValueAllowChatParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ privacyValueAllowChatParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_privacyValueDisallowChatParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ privacyValueDisallowChatParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_privacyRules(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_privacyRules");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  rules: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_accountDaysTTL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ accountDaysTTL");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  days: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_documentAttributeImageSize(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ documentAttributeImageSize");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  w: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  h: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_documentAttributeAnimated(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ documentAttributeAnimated }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_documentAttributeSticker(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDdocumentAttributeSticker::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ documentAttributeSticker");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  mask: "); ++stages.back(); if (flag & MTPDdocumentAttributeSticker::Flag::f_mask) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  alt: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  mask_coords: "); ++stages.back(); if (flag & MTPDdocumentAttributeSticker::Flag::f_mask_coords) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_documentAttributeVideo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDdocumentAttributeVideo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ documentAttributeVideo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  round_message: "); ++stages.back(); if (flag & MTPDdocumentAttributeVideo::Flag::f_round_message) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  supports_streaming: "); ++stages.back(); if (flag & MTPDdocumentAttributeVideo::Flag::f_supports_streaming) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  duration: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  w: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  h: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_documentAttributeAudio(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDdocumentAttributeAudio::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ documentAttributeAudio");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  voice: "); ++stages.back(); if (flag & MTPDdocumentAttributeAudio::Flag::f_voice) { to.add("YES [ BY BIT 10 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 2: to.add("  duration: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  title: "); ++stages.back(); if (flag & MTPDdocumentAttributeAudio::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  performer: "); ++stages.back(); if (flag & MTPDdocumentAttributeAudio::Flag::f_performer) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  waveform: "); ++stages.back(); if (flag & MTPDdocumentAttributeAudio::Flag::f_waveform) { types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_documentAttributeFilename(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ documentAttributeFilename");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  file_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_documentAttributeHasStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ documentAttributeHasStickers }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_stickersNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_stickersNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_stickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_stickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  stickers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickerPack(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickerPack");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  emoticon: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  documents: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_allStickersNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_allStickersNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_allStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_allStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  sets: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_affectedMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_affectedMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_webPageEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ webPageEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_webPagePending(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ webPagePending");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_webPage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDwebPage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ webPage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  display_url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  type: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_type) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  site_name: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_site_name) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 7: to.add("  title: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 8: to.add("  description: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_description) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 9: to.add("  photo: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 10: to.add("  embed_url: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_embed_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 11: to.add("  embed_type: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_embed_type) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 12: to.add("  embed_width: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_embed_width) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 13: to.add("  embed_height: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_embed_height) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 14: to.add("  duration: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_duration) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 15: to.add("  author: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_author) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 16: to.add("  document: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_document) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 17: to.add("  cached_page: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_cached_page) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 18: to.add("  attributes: "); ++stages.back(); if (flag & MTPDwebPage::Flag::f_attributes) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_webPageNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDwebPageNotModified::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ webPageNotModified");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  cached_page_views: "); ++stages.back(); if (flag & MTPDwebPageNotModified::Flag::f_cached_page_views) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_authorization(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDauthorization::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ authorization");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  current: "); ++stages.back(); if (flag & MTPDauthorization::Flag::f_current) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  official_app: "); ++stages.back(); if (flag & MTPDauthorization::Flag::f_official_app) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  password_pending: "); ++stages.back(); if (flag & MTPDauthorization::Flag::f_password_pending) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  device_model: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  platform: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  system_version: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  api_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  app_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  app_version: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  date_created: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  date_active: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  ip: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 14: to.add("  country: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 15: to.add("  region: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_authorizations(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_authorizations");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  authorizations: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_password(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDaccount_password::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_password");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  has_recovery: "); ++stages.back(); if (flag & MTPDaccount_password::Flag::f_has_recovery) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  has_secure_values: "); ++stages.back(); if (flag & MTPDaccount_password::Flag::f_has_secure_values) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  has_password: "); ++stages.back(); if (flag & MTPDaccount_password::Flag::f_has_password) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  current_algo: "); ++stages.back(); if (flag & MTPDaccount_password::Flag::f_current_algo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  srp_B: "); ++stages.back(); if (flag & MTPDaccount_password::Flag::f_srp_B) { types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 6: to.add("  srp_id: "); ++stages.back(); if (flag & MTPDaccount_password::Flag::f_srp_id) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 7: to.add("  hint: "); ++stages.back(); if (flag & MTPDaccount_password::Flag::f_hint) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 8: to.add("  email_unconfirmed_pattern: "); ++stages.back(); if (flag & MTPDaccount_password::Flag::f_email_unconfirmed_pattern) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 9: to.add("  new_algo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  new_secure_algo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  secure_random: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  pending_reset_date: "); ++stages.back(); if (flag & MTPDaccount_password::Flag::f_pending_reset_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_passwordSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDaccount_passwordSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_passwordSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  email: "); ++stages.back(); if (flag & MTPDaccount_passwordSettings::Flag::f_email) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  secure_settings: "); ++stages.back(); if (flag & MTPDaccount_passwordSettings::Flag::f_secure_settings) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_passwordInputSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDaccount_passwordInputSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_passwordInputSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_algo: "); ++stages.back(); if (flag & MTPDaccount_passwordInputSettings::Flag::f_new_algo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  new_password_hash: "); ++stages.back(); if (flag & MTPDaccount_passwordInputSettings::Flag::f_new_password_hash) { types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  hint: "); ++stages.back(); if (flag & MTPDaccount_passwordInputSettings::Flag::f_hint) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  email: "); ++stages.back(); if (flag & MTPDaccount_passwordInputSettings::Flag::f_email) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  new_secure_settings: "); ++stages.back(); if (flag & MTPDaccount_passwordInputSettings::Flag::f_new_secure_settings) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_passwordRecovery(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_passwordRecovery");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  email_pattern: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_receivedNotifyMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ receivedNotifyMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  flags: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatInviteExported(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchatInviteExported::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatInviteExported");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  revoked: "); ++stages.back(); if (flag & MTPDchatInviteExported::Flag::f_revoked) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  permanent: "); ++stages.back(); if (flag & MTPDchatInviteExported::Flag::f_permanent) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 3: to.add("  link: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  admin_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  start_date: "); ++stages.back(); if (flag & MTPDchatInviteExported::Flag::f_start_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 7: to.add("  expire_date: "); ++stages.back(); if (flag & MTPDchatInviteExported::Flag::f_expire_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 8: to.add("  usage_limit: "); ++stages.back(); if (flag & MTPDchatInviteExported::Flag::f_usage_limit) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 9: to.add("  usage: "); ++stages.back(); if (flag & MTPDchatInviteExported::Flag::f_usage) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatInviteAlready(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatInviteAlready");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchatInvite::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  channel: "); ++stages.back(); if (flag & MTPDchatInvite::Flag::f_channel) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  broadcast: "); ++stages.back(); if (flag & MTPDchatInvite::Flag::f_broadcast) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  public: "); ++stages.back(); if (flag & MTPDchatInvite::Flag::f_public) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  megagroup: "); ++stages.back(); if (flag & MTPDchatInvite::Flag::f_megagroup) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  participants_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  participants: "); ++stages.back(); if (flag & MTPDchatInvite::Flag::f_participants) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatInvitePeek(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatInvitePeek");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputStickerSetEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputStickerSetEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputStickerSetID(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputStickerSetID");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputStickerSetShortName(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputStickerSetShortName");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  short_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputStickerSetAnimatedEmoji(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputStickerSetAnimatedEmoji }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputStickerSetDice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputStickerSetDice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  emoticon: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickerSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDstickerSet::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickerSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  archived: "); ++stages.back(); if (flag & MTPDstickerSet::Flag::f_archived) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  official: "); ++stages.back(); if (flag & MTPDstickerSet::Flag::f_official) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 3: to.add("  masks: "); ++stages.back(); if (flag & MTPDstickerSet::Flag::f_masks) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 4: to.add("  animated: "); ++stages.back(); if (flag & MTPDstickerSet::Flag::f_animated) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 5: to.add("  installed_date: "); ++stages.back(); if (flag & MTPDstickerSet::Flag::f_installed_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  short_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  thumbs: "); ++stages.back(); if (flag & MTPDstickerSet::Flag::f_thumbs) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 11: to.add("  thumb_dc_id: "); ++stages.back(); if (flag & MTPDstickerSet::Flag::f_thumb_dc_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 12: to.add("  thumb_version: "); ++stages.back(); if (flag & MTPDstickerSet::Flag::f_thumb_version) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 13: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 14: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_stickerSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_stickerSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  set: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  packs: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  documents: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botCommand(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botCommand");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  command: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  description: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  description: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  commands: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButton(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButton");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButtonUrl(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButtonUrl");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButtonCallback(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDkeyboardButtonCallback::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButtonCallback");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  requires_password: "); ++stages.back(); if (flag & MTPDkeyboardButtonCallback::Flag::f_requires_password) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  data: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButtonRequestPhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButtonRequestPhone");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButtonRequestGeoLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButtonRequestGeoLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButtonSwitchInline(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDkeyboardButtonSwitchInline::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButtonSwitchInline");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  same_peer: "); ++stages.back(); if (flag & MTPDkeyboardButtonSwitchInline::Flag::f_same_peer) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  query: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButtonGame(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButtonGame");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButtonBuy(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButtonBuy");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButtonUrlAuth(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDkeyboardButtonUrlAuth::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButtonUrlAuth");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  fwd_text: "); ++stages.back(); if (flag & MTPDkeyboardButtonUrlAuth::Flag::f_fwd_text) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  button_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputKeyboardButtonUrlAuth(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputKeyboardButtonUrlAuth::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputKeyboardButtonUrlAuth");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  request_write_access: "); ++stages.back(); if (flag & MTPDinputKeyboardButtonUrlAuth::Flag::f_request_write_access) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  fwd_text: "); ++stages.back(); if (flag & MTPDinputKeyboardButtonUrlAuth::Flag::f_fwd_text) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  bot: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButtonRequestPoll(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDkeyboardButtonRequestPoll::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButtonRequestPoll");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  quiz: "); ++stages.back(); if (flag & MTPDkeyboardButtonRequestPoll::Flag::f_quiz) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_keyboardButtonRow(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ keyboardButtonRow");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  buttons: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_replyKeyboardHide(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDreplyKeyboardHide::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ replyKeyboardHide");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  selective: "); ++stages.back(); if (flag & MTPDreplyKeyboardHide::Flag::f_selective) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_replyKeyboardForceReply(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDreplyKeyboardForceReply::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ replyKeyboardForceReply");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  single_use: "); ++stages.back(); if (flag & MTPDreplyKeyboardForceReply::Flag::f_single_use) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  selective: "); ++stages.back(); if (flag & MTPDreplyKeyboardForceReply::Flag::f_selective) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 3: to.add("  placeholder: "); ++stages.back(); if (flag & MTPDreplyKeyboardForceReply::Flag::f_placeholder) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_replyKeyboardMarkup(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDreplyKeyboardMarkup::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ replyKeyboardMarkup");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  resize: "); ++stages.back(); if (flag & MTPDreplyKeyboardMarkup::Flag::f_resize) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  single_use: "); ++stages.back(); if (flag & MTPDreplyKeyboardMarkup::Flag::f_single_use) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  selective: "); ++stages.back(); if (flag & MTPDreplyKeyboardMarkup::Flag::f_selective) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  rows: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  placeholder: "); ++stages.back(); if (flag & MTPDreplyKeyboardMarkup::Flag::f_placeholder) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_replyInlineMarkup(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ replyInlineMarkup");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  rows: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityUnknown(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityUnknown");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityMention(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityMention");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityHashtag(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityHashtag");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityBotCommand(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityBotCommand");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityUrl(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityUrl");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityEmail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityEmail");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityBold(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityBold");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityItalic(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityItalic");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityPre(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityPre");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  language: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityTextUrl(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityTextUrl");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityMentionName(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityMentionName");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMessageEntityMentionName(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMessageEntityMentionName");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityPhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityPhone");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityCashtag(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityCashtag");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityUnderline(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityUnderline");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityStrike(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityStrike");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityBlockquote(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityBlockquote");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageEntityBankCard(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageEntityBankCard");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputChannelEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputChannelEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputChannelFromMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputChannelFromMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  channel_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_resolvedPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_resolvedPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageRange(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageRange");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  min_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates_channelDifferenceEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdates_channelDifferenceEmpty::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates_channelDifferenceEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  final: "); ++stages.back(); if (flag & MTPDupdates_channelDifferenceEmpty::Flag::f_final) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  timeout: "); ++stages.back(); if (flag & MTPDupdates_channelDifferenceEmpty::Flag::f_timeout) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates_channelDifferenceTooLong(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdates_channelDifferenceTooLong::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates_channelDifferenceTooLong");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  final: "); ++stages.back(); if (flag & MTPDupdates_channelDifferenceTooLong::Flag::f_final) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  timeout: "); ++stages.back(); if (flag & MTPDupdates_channelDifferenceTooLong::Flag::f_timeout) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  dialog: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates_channelDifference(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDupdates_channelDifference::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates_channelDifference");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  final: "); ++stages.back(); if (flag & MTPDupdates_channelDifference::Flag::f_final) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  timeout: "); ++stages.back(); if (flag & MTPDupdates_channelDifference::Flag::f_timeout) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  new_messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  other_updates: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelMessagesFilterEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ channelMessagesFilterEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_channelMessagesFilter(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchannelMessagesFilter::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelMessagesFilter");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  exclude_new_messages: "); ++stages.back(); if (flag & MTPDchannelMessagesFilter::Flag::f_exclude_new_messages) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  ranges: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipant(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipant");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipantSelf(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipantSelf");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  inviter_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipantCreator(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchannelParticipantCreator::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipantCreator");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  admin_rights: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  rank: "); ++stages.back(); if (flag & MTPDchannelParticipantCreator::Flag::f_rank) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipantAdmin(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchannelParticipantAdmin::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipantAdmin");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  can_edit: "); ++stages.back(); if (flag & MTPDchannelParticipantAdmin::Flag::f_can_edit) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  self: "); ++stages.back(); if (flag & MTPDchannelParticipantAdmin::Flag::f_self) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  inviter_id: "); ++stages.back(); if (flag & MTPDchannelParticipantAdmin::Flag::f_inviter_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  promoted_by: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  admin_rights: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  rank: "); ++stages.back(); if (flag & MTPDchannelParticipantAdmin::Flag::f_rank) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipantBanned(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchannelParticipantBanned::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipantBanned");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  left: "); ++stages.back(); if (flag & MTPDchannelParticipantBanned::Flag::f_left) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  kicked_by: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  banned_rights: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipantLeft(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipantLeft");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipantsRecent(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ channelParticipantsRecent }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_channelParticipantsAdmins(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ channelParticipantsAdmins }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_channelParticipantsKicked(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipantsKicked");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipantsBots(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ channelParticipantsBots }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_channelParticipantsBanned(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipantsBanned");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipantsSearch(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipantsSearch");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipantsContacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipantsContacts");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelParticipantsMentions(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchannelParticipantsMentions::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelParticipantsMentions");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  q: "); ++stages.back(); if (flag & MTPDchannelParticipantsMentions::Flag::f_q) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  top_msg_id: "); ++stages.back(); if (flag & MTPDchannelParticipantsMentions::Flag::f_top_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_channelParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_channelParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  participants: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_channelParticipantsNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ channels_channelParticipantsNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_channels_channelParticipant(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_channelParticipant");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_termsOfService(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDhelp_termsOfService::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_termsOfService");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  popup: "); ++stages.back(); if (flag & MTPDhelp_termsOfService::Flag::f_popup) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  entities: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  min_age_confirm: "); ++stages.back(); if (flag & MTPDhelp_termsOfService::Flag::f_min_age_confirm) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_savedGifsNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_savedGifsNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_savedGifs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_savedGifs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  gifs: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineMessageMediaAuto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputBotInlineMessageMediaAuto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineMessageMediaAuto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  entities: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageMediaAuto::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageMediaAuto::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineMessageText(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputBotInlineMessageText::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineMessageText");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  no_webpage: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageText::Flag::f_no_webpage) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  entities: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageText::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageText::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineMessageMediaGeo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputBotInlineMessageMediaGeo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineMessageMediaGeo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  geo_point: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  heading: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageMediaGeo::Flag::f_heading) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  period: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageMediaGeo::Flag::f_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  proximity_notification_radius: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageMediaGeo::Flag::f_proximity_notification_radius) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageMediaGeo::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineMessageMediaVenue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputBotInlineMessageMediaVenue::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineMessageMediaVenue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  geo_point: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  address: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  provider: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  venue_id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  venue_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageMediaVenue::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineMessageMediaContact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputBotInlineMessageMediaContact::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineMessageMediaContact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  first_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  last_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  vcard: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageMediaContact::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineMessageGame(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputBotInlineMessageGame::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineMessageGame");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageGame::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineMessageMediaInvoice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputBotInlineMessageMediaInvoice::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineMessageMediaInvoice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  description: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  photo: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageMediaInvoice::Flag::f_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  invoice: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  payload: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  provider: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  provider_data: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDinputBotInlineMessageMediaInvoice::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineResult(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputBotInlineResult::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineResult");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  title: "); ++stages.back(); if (flag & MTPDinputBotInlineResult::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  description: "); ++stages.back(); if (flag & MTPDinputBotInlineResult::Flag::f_description) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  url: "); ++stages.back(); if (flag & MTPDinputBotInlineResult::Flag::f_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 6: to.add("  thumb: "); ++stages.back(); if (flag & MTPDinputBotInlineResult::Flag::f_thumb) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 7: to.add("  content: "); ++stages.back(); if (flag & MTPDinputBotInlineResult::Flag::f_content) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 8: to.add("  send_message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineResultPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineResultPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  send_message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineResultDocument(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputBotInlineResultDocument::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineResultDocument");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  title: "); ++stages.back(); if (flag & MTPDinputBotInlineResultDocument::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  description: "); ++stages.back(); if (flag & MTPDinputBotInlineResultDocument::Flag::f_description) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  document: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  send_message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineResultGame(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineResultGame");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  short_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  send_message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botInlineMessageMediaAuto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDbotInlineMessageMediaAuto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botInlineMessageMediaAuto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  entities: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaAuto::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaAuto::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botInlineMessageText(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDbotInlineMessageText::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botInlineMessageText");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  no_webpage: "); ++stages.back(); if (flag & MTPDbotInlineMessageText::Flag::f_no_webpage) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  entities: "); ++stages.back(); if (flag & MTPDbotInlineMessageText::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDbotInlineMessageText::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botInlineMessageMediaGeo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDbotInlineMessageMediaGeo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botInlineMessageMediaGeo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  geo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  heading: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaGeo::Flag::f_heading) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  period: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaGeo::Flag::f_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  proximity_notification_radius: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaGeo::Flag::f_proximity_notification_radius) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaGeo::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botInlineMessageMediaVenue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDbotInlineMessageMediaVenue::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botInlineMessageMediaVenue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  geo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  address: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  provider: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  venue_id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  venue_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaVenue::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botInlineMessageMediaContact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDbotInlineMessageMediaContact::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botInlineMessageMediaContact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  first_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  last_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  vcard: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaContact::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botInlineMessageMediaInvoice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDbotInlineMessageMediaInvoice::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botInlineMessageMediaInvoice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  shipping_address_requested: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaInvoice::Flag::f_shipping_address_requested) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  test: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaInvoice::Flag::f_test) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 3: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  description: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  photo: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaInvoice::Flag::f_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  currency: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  total_amount: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPDbotInlineMessageMediaInvoice::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botInlineResult(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDbotInlineResult::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botInlineResult");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  title: "); ++stages.back(); if (flag & MTPDbotInlineResult::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  description: "); ++stages.back(); if (flag & MTPDbotInlineResult::Flag::f_description) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  url: "); ++stages.back(); if (flag & MTPDbotInlineResult::Flag::f_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 6: to.add("  thumb: "); ++stages.back(); if (flag & MTPDbotInlineResult::Flag::f_thumb) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 7: to.add("  content: "); ++stages.back(); if (flag & MTPDbotInlineResult::Flag::f_content) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 8: to.add("  send_message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botInlineMediaResult(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDbotInlineMediaResult::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botInlineMediaResult");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  photo: "); ++stages.back(); if (flag & MTPDbotInlineMediaResult::Flag::f_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  document: "); ++stages.back(); if (flag & MTPDbotInlineMediaResult::Flag::f_document) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  title: "); ++stages.back(); if (flag & MTPDbotInlineMediaResult::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 6: to.add("  description: "); ++stages.back(); if (flag & MTPDbotInlineMediaResult::Flag::f_description) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 7: to.add("  send_message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_botResults(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessages_botResults::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_botResults");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  gallery: "); ++stages.back(); if (flag & MTPDmessages_botResults::Flag::f_gallery) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  next_offset: "); ++stages.back(); if (flag & MTPDmessages_botResults::Flag::f_next_offset) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  switch_pm: "); ++stages.back(); if (flag & MTPDmessages_botResults::Flag::f_switch_pm) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  results: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  cache_time: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_exportedMessageLink(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ exportedMessageLink");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  link: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  html: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageFwdHeader(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageFwdHeader::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageFwdHeader");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  imported: "); ++stages.back(); if (flag & MTPDmessageFwdHeader::Flag::f_imported) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 2: to.add("  from_id: "); ++stages.back(); if (flag & MTPDmessageFwdHeader::Flag::f_from_id) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  from_name: "); ++stages.back(); if (flag & MTPDmessageFwdHeader::Flag::f_from_name) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 4: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  channel_post: "); ++stages.back(); if (flag & MTPDmessageFwdHeader::Flag::f_channel_post) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 6: to.add("  post_author: "); ++stages.back(); if (flag & MTPDmessageFwdHeader::Flag::f_post_author) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 7: to.add("  saved_from_peer: "); ++stages.back(); if (flag & MTPDmessageFwdHeader::Flag::f_saved_from_peer) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 8: to.add("  saved_from_msg_id: "); ++stages.back(); if (flag & MTPDmessageFwdHeader::Flag::f_saved_from_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 9: to.add("  psa_type: "); ++stages.back(); if (flag & MTPDmessageFwdHeader::Flag::f_psa_type) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_codeTypeSms(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ auth_codeTypeSms }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_auth_codeTypeCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ auth_codeTypeCall }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_auth_codeTypeFlashCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ auth_codeTypeFlashCall }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_auth_sentCodeTypeApp(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_sentCodeTypeApp");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_sentCodeTypeSms(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_sentCodeTypeSms");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_sentCodeTypeCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_sentCodeTypeCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_sentCodeTypeFlashCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_sentCodeTypeFlashCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pattern: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_botCallbackAnswer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessages_botCallbackAnswer::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_botCallbackAnswer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  alert: "); ++stages.back(); if (flag & MTPDmessages_botCallbackAnswer::Flag::f_alert) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  has_url: "); ++stages.back(); if (flag & MTPDmessages_botCallbackAnswer::Flag::f_has_url) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 3: to.add("  native_ui: "); ++stages.back(); if (flag & MTPDmessages_botCallbackAnswer::Flag::f_native_ui) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 4: to.add("  message: "); ++stages.back(); if (flag & MTPDmessages_botCallbackAnswer::Flag::f_message) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  url: "); ++stages.back(); if (flag & MTPDmessages_botCallbackAnswer::Flag::f_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 6: to.add("  cache_time: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_messageEditData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessages_messageEditData::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_messageEditData");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  caption: "); ++stages.back(); if (flag & MTPDmessages_messageEditData::Flag::f_caption) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputBotInlineMessageID(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputBotInlineMessageID");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inlineBotSwitchPM(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inlineBotSwitchPM");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  start_param: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_peerDialogs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_peerDialogs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  dialogs: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  state: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_topPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ topPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  rating: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_topPeerCategoryBotsPM(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ topPeerCategoryBotsPM }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_topPeerCategoryBotsInline(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ topPeerCategoryBotsInline }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_topPeerCategoryCorrespondents(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ topPeerCategoryCorrespondents }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_topPeerCategoryGroups(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ topPeerCategoryGroups }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_topPeerCategoryChannels(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ topPeerCategoryChannels }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_topPeerCategoryPhoneCalls(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ topPeerCategoryPhoneCalls }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_topPeerCategoryForwardUsers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ topPeerCategoryForwardUsers }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_topPeerCategoryForwardChats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ topPeerCategoryForwardChats }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_topPeerCategoryPeers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ topPeerCategoryPeers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  category: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  peers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_topPeersNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ contacts_topPeersNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_contacts_topPeers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_topPeers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  categories: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_topPeersDisabled(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ contacts_topPeersDisabled }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_draftMessageEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDdraftMessageEmpty::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ draftMessageEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); if (flag & MTPDdraftMessageEmpty::Flag::f_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_draftMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDdraftMessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ draftMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  no_webpage: "); ++stages.back(); if (flag & MTPDdraftMessage::Flag::f_no_webpage) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  reply_to_msg_id: "); ++stages.back(); if (flag & MTPDdraftMessage::Flag::f_reply_to_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  entities: "); ++stages.back(); if (flag & MTPDdraftMessage::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_featuredStickersNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_featuredStickersNotModified");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_featuredStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_featuredStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  sets: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  unread: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_recentStickersNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_recentStickersNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_recentStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_recentStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  packs: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  stickers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  dates: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_archivedStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_archivedStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  sets: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_stickerSetInstallResultSuccess(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_stickerSetInstallResultSuccess }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_stickerSetInstallResultArchive(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_stickerSetInstallResultArchive");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  sets: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickerSetCovered(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickerSetCovered");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  set: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  cover: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickerSetMultiCovered(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickerSetMultiCovered");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  set: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  covers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_maskCoords(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ maskCoords");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  n: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  x: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  y: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  zoom: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputStickeredMediaPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputStickeredMediaPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputStickeredMediaDocument(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputStickeredMediaDocument");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_game(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDgame::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ game");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  short_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  description: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  document: "); ++stages.back(); if (flag & MTPDgame::Flag::f_document) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputGameID(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputGameID");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputGameShortName(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputGameShortName");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  bot_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  short_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_highScore(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ highScore");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pos: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  score: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_highScores(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_highScores");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  scores: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ textEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_textPlain(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textPlain");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textBold(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textBold");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textItalic(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textItalic");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textUnderline(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textUnderline");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textStrike(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textStrike");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textFixed(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textFixed");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textUrl(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textUrl");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  webpage_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textEmail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textEmail");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  email: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textConcat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textConcat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  texts: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textSubscript(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textSubscript");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textSuperscript(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textSuperscript");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textMarked(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textMarked");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textPhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textPhone");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textImage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textImage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  document_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  w: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  h: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_textAnchor(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ textAnchor");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockUnsupported(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ pageBlockUnsupported }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_pageBlockTitle(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockTitle");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockSubtitle(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockSubtitle");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockAuthorDate(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockAuthorDate");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  author: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  published_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockHeader(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockHeader");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockSubheader(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockSubheader");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockParagraph(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockParagraph");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockPreformatted(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockPreformatted");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  language: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockFooter(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockFooter");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockDivider(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ pageBlockDivider }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_pageBlockAnchor(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockAnchor");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockList(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockList");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  items: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockBlockquote(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockBlockquote");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  caption: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockPullquote(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockPullquote");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  caption: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpageBlockPhoto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  photo_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  caption: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  url: "); ++stages.back(); if (flag & MTPDpageBlockPhoto::Flag::f_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  webpage_id: "); ++stages.back(); if (flag & MTPDpageBlockPhoto::Flag::f_webpage_id) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockVideo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpageBlockVideo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockVideo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  autoplay: "); ++stages.back(); if (flag & MTPDpageBlockVideo::Flag::f_autoplay) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  loop: "); ++stages.back(); if (flag & MTPDpageBlockVideo::Flag::f_loop) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  video_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  caption: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockCover(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockCover");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  cover: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockEmbed(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpageBlockEmbed::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockEmbed");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  full_width: "); ++stages.back(); if (flag & MTPDpageBlockEmbed::Flag::f_full_width) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  allow_scrolling: "); ++stages.back(); if (flag & MTPDpageBlockEmbed::Flag::f_allow_scrolling) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 3: to.add("  url: "); ++stages.back(); if (flag & MTPDpageBlockEmbed::Flag::f_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  html: "); ++stages.back(); if (flag & MTPDpageBlockEmbed::Flag::f_html) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  poster_photo_id: "); ++stages.back(); if (flag & MTPDpageBlockEmbed::Flag::f_poster_photo_id) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  w: "); ++stages.back(); if (flag & MTPDpageBlockEmbed::Flag::f_w) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 7: to.add("  h: "); ++stages.back(); if (flag & MTPDpageBlockEmbed::Flag::f_h) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 8: to.add("  caption: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockEmbedPost(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockEmbedPost");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  webpage_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  author_photo_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  author: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  blocks: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  caption: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockCollage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockCollage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  items: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  caption: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockSlideshow(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockSlideshow");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  items: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  caption: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockAudio(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockAudio");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  audio_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  caption: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockKicker(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockKicker");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockTable(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpageBlockTable::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockTable");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bordered: "); ++stages.back(); if (flag & MTPDpageBlockTable::Flag::f_bordered) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  striped: "); ++stages.back(); if (flag & MTPDpageBlockTable::Flag::f_striped) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  title: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  rows: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockOrderedList(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockOrderedList");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  items: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockDetails(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpageBlockDetails::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockDetails");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  open: "); ++stages.back(); if (flag & MTPDpageBlockDetails::Flag::f_open) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  blocks: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  title: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockRelatedArticles(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockRelatedArticles");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  title: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  articles: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageBlockMap(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageBlockMap");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  geo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  zoom: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  w: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  h: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  caption: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phoneCallDiscardReasonMissed(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ phoneCallDiscardReasonMissed }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_phoneCallDiscardReasonDisconnect(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ phoneCallDiscardReasonDisconnect }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_phoneCallDiscardReasonHangup(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ phoneCallDiscardReasonHangup }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_phoneCallDiscardReasonBusy(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ phoneCallDiscardReasonBusy }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_dataJSON(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dataJSON");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  data: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_labeledPrice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ labeledPrice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  label: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  amount: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_invoice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinvoice::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ invoice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  test: "); ++stages.back(); if (flag & MTPDinvoice::Flag::f_test) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  name_requested: "); ++stages.back(); if (flag & MTPDinvoice::Flag::f_name_requested) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  phone_requested: "); ++stages.back(); if (flag & MTPDinvoice::Flag::f_phone_requested) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  email_requested: "); ++stages.back(); if (flag & MTPDinvoice::Flag::f_email_requested) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  shipping_address_requested: "); ++stages.back(); if (flag & MTPDinvoice::Flag::f_shipping_address_requested) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  flexible: "); ++stages.back(); if (flag & MTPDinvoice::Flag::f_flexible) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 7: to.add("  phone_to_provider: "); ++stages.back(); if (flag & MTPDinvoice::Flag::f_phone_to_provider) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 8: to.add("  email_to_provider: "); ++stages.back(); if (flag & MTPDinvoice::Flag::f_email_to_provider) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 9: to.add("  currency: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  prices: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  max_tip_amount: "); ++stages.back(); if (flag & MTPDinvoice::Flag::f_max_tip_amount) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 12: to.add("  suggested_tip_amounts: "); ++stages.back(); if (flag & MTPDinvoice::Flag::f_suggested_tip_amounts) { types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_paymentCharge(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ paymentCharge");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  provider_charge_id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_postAddress(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ postAddress");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  street_line1: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  street_line2: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  city: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  state: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  country_iso2: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  post_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_paymentRequestedInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpaymentRequestedInfo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ paymentRequestedInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  name: "); ++stages.back(); if (flag & MTPDpaymentRequestedInfo::Flag::f_name) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  phone: "); ++stages.back(); if (flag & MTPDpaymentRequestedInfo::Flag::f_phone) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  email: "); ++stages.back(); if (flag & MTPDpaymentRequestedInfo::Flag::f_email) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  shipping_address: "); ++stages.back(); if (flag & MTPDpaymentRequestedInfo::Flag::f_shipping_address) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_paymentSavedCredentialsCard(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ paymentSavedCredentialsCard");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_webDocument(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ webDocument");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  size: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  mime_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  attributes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_webDocumentNoProxy(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ webDocumentNoProxy");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  size: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  mime_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  attributes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputWebDocument(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputWebDocument");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  size: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  mime_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  attributes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputWebFileLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputWebFileLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputWebFileGeoPointLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputWebFileGeoPointLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  geo_point: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  w: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  h: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  zoom: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  scale: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_webFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_webFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  size: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  mime_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  file_type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  mtime: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_paymentForm(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpayments_paymentForm::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_paymentForm");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  can_save_credentials: "); ++stages.back(); if (flag & MTPDpayments_paymentForm::Flag::f_can_save_credentials) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 2: to.add("  password_missing: "); ++stages.back(); if (flag & MTPDpayments_paymentForm::Flag::f_password_missing) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 3: to.add("  form_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  bot_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  invoice: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  provider_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  native_provider: "); ++stages.back(); if (flag & MTPDpayments_paymentForm::Flag::f_native_provider) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 9: to.add("  native_params: "); ++stages.back(); if (flag & MTPDpayments_paymentForm::Flag::f_native_params) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 10: to.add("  saved_info: "); ++stages.back(); if (flag & MTPDpayments_paymentForm::Flag::f_saved_info) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 11: to.add("  saved_credentials: "); ++stages.back(); if (flag & MTPDpayments_paymentForm::Flag::f_saved_credentials) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 12: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_validatedRequestedInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpayments_validatedRequestedInfo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_validatedRequestedInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); if (flag & MTPDpayments_validatedRequestedInfo::Flag::f_id) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  shipping_options: "); ++stages.back(); if (flag & MTPDpayments_validatedRequestedInfo::Flag::f_shipping_options) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_paymentResult(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_paymentResult");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  updates: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_paymentVerificationNeeded(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_paymentVerificationNeeded");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_paymentReceipt(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpayments_paymentReceipt::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_paymentReceipt");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  bot_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  provider_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  description: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  photo: "); ++stages.back(); if (flag & MTPDpayments_paymentReceipt::Flag::f_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 7: to.add("  invoice: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  info: "); ++stages.back(); if (flag & MTPDpayments_paymentReceipt::Flag::f_info) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 9: to.add("  shipping: "); ++stages.back(); if (flag & MTPDpayments_paymentReceipt::Flag::f_shipping) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 10: to.add("  tip_amount: "); ++stages.back(); if (flag & MTPDpayments_paymentReceipt::Flag::f_tip_amount) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 11: to.add("  currency: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  total_amount: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  credentials_title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 14: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_savedInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpayments_savedInfo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_savedInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  has_saved_credentials: "); ++stages.back(); if (flag & MTPDpayments_savedInfo::Flag::f_has_saved_credentials) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  saved_info: "); ++stages.back(); if (flag & MTPDpayments_savedInfo::Flag::f_saved_info) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPaymentCredentialsSaved(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPaymentCredentialsSaved");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  tmp_password: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPaymentCredentials(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputPaymentCredentials::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPaymentCredentials");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  save: "); ++stages.back(); if (flag & MTPDinputPaymentCredentials::Flag::f_save) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  data: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPaymentCredentialsApplePay(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPaymentCredentialsApplePay");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  payment_data: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPaymentCredentialsGooglePay(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPaymentCredentialsGooglePay");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  payment_token: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_tmpPassword(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_tmpPassword");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  tmp_password: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  valid_until: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_shippingOption(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ shippingOption");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  prices: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputStickerSetItem(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputStickerSetItem::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputStickerSetItem");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  document: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  emoji: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  mask_coords: "); ++stages.back(); if (flag & MTPDinputStickerSetItem::Flag::f_mask_coords) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputPhoneCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputPhoneCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phoneCallEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phoneCallEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phoneCallWaiting(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDphoneCallWaiting::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phoneCallWaiting");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  video: "); ++stages.back(); if (flag & MTPDphoneCallWaiting::Flag::f_video) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  admin_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  participant_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  protocol: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  receive_date: "); ++stages.back(); if (flag & MTPDphoneCallWaiting::Flag::f_receive_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phoneCallRequested(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDphoneCallRequested::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phoneCallRequested");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  video: "); ++stages.back(); if (flag & MTPDphoneCallRequested::Flag::f_video) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  admin_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  participant_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  g_a_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  protocol: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phoneCallAccepted(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDphoneCallAccepted::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phoneCallAccepted");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  video: "); ++stages.back(); if (flag & MTPDphoneCallAccepted::Flag::f_video) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  admin_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  participant_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  g_b: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  protocol: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phoneCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDphoneCall::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phoneCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  p2p_allowed: "); ++stages.back(); if (flag & MTPDphoneCall::Flag::f_p2p_allowed) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 2: to.add("  video: "); ++stages.back(); if (flag & MTPDphoneCall::Flag::f_video) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 3: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  admin_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  participant_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  g_a_or_b: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  key_fingerprint: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  protocol: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  connections: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  start_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phoneCallDiscarded(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDphoneCallDiscarded::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phoneCallDiscarded");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  need_rating: "); ++stages.back(); if (flag & MTPDphoneCallDiscarded::Flag::f_need_rating) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 2: to.add("  need_debug: "); ++stages.back(); if (flag & MTPDphoneCallDiscarded::Flag::f_need_debug) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 3: to.add("  video: "); ++stages.back(); if (flag & MTPDphoneCallDiscarded::Flag::f_video) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 4: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  reason: "); ++stages.back(); if (flag & MTPDphoneCallDiscarded::Flag::f_reason) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  duration: "); ++stages.back(); if (flag & MTPDphoneCallDiscarded::Flag::f_duration) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phoneConnection(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phoneConnection");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  ip: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  ipv6: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  port: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  peer_tag: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phoneConnectionWebrtc(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDphoneConnectionWebrtc::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phoneConnectionWebrtc");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  turn: "); ++stages.back(); if (flag & MTPDphoneConnectionWebrtc::Flag::f_turn) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  stun: "); ++stages.back(); if (flag & MTPDphoneConnectionWebrtc::Flag::f_stun) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  ip: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  ipv6: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  port: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  username: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  password: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phoneCallProtocol(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDphoneCallProtocol::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phoneCallProtocol");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  udp_p2p: "); ++stages.back(); if (flag & MTPDphoneCallProtocol::Flag::f_udp_p2p) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  udp_reflector: "); ++stages.back(); if (flag & MTPDphoneCallProtocol::Flag::f_udp_reflector) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  min_layer: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  max_layer: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  library_versions: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_string+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_phoneCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_phoneCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_cdnFileReuploadNeeded(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_cdnFileReuploadNeeded");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  request_token: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_cdnFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_cdnFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_cdnPublicKey(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ cdnPublicKey");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  public_key: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_cdnConfig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ cdnConfig");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  public_keys: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_langPackString(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ langPackString");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  key: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  value: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_langPackStringPluralized(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDlangPackStringPluralized::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ langPackStringPluralized");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  key: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  zero_value: "); ++stages.back(); if (flag & MTPDlangPackStringPluralized::Flag::f_zero_value) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  one_value: "); ++stages.back(); if (flag & MTPDlangPackStringPluralized::Flag::f_one_value) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  two_value: "); ++stages.back(); if (flag & MTPDlangPackStringPluralized::Flag::f_two_value) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  few_value: "); ++stages.back(); if (flag & MTPDlangPackStringPluralized::Flag::f_few_value) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 6: to.add("  many_value: "); ++stages.back(); if (flag & MTPDlangPackStringPluralized::Flag::f_many_value) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 7: to.add("  other_value: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_langPackStringDeleted(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ langPackStringDeleted");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  key: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_langPackDifference(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ langPackDifference");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  from_version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  strings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_langPackLanguage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDlangPackLanguage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ langPackLanguage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  official: "); ++stages.back(); if (flag & MTPDlangPackLanguage::Flag::f_official) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  rtl: "); ++stages.back(); if (flag & MTPDlangPackLanguage::Flag::f_rtl) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 3: to.add("  beta: "); ++stages.back(); if (flag & MTPDlangPackLanguage::Flag::f_beta) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 4: to.add("  name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  native_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  base_lang_code: "); ++stages.back(); if (flag & MTPDlangPackLanguage::Flag::f_base_lang_code) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 8: to.add("  plural_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  strings_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  translated_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  translations_url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionChangeTitle(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionChangeTitle");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_value: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_value: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionChangeAbout(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionChangeAbout");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_value: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_value: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionChangeUsername(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionChangeUsername");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_value: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_value: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionChangePhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionChangePhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionToggleInvites(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionToggleInvites");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  new_value: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionToggleSignatures(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionToggleSignatures");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  new_value: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionUpdatePinned(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionUpdatePinned");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionEditMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionEditMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionDeleteMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionDeleteMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionParticipantJoin(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ channelAdminLogEventActionParticipantJoin }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_channelAdminLogEventActionParticipantLeave(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ channelAdminLogEventActionParticipantLeave }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_channelAdminLogEventActionParticipantInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionParticipantInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionParticipantToggleBan(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionParticipantToggleBan");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionParticipantToggleAdmin(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionParticipantToggleAdmin");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionChangeStickerSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionChangeStickerSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionTogglePreHistoryHidden(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionTogglePreHistoryHidden");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  new_value: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionDefaultBannedRights(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionDefaultBannedRights");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_banned_rights: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_banned_rights: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionStopPoll(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionStopPoll");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionChangeLinkedChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionChangeLinkedChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_value: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_value: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionChangeLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionChangeLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_value: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_value: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionToggleSlowMode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionToggleSlowMode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_value: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_value: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionStartGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionStartGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionDiscardGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionDiscardGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionParticipantMute(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionParticipantMute");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionParticipantUnmute(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionParticipantUnmute");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionToggleGroupCallSetting(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionToggleGroupCallSetting");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  join_muted: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionParticipantJoinByInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionParticipantJoinByInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  invite: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionExportedInviteDelete(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionExportedInviteDelete");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  invite: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionExportedInviteRevoke(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionExportedInviteRevoke");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  invite: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionExportedInviteEdit(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionExportedInviteEdit");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_invite: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_invite: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionParticipantVolume(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionParticipantVolume");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventActionChangeHistoryTTL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventActionChangeHistoryTTL");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_value: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_value: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEvent(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEvent");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  action: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_adminLogResults(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_adminLogResults");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  events: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channelAdminLogEventsFilter(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchannelAdminLogEventsFilter::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelAdminLogEventsFilter");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  join: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_join) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  leave: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_leave) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  invite: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_invite) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  ban: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_ban) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  unban: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_unban) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  kick: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_kick) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 7: to.add("  unkick: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_unkick) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 8: to.add("  promote: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_promote) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 9: to.add("  demote: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_demote) { to.add("YES [ BY BIT 8 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 10: to.add("  info: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_info) { to.add("YES [ BY BIT 9 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 11: to.add("  settings: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_settings) { to.add("YES [ BY BIT 10 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 12: to.add("  pinned: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_pinned) { to.add("YES [ BY BIT 11 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 13: to.add("  edit: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_edit) { to.add("YES [ BY BIT 12 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	case 14: to.add("  delete: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_delete) { to.add("YES [ BY BIT 13 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 15: to.add("  group_call: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_group_call) { to.add("YES [ BY BIT 14 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 16: to.add("  invites: "); ++stages.back(); if (flag & MTPDchannelAdminLogEventsFilter::Flag::f_invites) { to.add("YES [ BY BIT 15 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_popularContact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ popularContact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  client_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  importers: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_favedStickersNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_favedStickersNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_favedStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_favedStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  packs: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  stickers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_recentMeUrlUnknown(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ recentMeUrlUnknown");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_recentMeUrlUser(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ recentMeUrlUser");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_recentMeUrlChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ recentMeUrlChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_recentMeUrlChatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ recentMeUrlChatInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chat_invite: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_recentMeUrlStickerSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ recentMeUrlStickerSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  set: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_recentMeUrls(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_recentMeUrls");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  urls: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputSingleMedia(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputSingleMedia::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputSingleMedia");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  media: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  entities: "); ++stages.back(); if (flag & MTPDinputSingleMedia::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_webAuthorization(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ webAuthorization");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bot_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  domain: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  browser: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  platform: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  date_created: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  date_active: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  ip: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  region: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_webAuthorizations(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_webAuthorizations");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  authorizations: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMessageID(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMessageID");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMessageReplyTo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMessageReplyTo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputMessagePinned(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputMessagePinned }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputMessageCallbackQuery(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputMessageCallbackQuery");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputDialogPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputDialogPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputDialogPeerFolder(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputDialogPeerFolder");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  folder_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_dialogPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dialogPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_dialogPeerFolder(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dialogPeerFolder");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  folder_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_foundStickerSetsNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_foundStickerSetsNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_foundStickerSets(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_foundStickerSets");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  sets: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_fileHash(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ fileHash");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputClientProxy(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputClientProxy");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  address: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  port: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_termsOfServiceUpdateEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_termsOfServiceUpdateEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_termsOfServiceUpdate(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_termsOfServiceUpdate");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  terms_of_service: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputSecureFileUploaded(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputSecureFileUploaded");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  parts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  md5_checksum: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  file_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  secret: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputSecureFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputSecureFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureFileEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureFileEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  size: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  file_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  secret: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureData");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  data: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  data_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  secret: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_securePlainPhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ securePlainPhone");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_securePlainEmail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ securePlainEmail");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  email: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueTypePersonalDetails(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypePersonalDetails }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypePassport(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypePassport }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypeDriverLicense(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypeDriverLicense }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypeIdentityCard(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypeIdentityCard }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypeInternalPassport(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypeInternalPassport }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypeAddress(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypeAddress }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypeUtilityBill(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypeUtilityBill }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypeBankStatement(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypeBankStatement }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypeRentalAgreement(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypeRentalAgreement }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypePassportRegistration(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypePassportRegistration }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypeTemporaryRegistration(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypeTemporaryRegistration }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypePhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypePhone }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValueTypeEmail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ secureValueTypeEmail }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_secureValue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDsecureValue::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  data: "); ++stages.back(); if (flag & MTPDsecureValue::Flag::f_data) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  front_side: "); ++stages.back(); if (flag & MTPDsecureValue::Flag::f_front_side) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  reverse_side: "); ++stages.back(); if (flag & MTPDsecureValue::Flag::f_reverse_side) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  selfie: "); ++stages.back(); if (flag & MTPDsecureValue::Flag::f_selfie) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 6: to.add("  translation: "); ++stages.back(); if (flag & MTPDsecureValue::Flag::f_translation) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 7: to.add("  files: "); ++stages.back(); if (flag & MTPDsecureValue::Flag::f_files) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 8: to.add("  plain_data: "); ++stages.back(); if (flag & MTPDsecureValue::Flag::f_plain_data) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 9: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputSecureValue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputSecureValue::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputSecureValue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  data: "); ++stages.back(); if (flag & MTPDinputSecureValue::Flag::f_data) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  front_side: "); ++stages.back(); if (flag & MTPDinputSecureValue::Flag::f_front_side) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  reverse_side: "); ++stages.back(); if (flag & MTPDinputSecureValue::Flag::f_reverse_side) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  selfie: "); ++stages.back(); if (flag & MTPDinputSecureValue::Flag::f_selfie) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 6: to.add("  translation: "); ++stages.back(); if (flag & MTPDinputSecureValue::Flag::f_translation) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 7: to.add("  files: "); ++stages.back(); if (flag & MTPDinputSecureValue::Flag::f_files) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 8: to.add("  plain_data: "); ++stages.back(); if (flag & MTPDinputSecureValue::Flag::f_plain_data) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueHash(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValueHash");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueErrorData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValueErrorData");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  data_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  field: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueErrorFrontSide(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValueErrorFrontSide");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueErrorReverseSide(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValueErrorReverseSide");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueErrorSelfie(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValueErrorSelfie");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueErrorFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValueErrorFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueErrorFiles(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValueErrorFiles");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file_hash: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_bytes+0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueError(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValueError");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueErrorTranslationFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValueErrorTranslationFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureValueErrorTranslationFiles(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureValueErrorTranslationFiles");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file_hash: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_bytes+0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureCredentialsEncrypted(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureCredentialsEncrypted");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  data: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  secret: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_authorizationForm(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDaccount_authorizationForm::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_authorizationForm");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  required_types: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  values: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  errors: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  privacy_policy_url: "); ++stages.back(); if (flag & MTPDaccount_authorizationForm::Flag::f_privacy_policy_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_sentEmailCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_sentEmailCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  email_pattern: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_deepLinkInfoEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_deepLinkInfoEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_deepLinkInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDhelp_deepLinkInfo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_deepLinkInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  update_app: "); ++stages.back(); if (flag & MTPDhelp_deepLinkInfo::Flag::f_update_app) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  entities: "); ++stages.back(); if (flag & MTPDhelp_deepLinkInfo::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_savedPhoneContact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ savedPhoneContact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  first_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  last_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_takeout(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_takeout");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_passwordKdfAlgoUnknown(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ passwordKdfAlgoUnknown }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_passwordKdfAlgoModPow(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ passwordKdfAlgoModPow");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  salt1: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  salt2: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  g: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  p: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_securePasswordKdfAlgoUnknown(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ securePasswordKdfAlgoUnknown }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_securePasswordKdfAlgoPBKDF2HMACSHA512iter100000(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ securePasswordKdfAlgoPBKDF2HMACSHA512iter100000");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  salt: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_securePasswordKdfAlgoSHA512(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ securePasswordKdfAlgoSHA512");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  salt: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureSecretSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureSecretSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  secure_algo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  secure_secret: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  secure_secret_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputCheckPasswordEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inputCheckPasswordEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputCheckPasswordSRP(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputCheckPasswordSRP");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  srp_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  A: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  M1: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureRequiredType(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDsecureRequiredType::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureRequiredType");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  native_names: "); ++stages.back(); if (flag & MTPDsecureRequiredType::Flag::f_native_names) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  selfie_required: "); ++stages.back(); if (flag & MTPDsecureRequiredType::Flag::f_selfie_required) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  translation_required: "); ++stages.back(); if (flag & MTPDsecureRequiredType::Flag::f_translation_required) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  type: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_secureRequiredTypeOneOf(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ secureRequiredTypeOneOf");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  types: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_passportConfigNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_passportConfigNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_passportConfig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_passportConfig");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  countries_langs: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputAppEvent(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputAppEvent");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  time: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  data: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_jsonObjectValue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ jsonObjectValue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  key: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  value: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_jsonNull(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ jsonNull }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_jsonBool(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ jsonBool");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  value: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_jsonNumber(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ jsonNumber");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  value: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_jsonString(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ jsonString");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  value: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_jsonArray(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ jsonArray");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  value: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_jsonObject(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ jsonObject");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  value: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageTableCell(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpageTableCell::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageTableCell");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  header: "); ++stages.back(); if (flag & MTPDpageTableCell::Flag::f_header) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  align_center: "); ++stages.back(); if (flag & MTPDpageTableCell::Flag::f_align_center) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 3: to.add("  align_right: "); ++stages.back(); if (flag & MTPDpageTableCell::Flag::f_align_right) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 4: to.add("  valign_middle: "); ++stages.back(); if (flag & MTPDpageTableCell::Flag::f_valign_middle) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 5: to.add("  valign_bottom: "); ++stages.back(); if (flag & MTPDpageTableCell::Flag::f_valign_bottom) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 6: to.add("  text: "); ++stages.back(); if (flag & MTPDpageTableCell::Flag::f_text) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 7: to.add("  colspan: "); ++stages.back(); if (flag & MTPDpageTableCell::Flag::f_colspan) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 8: to.add("  rowspan: "); ++stages.back(); if (flag & MTPDpageTableCell::Flag::f_rowspan) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageTableRow(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageTableRow");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  cells: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageCaption(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageCaption");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  credit: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageListItemText(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageListItemText");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageListItemBlocks(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageListItemBlocks");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  blocks: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageListOrderedItemText(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageListOrderedItemText");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  num: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  text: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageListOrderedItemBlocks(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageListOrderedItemBlocks");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  num: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  blocks: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pageRelatedArticle(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpageRelatedArticle::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pageRelatedArticle");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  webpage_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  title: "); ++stages.back(); if (flag & MTPDpageRelatedArticle::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  description: "); ++stages.back(); if (flag & MTPDpageRelatedArticle::Flag::f_description) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  photo_id: "); ++stages.back(); if (flag & MTPDpageRelatedArticle::Flag::f_photo_id) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 6: to.add("  author: "); ++stages.back(); if (flag & MTPDpageRelatedArticle::Flag::f_author) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 7: to.add("  published_date: "); ++stages.back(); if (flag & MTPDpageRelatedArticle::Flag::f_published_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_page(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ page");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  part: "); ++stages.back(); if (flag & MTPDpage::Flag::f_part) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  rtl: "); ++stages.back(); if (flag & MTPDpage::Flag::f_rtl) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  v2: "); ++stages.back(); if (flag & MTPDpage::Flag::f_v2) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  blocks: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  photos: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  documents: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  views: "); ++stages.back(); if (flag & MTPDpage::Flag::f_views) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_supportName(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_supportName");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_userInfoEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_userInfoEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_userInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_userInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  entities: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  author: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pollAnswer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pollAnswer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  option: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_poll(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpoll::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ poll");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  closed: "); ++stages.back(); if (flag & MTPDpoll::Flag::f_closed) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  public_voters: "); ++stages.back(); if (flag & MTPDpoll::Flag::f_public_voters) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  multiple_choice: "); ++stages.back(); if (flag & MTPDpoll::Flag::f_multiple_choice) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  quiz: "); ++stages.back(); if (flag & MTPDpoll::Flag::f_quiz) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 6: to.add("  question: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  answers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  close_period: "); ++stages.back(); if (flag & MTPDpoll::Flag::f_close_period) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 9: to.add("  close_date: "); ++stages.back(); if (flag & MTPDpoll::Flag::f_close_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pollAnswerVoters(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpollAnswerVoters::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pollAnswerVoters");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chosen: "); ++stages.back(); if (flag & MTPDpollAnswerVoters::Flag::f_chosen) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  correct: "); ++stages.back(); if (flag & MTPDpollAnswerVoters::Flag::f_correct) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  option: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  voters: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_pollResults(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDpollResults::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ pollResults");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  min: "); ++stages.back(); if (flag & MTPDpollResults::Flag::f_min) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  results: "); ++stages.back(); if (flag & MTPDpollResults::Flag::f_results) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  total_voters: "); ++stages.back(); if (flag & MTPDpollResults::Flag::f_total_voters) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  recent_voters: "); ++stages.back(); if (flag & MTPDpollResults::Flag::f_recent_voters) { types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  solution: "); ++stages.back(); if (flag & MTPDpollResults::Flag::f_solution) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  solution_entities: "); ++stages.back(); if (flag & MTPDpollResults::Flag::f_solution_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatOnlines(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatOnlines");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  onlines: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_statsURL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ statsURL");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatAdminRights(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchatAdminRights::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatAdminRights");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  change_info: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_change_info) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  post_messages: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_post_messages) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  edit_messages: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_edit_messages) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  delete_messages: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_delete_messages) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  ban_users: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_ban_users) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  invite_users: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_invite_users) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 7: to.add("  pin_messages: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_pin_messages) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 8: to.add("  add_admins: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_add_admins) { to.add("YES [ BY BIT 9 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 9: to.add("  anonymous: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_anonymous) { to.add("YES [ BY BIT 10 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 10: to.add("  manage_call: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_manage_call) { to.add("YES [ BY BIT 11 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 11: to.add("  other: "); ++stages.back(); if (flag & MTPDchatAdminRights::Flag::f_other) { to.add("YES [ BY BIT 12 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatBannedRights(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDchatBannedRights::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatBannedRights");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  view_messages: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_view_messages) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  send_messages: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_send_messages) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  send_media: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_send_media) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  send_stickers: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_send_stickers) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  send_gifs: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_send_gifs) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  send_games: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_send_games) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 7: to.add("  send_inline: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_send_inline) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 8: to.add("  embed_links: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_embed_links) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 9: to.add("  send_polls: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_send_polls) { to.add("YES [ BY BIT 8 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 10: to.add("  change_info: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_change_info) { to.add("YES [ BY BIT 10 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 11: to.add("  invite_users: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_invite_users) { to.add("YES [ BY BIT 15 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	case 12: to.add("  pin_messages: "); ++stages.back(); if (flag & MTPDchatBannedRights::Flag::f_pin_messages) { to.add("YES [ BY BIT 17 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 17 IN FIELD flags ]"); } break;
	case 13: to.add("  until_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputWallPaper(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputWallPaper");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputWallPaperSlug(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputWallPaperSlug");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  slug: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputWallPaperNoFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputWallPaperNoFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_wallPapersNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_wallPapersNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_wallPapers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_wallPapers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  wallpapers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_codeSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDcodeSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ codeSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  allow_flashcall: "); ++stages.back(); if (flag & MTPDcodeSettings::Flag::f_allow_flashcall) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  current_number: "); ++stages.back(); if (flag & MTPDcodeSettings::Flag::f_current_number) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  allow_app_hash: "); ++stages.back(); if (flag & MTPDcodeSettings::Flag::f_allow_app_hash) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_wallPaperSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDwallPaperSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ wallPaperSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  blur: "); ++stages.back(); if (flag & MTPDwallPaperSettings::Flag::f_blur) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  motion: "); ++stages.back(); if (flag & MTPDwallPaperSettings::Flag::f_motion) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 3: to.add("  background_color: "); ++stages.back(); if (flag & MTPDwallPaperSettings::Flag::f_background_color) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  second_background_color: "); ++stages.back(); if (flag & MTPDwallPaperSettings::Flag::f_second_background_color) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 5: to.add("  third_background_color: "); ++stages.back(); if (flag & MTPDwallPaperSettings::Flag::f_third_background_color) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 6: to.add("  fourth_background_color: "); ++stages.back(); if (flag & MTPDwallPaperSettings::Flag::f_fourth_background_color) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 7: to.add("  intensity: "); ++stages.back(); if (flag & MTPDwallPaperSettings::Flag::f_intensity) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 8: to.add("  rotation: "); ++stages.back(); if (flag & MTPDwallPaperSettings::Flag::f_rotation) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_autoDownloadSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDautoDownloadSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ autoDownloadSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  disabled: "); ++stages.back(); if (flag & MTPDautoDownloadSettings::Flag::f_disabled) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  video_preload_large: "); ++stages.back(); if (flag & MTPDautoDownloadSettings::Flag::f_video_preload_large) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  audio_preload_next: "); ++stages.back(); if (flag & MTPDautoDownloadSettings::Flag::f_audio_preload_next) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  phonecalls_less_data: "); ++stages.back(); if (flag & MTPDautoDownloadSettings::Flag::f_phonecalls_less_data) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  photo_size_max: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  video_size_max: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  file_size_max: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  video_upload_maxbitrate: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_autoDownloadSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_autoDownloadSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  low: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  medium: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  high: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_emojiKeyword(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ emojiKeyword");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  keyword: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  emoticons: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_string+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_emojiKeywordDeleted(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ emojiKeywordDeleted");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  keyword: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  emoticons: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_string+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_emojiKeywordsDifference(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ emojiKeywordsDifference");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  from_version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  keywords: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_emojiURL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ emojiURL");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_emojiLanguage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ emojiLanguage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_folder(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDfolder::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ folder");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  autofill_new_broadcasts: "); ++stages.back(); if (flag & MTPDfolder::Flag::f_autofill_new_broadcasts) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  autofill_public_groups: "); ++stages.back(); if (flag & MTPDfolder::Flag::f_autofill_public_groups) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  autofill_new_correspondents: "); ++stages.back(); if (flag & MTPDfolder::Flag::f_autofill_new_correspondents) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  photo: "); ++stages.back(); if (flag & MTPDfolder::Flag::f_photo) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputFolderPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputFolderPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  folder_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_folderPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ folderPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  folder_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_searchCounter(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessages_searchCounter::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_searchCounter");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  inexact: "); ++stages.back(); if (flag & MTPDmessages_searchCounter::Flag::f_inexact) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  filter: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_urlAuthResultRequest(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDurlAuthResultRequest::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ urlAuthResultRequest");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  request_write_access: "); ++stages.back(); if (flag & MTPDurlAuthResultRequest::Flag::f_request_write_access) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  bot: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  domain: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_urlAuthResultAccepted(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ urlAuthResultAccepted");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_urlAuthResultDefault(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ urlAuthResultDefault }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_channelLocationEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ channelLocationEmpty }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_channelLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channelLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  geo_point: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  address: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_peerLocated(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ peerLocated");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  distance: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_peerSelfLocated(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ peerSelfLocated");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_restrictionReason(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ restrictionReason");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  platform: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  reason: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputThemeSlug(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputThemeSlug");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  slug: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_theme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDtheme::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ theme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  creator: "); ++stages.back(); if (flag & MTPDtheme::Flag::f_creator) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  default: "); ++stages.back(); if (flag & MTPDtheme::Flag::f_default) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  for_chat: "); ++stages.back(); if (flag & MTPDtheme::Flag::f_for_chat) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 4: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  slug: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  document: "); ++stages.back(); if (flag & MTPDtheme::Flag::f_document) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 9: to.add("  settings: "); ++stages.back(); if (flag & MTPDtheme::Flag::f_settings) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 10: to.add("  installs_count: "); ++stages.back(); if (flag & MTPDtheme::Flag::f_installs_count) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_themesNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_themesNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_themes(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_themes");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  themes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_loginToken(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_loginToken");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  token: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_loginTokenMigrateTo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_loginTokenMigrateTo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  token: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_loginTokenSuccess(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_loginTokenSuccess");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  authorization: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_contentSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDaccount_contentSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_contentSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  sensitive_enabled: "); ++stages.back(); if (flag & MTPDaccount_contentSettings::Flag::f_sensitive_enabled) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  sensitive_can_change: "); ++stages.back(); if (flag & MTPDaccount_contentSettings::Flag::f_sensitive_can_change) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_inactiveChats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_inactiveChats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  dates: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_baseThemeClassic(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ baseThemeClassic }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_baseThemeDay(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ baseThemeDay }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_baseThemeNight(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ baseThemeNight }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_baseThemeTinted(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ baseThemeTinted }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_baseThemeArctic(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ baseThemeArctic }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inputThemeSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDinputThemeSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputThemeSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  message_colors_animated: "); ++stages.back(); if (flag & MTPDinputThemeSettings::Flag::f_message_colors_animated) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 2: to.add("  base_theme: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  accent_color: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  message_colors: "); ++stages.back(); if (flag & MTPDinputThemeSettings::Flag::f_message_colors) { types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  wallpaper: "); ++stages.back(); if (flag & MTPDinputThemeSettings::Flag::f_wallpaper) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 6: to.add("  wallpaper_settings: "); ++stages.back(); if (flag & MTPDinputThemeSettings::Flag::f_wallpaper_settings) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_themeSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDthemeSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ themeSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  message_colors_animated: "); ++stages.back(); if (flag & MTPDthemeSettings::Flag::f_message_colors_animated) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 2: to.add("  base_theme: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  accent_color: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  message_colors: "); ++stages.back(); if (flag & MTPDthemeSettings::Flag::f_message_colors) { types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  wallpaper: "); ++stages.back(); if (flag & MTPDthemeSettings::Flag::f_wallpaper) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_webPageAttributeTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDwebPageAttributeTheme::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ webPageAttributeTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  documents: "); ++stages.back(); if (flag & MTPDwebPageAttributeTheme::Flag::f_documents) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  settings: "); ++stages.back(); if (flag & MTPDwebPageAttributeTheme::Flag::f_settings) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageUserVote(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageUserVote");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  option: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageUserVoteInputOption(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageUserVoteInputOption");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageUserVoteMultiple(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageUserVoteMultiple");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  options: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_bytes+0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_votesList(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessages_votesList::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_votesList");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  votes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  next_offset: "); ++stages.back(); if (flag & MTPDmessages_votesList::Flag::f_next_offset) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_bankCardOpenUrl(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ bankCardOpenUrl");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_bankCardData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_bankCardData");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  open_urls: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_dialogFilter(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDdialogFilter::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dialogFilter");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  contacts: "); ++stages.back(); if (flag & MTPDdialogFilter::Flag::f_contacts) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  non_contacts: "); ++stages.back(); if (flag & MTPDdialogFilter::Flag::f_non_contacts) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  groups: "); ++stages.back(); if (flag & MTPDdialogFilter::Flag::f_groups) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  broadcasts: "); ++stages.back(); if (flag & MTPDdialogFilter::Flag::f_broadcasts) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  bots: "); ++stages.back(); if (flag & MTPDdialogFilter::Flag::f_bots) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  exclude_muted: "); ++stages.back(); if (flag & MTPDdialogFilter::Flag::f_exclude_muted) { to.add("YES [ BY BIT 11 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 7: to.add("  exclude_read: "); ++stages.back(); if (flag & MTPDdialogFilter::Flag::f_exclude_read) { to.add("YES [ BY BIT 12 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	case 8: to.add("  exclude_archived: "); ++stages.back(); if (flag & MTPDdialogFilter::Flag::f_exclude_archived) { to.add("YES [ BY BIT 13 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 9: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  emoticon: "); ++stages.back(); if (flag & MTPDdialogFilter::Flag::f_emoticon) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 25 IN FIELD flags ]"); } break;
	case 12: to.add("  pinned_peers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  include_peers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 14: to.add("  exclude_peers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_dialogFilterSuggested(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ dialogFilterSuggested");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  filter: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  description: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_statsDateRangeDays(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ statsDateRangeDays");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  min_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  max_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_statsAbsValueAndPrev(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ statsAbsValueAndPrev");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  current: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  previous: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_statsPercentValue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ statsPercentValue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  part: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  total: "); ++stages.back(); types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_statsGraphAsync(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ statsGraphAsync");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  token: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_statsGraphError(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ statsGraphError");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  error: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_statsGraph(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDstatsGraph::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ statsGraph");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  json: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  zoom_token: "); ++stages.back(); if (flag & MTPDstatsGraph::Flag::f_zoom_token) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageInteractionCounters(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageInteractionCounters");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  views: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  forwards: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stats_broadcastStats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stats_broadcastStats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  period: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  followers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  views_per_post: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  shares_per_post: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  enabled_notifications: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  growth_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  followers_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  mute_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  top_hours_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  interactions_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  iv_interactions_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  views_by_source_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  new_followers_by_source_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  languages_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 14: to.add("  recent_message_interactions: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_promoDataEmpty(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_promoDataEmpty");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_promoData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDhelp_promoData::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_promoData");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  proxy: "); ++stages.back(); if (flag & MTPDhelp_promoData::Flag::f_proxy) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  expires: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  psa_type: "); ++stages.back(); if (flag & MTPDhelp_promoData::Flag::f_psa_type) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 7: to.add("  psa_message: "); ++stages.back(); if (flag & MTPDhelp_promoData::Flag::f_psa_message) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_videoSize(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDvideoSize::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ videoSize");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  w: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  h: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  size: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  video_start_ts: "); ++stages.back(); if (flag & MTPDvideoSize::Flag::f_video_start_ts) { types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_statsGroupTopPoster(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ statsGroupTopPoster");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  messages: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  avg_chars: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_statsGroupTopAdmin(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ statsGroupTopAdmin");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  deleted: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  kicked: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  banned: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_statsGroupTopInviter(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ statsGroupTopInviter");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  invitations: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stats_megagroupStats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stats_megagroupStats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  period: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  members: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  viewers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  posters: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  growth_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  members_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  new_members_by_source_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  languages_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  messages_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  actions_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  top_hours_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  weekdays_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  top_posters: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 14: to.add("  top_admins: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 15: to.add("  top_inviters: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 16: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_globalPrivacySettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDglobalPrivacySettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ globalPrivacySettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  archive_and_mute_new_noncontact_peers: "); ++stages.back(); if (flag & MTPDglobalPrivacySettings::Flag::f_archive_and_mute_new_noncontact_peers) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_countryCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDhelp_countryCode::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_countryCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  country_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  prefixes: "); ++stages.back(); if (flag & MTPDhelp_countryCode::Flag::f_prefixes) { types.push_back(0); vtypes.push_back(mtpc_string+0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  patterns: "); ++stages.back(); if (flag & MTPDhelp_countryCode::Flag::f_patterns) { types.push_back(0); vtypes.push_back(mtpc_string+0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_country(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDhelp_country::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_country");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  hidden: "); ++stages.back(); if (flag & MTPDhelp_country::Flag::f_hidden) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  iso2: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  default_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  name: "); ++stages.back(); if (flag & MTPDhelp_country::Flag::f_name) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  country_codes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_countriesListNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_countriesListNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_countriesList(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_countriesList");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  countries: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageViews(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageViews::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageViews");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  views: "); ++stages.back(); if (flag & MTPDmessageViews::Flag::f_views) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  forwards: "); ++stages.back(); if (flag & MTPDmessageViews::Flag::f_forwards) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  replies: "); ++stages.back(); if (flag & MTPDmessageViews::Flag::f_replies) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_messageViews(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_messageViews");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  views: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_discussionMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessages_discussionMessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_discussionMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  max_id: "); ++stages.back(); if (flag & MTPDmessages_discussionMessage::Flag::f_max_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  read_inbox_max_id: "); ++stages.back(); if (flag & MTPDmessages_discussionMessage::Flag::f_read_inbox_max_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  read_outbox_max_id: "); ++stages.back(); if (flag & MTPDmessages_discussionMessage::Flag::f_read_outbox_max_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  unread_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageReplyHeader(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageReplyHeader::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageReplyHeader");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  reply_to_msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  reply_to_peer_id: "); ++stages.back(); if (flag & MTPDmessageReplyHeader::Flag::f_reply_to_peer_id) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  reply_to_top_id: "); ++stages.back(); if (flag & MTPDmessageReplyHeader::Flag::f_reply_to_top_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messageReplies(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessageReplies::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messageReplies");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  comments: "); ++stages.back(); if (flag & MTPDmessageReplies::Flag::f_comments) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  replies: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  replies_pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  recent_repliers: "); ++stages.back(); if (flag & MTPDmessageReplies::Flag::f_recent_repliers) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  channel_id: "); ++stages.back(); if (flag & MTPDmessageReplies::Flag::f_channel_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  max_id: "); ++stages.back(); if (flag & MTPDmessageReplies::Flag::f_max_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 7: to.add("  read_max_id: "); ++stages.back(); if (flag & MTPDmessageReplies::Flag::f_read_max_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_peerBlocked(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ peerBlocked");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stats_messageStats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stats_messageStats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  views_graph: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_groupCallDiscarded(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ groupCallDiscarded");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  duration: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_groupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDgroupCall::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ groupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  join_muted: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_join_muted) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  can_change_join_muted: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_can_change_join_muted) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 3: to.add("  join_date_asc: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_join_date_asc) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 4: to.add("  schedule_start_subscribed: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_schedule_start_subscribed) { to.add("YES [ BY BIT 8 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 5: to.add("  can_start_video: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_can_start_video) { to.add("YES [ BY BIT 9 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 6: to.add("  record_video_active: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_record_video_active) { to.add("YES [ BY BIT 11 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 7: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  participants_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  title: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 11: to.add("  stream_dc_id: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_stream_dc_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 12: to.add("  record_start_date: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_record_start_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 13: to.add("  schedule_date: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_schedule_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 14: to.add("  unmuted_video_count: "); ++stages.back(); if (flag & MTPDgroupCall::Flag::f_unmuted_video_count) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 15: to.add("  unmuted_video_limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 16: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inputGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ inputGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  access_hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_groupCallParticipant(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDgroupCallParticipant::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ groupCallParticipant");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  muted: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_muted) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  left: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_left) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  can_self_unmute: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_can_self_unmute) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  just_joined: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_just_joined) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 5: to.add("  versioned: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_versioned) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 6: to.add("  min: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_min) { to.add("YES [ BY BIT 8 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 7: to.add("  muted_by_you: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_muted_by_you) { to.add("YES [ BY BIT 9 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 9 IN FIELD flags ]"); } break;
	case 8: to.add("  volume_by_admin: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_volume_by_admin) { to.add("YES [ BY BIT 10 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 9: to.add("  self: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_self) { to.add("YES [ BY BIT 12 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	case 10: to.add("  video_joined: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_video_joined) { to.add("YES [ BY BIT 15 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	case 11: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  active_date: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_active_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 14: to.add("  source: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 15: to.add("  volume: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_volume) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 16: to.add("  about: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_about) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 17: to.add("  raise_hand_rating: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_raise_hand_rating) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 13 IN FIELD flags ]"); } break;
	case 18: to.add("  video: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_video) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 19: to.add("  presentation: "); ++stages.back(); if (flag & MTPDgroupCallParticipant::Flag::f_presentation) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_groupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_groupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  participants: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  participants_next_offset: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_groupParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_groupParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  participants: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  next_offset: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_inlineQueryPeerTypeSameBotPM(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inlineQueryPeerTypeSameBotPM }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inlineQueryPeerTypePM(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inlineQueryPeerTypePM }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inlineQueryPeerTypeChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inlineQueryPeerTypeChat }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inlineQueryPeerTypeMegagroup(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inlineQueryPeerTypeMegagroup }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_inlineQueryPeerTypeBroadcast(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ inlineQueryPeerTypeBroadcast }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_historyImport(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_historyImport");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_historyImportParsed(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDmessages_historyImportParsed::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_historyImportParsed");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pm: "); ++stages.back(); if (flag & MTPDmessages_historyImportParsed::Flag::f_pm) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  group: "); ++stages.back(); if (flag & MTPDmessages_historyImportParsed::Flag::f_group) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  title: "); ++stages.back(); if (flag & MTPDmessages_historyImportParsed::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_affectedFoundMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_affectedFoundMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatInviteImporter(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatInviteImporter");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_exportedChatInvites(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_exportedChatInvites");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  invites: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_exportedChatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_exportedChatInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  invite: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_exportedChatInviteReplaced(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_exportedChatInviteReplaced");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  invite: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_invite: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_chatInviteImporters(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_chatInviteImporters");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  importers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_chatAdminWithInvites(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatAdminWithInvites");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  admin_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  invites_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  revoked_invites_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_chatAdminsWithInvites(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_chatAdminsWithInvites");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  admins: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_checkedHistoryImportPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_checkedHistoryImportPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  confirm_text: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_joinAsPeers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_joinAsPeers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_exportedGroupCallInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_exportedGroupCallInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  link: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_groupCallParticipantVideoSourceGroup(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ groupCallParticipantVideoSourceGroup");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  semantics: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  sources: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_groupCallParticipantVideo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDgroupCallParticipantVideo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ groupCallParticipantVideo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  paused: "); ++stages.back(); if (flag & MTPDgroupCallParticipantVideo::Flag::f_paused) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  endpoint: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  source_groups: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  audio_source: "); ++stages.back(); if (flag & MTPDgroupCallParticipantVideo::Flag::f_audio_source) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickers_suggestedShortName(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickers_suggestedShortName");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  short_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botCommandScopeDefault(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ botCommandScopeDefault }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_botCommandScopeUsers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ botCommandScopeUsers }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_botCommandScopeChats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ botCommandScopeChats }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_botCommandScopeChatAdmins(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ botCommandScopeChatAdmins }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_botCommandScopePeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botCommandScopePeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botCommandScopePeerAdmins(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botCommandScopePeerAdmins");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_botCommandScopePeerUser(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ botCommandScopePeerUser");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_resetPasswordFailedWait(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_resetPasswordFailedWait");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  retry_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_resetPasswordRequestedWait(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_resetPasswordRequestedWait");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  until_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_resetPasswordOk(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_resetPasswordOk }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_chatTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ chatTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  emoticon: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  theme: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  dark_theme: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_chatThemesNotModified(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_chatThemesNotModified }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_chatThemes(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_chatThemes");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  themes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_sponsoredMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPDsponsoredMessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ sponsoredMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  peer_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  from_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  media: "); ++stages.back(); if (flag & MTPDsponsoredMessage::Flag::f_media) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  entities: "); ++stages.back(); if (flag & MTPDsponsoredMessage::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sponsoredMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sponsoredMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  messages: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  chats: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_req_pq(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ req_pq");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_req_pq_multi(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ req_pq_multi");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_req_DH_params(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ req_DH_params");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  p: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  public_key_fingerprint: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  encrypted_data: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_set_client_DH_params(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ set_client_DH_params");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  server_nonce: "); ++stages.back(); types.push_back(mtpc_int128+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  encrypted_data: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_destroy_auth_key(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ destroy_auth_key }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_rpc_drop_answer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ rpc_drop_answer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  req_msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_get_future_salts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ get_future_salts");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  num: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_ping(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ ping");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  ping_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_ping_delay_disconnect(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ ping_delay_disconnect");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  ping_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  disconnect_delay: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_destroy_session(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ destroy_session");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  session_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_invokeAfterMsg(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ invokeAfterMsg");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_invokeAfterMsgs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ invokeAfterMsgs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_ids: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_initConnection(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPinitConnection::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ initConnection");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  api_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  device_model: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  system_version: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  app_version: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  system_lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  lang_pack: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  proxy: "); ++stages.back(); if (flag & MTPinitConnection::Flag::f_proxy) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 9: to.add("  params: "); ++stages.back(); if (flag & MTPinitConnection::Flag::f_params) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 10: to.add("  query: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_invokeWithLayer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ invokeWithLayer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  layer: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_invokeWithoutUpdates(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ invokeWithoutUpdates");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  query: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_invokeWithMessagesRange(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ invokeWithMessagesRange");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  range: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_invokeWithTakeout(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ invokeWithTakeout");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  takeout_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_sendCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_sendCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  api_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  api_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_resendCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_resendCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone_code_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_sendChangePhoneCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_sendChangePhoneCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_sendConfirmPhoneCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_sendConfirmPhoneCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_sendVerifyPhoneCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_sendVerifyPhoneCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_signUp(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_signUp");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone_code_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  first_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  last_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_signIn(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_signIn");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone_code_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  phone_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_importAuthorization(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_importAuthorization");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_importBotAuthorization(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_importBotAuthorization");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  api_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  api_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  bot_auth_token: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_checkPassword(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_checkPassword");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  password: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_recoverPassword(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPauth_recoverPassword::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_recoverPassword");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  new_settings: "); ++stages.back(); if (flag & MTPauth_recoverPassword::Flag::f_new_settings) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_logOut(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ auth_logOut }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_auth_resetAuthorizations(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ auth_resetAuthorizations }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_auth_bindTempAuthKey(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_bindTempAuthKey");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  perm_auth_key_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  nonce: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  expires_at: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  encrypted_message: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_cancelCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_cancelCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone_code_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_dropTempAuthKeys(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_dropTempAuthKeys");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  except_auth_keys: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_checkRecoveryPassword(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_checkRecoveryPassword");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_registerDevice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_registerDevice::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_registerDevice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  no_muted: "); ++stages.back(); if (flag & MTPaccount_registerDevice::Flag::f_no_muted) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  token_type: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  token: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  app_sandbox: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  secret: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  other_uids: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_unregisterDevice(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_unregisterDevice");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  token_type: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  token: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  other_uids: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_updateNotifySettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_updateNotifySettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_resetNotifySettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_resetNotifySettings }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_updateStatus(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_updateStatus");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offline: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_reportPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_reportPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  reason: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_checkUsername(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_checkUsername");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  username: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_deleteAccount(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_deleteAccount");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  reason: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_setAccountTTL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_setAccountTTL");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  ttl: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_updateDeviceLocked(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_updateDeviceLocked");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  period: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_resetAuthorization(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_resetAuthorization");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_updatePasswordSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_updatePasswordSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  password: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  new_settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_confirmPhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_confirmPhone");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_code_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_resetWebAuthorization(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_resetWebAuthorization");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_resetWebAuthorizations(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_resetWebAuthorizations }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_deleteSecureValue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_deleteSecureValue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  types: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_acceptAuthorization(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_acceptAuthorization");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  bot_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  scope: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  public_key: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  value_hashes: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  credentials: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_verifyPhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_verifyPhone");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone_code_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  phone_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_verifyEmail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_verifyEmail");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  email: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_finishTakeoutSession(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_finishTakeoutSession::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_finishTakeoutSession");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  success: "); ++stages.back(); if (flag & MTPaccount_finishTakeoutSession::Flag::f_success) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_confirmPasswordEmail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_confirmPasswordEmail");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_resendPasswordEmail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_resendPasswordEmail }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_cancelPasswordEmail(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_cancelPasswordEmail }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_getContactSignUpNotification(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_getContactSignUpNotification }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_setContactSignUpNotification(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_setContactSignUpNotification");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  silent: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_saveWallPaper(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_saveWallPaper");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  wallpaper: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  unsave: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_installWallPaper(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_installWallPaper");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  wallpaper: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_resetWallPapers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_resetWallPapers }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_saveAutoDownloadSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_saveAutoDownloadSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_saveAutoDownloadSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  low: "); ++stages.back(); if (flag & MTPaccount_saveAutoDownloadSettings::Flag::f_low) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  high: "); ++stages.back(); if (flag & MTPaccount_saveAutoDownloadSettings::Flag::f_high) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_saveTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_saveTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  theme: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  unsave: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_installTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_installTheme::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_installTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  dark: "); ++stages.back(); if (flag & MTPaccount_installTheme::Flag::f_dark) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  format: "); ++stages.back(); if (flag & MTPaccount_installTheme::Flag::f_format) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  theme: "); ++stages.back(); if (flag & MTPaccount_installTheme::Flag::f_theme) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_setContentSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_setContentSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_setContentSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  sensitive_enabled: "); ++stages.back(); if (flag & MTPaccount_setContentSettings::Flag::f_sensitive_enabled) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_reportProfilePhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_reportProfilePhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  photo_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  reason: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_declinePasswordReset(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_declinePasswordReset }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_users_setSecureValueErrors(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ users_setSecureValueErrors");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  errors: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_deleteByPhones(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_deleteByPhones");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phones: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_string+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_block(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_block");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_unblock(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_unblock");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_resetTopPeerRating(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_resetTopPeerRating");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  category: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_resetSaved(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ contacts_resetSaved }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_contacts_toggleTopPeers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_toggleTopPeers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  enabled: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_setTyping(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_setTyping::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_setTyping");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  top_msg_id: "); ++stages.back(); if (flag & MTPmessages_setTyping::Flag::f_top_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  action: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_reportSpam(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_reportSpam");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_report(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_report");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  reason: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_discardEncryption(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_discardEncryption::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_discardEncryption");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  delete_history: "); ++stages.back(); if (flag & MTPmessages_discardEncryption::Flag::f_delete_history) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_setEncryptedTyping(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_setEncryptedTyping");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  typing: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_readEncryptedHistory(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_readEncryptedHistory");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  max_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_reportEncryptedSpam(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_reportEncryptedSpam");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_uninstallStickerSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_uninstallStickerSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_editChatAdmin(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_editChatAdmin");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  is_admin: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_reorderStickerSets(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_reorderStickerSets::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_reorderStickerSets");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  masks: "); ++stages.back(); if (flag & MTPmessages_reorderStickerSets::Flag::f_masks) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  order: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_saveGif(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_saveGif");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  unsave: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_setInlineBotResults(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_setInlineBotResults::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_setInlineBotResults");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  gallery: "); ++stages.back(); if (flag & MTPmessages_setInlineBotResults::Flag::f_gallery) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  private: "); ++stages.back(); if (flag & MTPmessages_setInlineBotResults::Flag::f_private) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  results: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  cache_time: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  next_offset: "); ++stages.back(); if (flag & MTPmessages_setInlineBotResults::Flag::f_next_offset) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 7: to.add("  switch_pm: "); ++stages.back(); if (flag & MTPmessages_setInlineBotResults::Flag::f_switch_pm) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_editInlineBotMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_editInlineBotMessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_editInlineBotMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  no_webpage: "); ++stages.back(); if (flag & MTPmessages_editInlineBotMessage::Flag::f_no_webpage) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  message: "); ++stages.back(); if (flag & MTPmessages_editInlineBotMessage::Flag::f_message) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 4: to.add("  media: "); ++stages.back(); if (flag & MTPmessages_editInlineBotMessage::Flag::f_media) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 5: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPmessages_editInlineBotMessage::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 6: to.add("  entities: "); ++stages.back(); if (flag & MTPmessages_editInlineBotMessage::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_setBotCallbackAnswer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_setBotCallbackAnswer::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_setBotCallbackAnswer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  alert: "); ++stages.back(); if (flag & MTPmessages_setBotCallbackAnswer::Flag::f_alert) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  message: "); ++stages.back(); if (flag & MTPmessages_setBotCallbackAnswer::Flag::f_message) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  url: "); ++stages.back(); if (flag & MTPmessages_setBotCallbackAnswer::Flag::f_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  cache_time: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_saveDraft(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_saveDraft::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_saveDraft");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  no_webpage: "); ++stages.back(); if (flag & MTPmessages_saveDraft::Flag::f_no_webpage) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  reply_to_msg_id: "); ++stages.back(); if (flag & MTPmessages_saveDraft::Flag::f_reply_to_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  entities: "); ++stages.back(); if (flag & MTPmessages_saveDraft::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_readFeaturedStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_readFeaturedStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_saveRecentSticker(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_saveRecentSticker::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_saveRecentSticker");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  attached: "); ++stages.back(); if (flag & MTPmessages_saveRecentSticker::Flag::f_attached) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  unsave: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_clearRecentStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_clearRecentStickers::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_clearRecentStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  attached: "); ++stages.back(); if (flag & MTPmessages_clearRecentStickers::Flag::f_attached) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_setInlineGameScore(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_setInlineGameScore::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_setInlineGameScore");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  edit_message: "); ++stages.back(); if (flag & MTPmessages_setInlineGameScore::Flag::f_edit_message) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  force: "); ++stages.back(); if (flag & MTPmessages_setInlineGameScore::Flag::f_force) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  score: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_toggleDialogPin(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_toggleDialogPin::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_toggleDialogPin");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pinned: "); ++stages.back(); if (flag & MTPmessages_toggleDialogPin::Flag::f_pinned) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_reorderPinnedDialogs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_reorderPinnedDialogs::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_reorderPinnedDialogs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  force: "); ++stages.back(); if (flag & MTPmessages_reorderPinnedDialogs::Flag::f_force) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  folder_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  order: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_setBotShippingResults(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_setBotShippingResults::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_setBotShippingResults");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  error: "); ++stages.back(); if (flag & MTPmessages_setBotShippingResults::Flag::f_error) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  shipping_options: "); ++stages.back(); if (flag & MTPmessages_setBotShippingResults::Flag::f_shipping_options) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_setBotPrecheckoutResults(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_setBotPrecheckoutResults::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_setBotPrecheckoutResults");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  success: "); ++stages.back(); if (flag & MTPmessages_setBotPrecheckoutResults::Flag::f_success) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  error: "); ++stages.back(); if (flag & MTPmessages_setBotPrecheckoutResults::Flag::f_error) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_faveSticker(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_faveSticker");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  unfave: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_markDialogUnread(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_markDialogUnread::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_markDialogUnread");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  unread: "); ++stages.back(); if (flag & MTPmessages_markDialogUnread::Flag::f_unread) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_clearAllDrafts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_clearAllDrafts }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_editChatAbout(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_editChatAbout");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  about: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_hidePeerSettingsBar(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_hidePeerSettingsBar");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_toggleStickerSets(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_toggleStickerSets::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_toggleStickerSets");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  uninstall: "); ++stages.back(); if (flag & MTPmessages_toggleStickerSets::Flag::f_uninstall) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  archive: "); ++stages.back(); if (flag & MTPmessages_toggleStickerSets::Flag::f_archive) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  unarchive: "); ++stages.back(); if (flag & MTPmessages_toggleStickerSets::Flag::f_unarchive) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  stickersets: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_updateDialogFilter(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_updateDialogFilter::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_updateDialogFilter");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  filter: "); ++stages.back(); if (flag & MTPmessages_updateDialogFilter::Flag::f_filter) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_updateDialogFiltersOrder(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_updateDialogFiltersOrder");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  order: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_readDiscussion(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_readDiscussion");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  read_max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_deleteChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_deleteChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_startHistoryImport(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_startHistoryImport");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  import_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_deleteRevokedExportedChatInvites(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_deleteRevokedExportedChatInvites");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  admin_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_deleteExportedChatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_deleteExportedChatInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  link: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_saveFilePart(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_saveFilePart");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  file_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file_part: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_saveBigFilePart(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_saveBigFilePart");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  file_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file_part: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  file_total_parts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_setBotUpdatesStatus(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_setBotUpdatesStatus");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  pending_updates_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_acceptTermsOfService(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_acceptTermsOfService");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_saveAppLog(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_saveAppLog");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  events: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_hidePromoData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_hidePromoData");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_dismissSuggestion(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_dismissSuggestion");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  suggestion: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_readHistory(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_readHistory");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_reportSpam(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_reportSpam");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_checkUsername(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_checkUsername");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  username: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_updateUsername(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_updateUsername");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  username: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_setStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_setStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_readMessageContents(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_readMessageContents");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_deleteHistory(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_deleteHistory");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_setDiscussionGroup(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_setDiscussionGroup");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  broadcast: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  group: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_editLocation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_editLocation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  geo_point: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  address: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_viewSponsoredMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_viewSponsoredMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_bots_answerWebhookJSONQuery(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ bots_answerWebhookJSONQuery");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  data: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_bots_setBotCommands(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ bots_setBotCommands");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  scope: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  commands: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_bots_resetBotCommands(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ bots_resetBotCommands");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  scope: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_clearSavedInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPpayments_clearSavedInfo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_clearSavedInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  credentials: "); ++stages.back(); if (flag & MTPpayments_clearSavedInfo::Flag::f_credentials) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  info: "); ++stages.back(); if (flag & MTPpayments_clearSavedInfo::Flag::f_info) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickers_checkShortName(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickers_checkShortName");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  short_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_receivedCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_receivedCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_saveCallDebug(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_saveCallDebug");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  debug: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_sendSignalingData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_sendSignalingData");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  data: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_saveDefaultGroupCallJoinAs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_saveDefaultGroupCallJoinAs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  join_as: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_exportAuthorization(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_exportAuthorization");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  dc_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_requestPasswordRecovery(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ auth_requestPasswordRecovery }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_auth_exportLoginToken(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_exportLoginToken");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  api_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  api_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  except_ids: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_importLoginToken(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_importLoginToken");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  token: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_auth_acceptLoginToken(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ auth_acceptLoginToken");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  token: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getNotifySettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getNotifySettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_updateProfile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_updateProfile::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_updateProfile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  first_name: "); ++stages.back(); if (flag & MTPaccount_updateProfile::Flag::f_first_name) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  last_name: "); ++stages.back(); if (flag & MTPaccount_updateProfile::Flag::f_last_name) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  about: "); ++stages.back(); if (flag & MTPaccount_updateProfile::Flag::f_about) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_updateUsername(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_updateUsername");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  username: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_changePhone(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_changePhone");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  phone_number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  phone_code_hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  phone_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getWallPapers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getWallPapers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getPrivacy(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getPrivacy");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  key: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_setPrivacy(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_setPrivacy");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  key: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  rules: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getAccountTTL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_getAccountTTL }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_getAuthorizations(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_getAuthorizations }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_getPassword(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_getPassword }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_getPasswordSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getPasswordSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  password: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getTmpPassword(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getTmpPassword");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  password: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  period: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getWebAuthorizations(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_getWebAuthorizations }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_getAllSecureValues(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_getAllSecureValues }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_getSecureValue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getSecureValue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  types: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_saveSecureValue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_saveSecureValue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  value: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  secure_secret_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getAuthorizationForm(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getAuthorizationForm");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  bot_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  scope: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  public_key: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_sendVerifyEmailCode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_sendVerifyEmailCode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  email: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_initTakeoutSession(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_initTakeoutSession::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_initTakeoutSession");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  contacts: "); ++stages.back(); if (flag & MTPaccount_initTakeoutSession::Flag::f_contacts) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  message_users: "); ++stages.back(); if (flag & MTPaccount_initTakeoutSession::Flag::f_message_users) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  message_chats: "); ++stages.back(); if (flag & MTPaccount_initTakeoutSession::Flag::f_message_chats) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  message_megagroups: "); ++stages.back(); if (flag & MTPaccount_initTakeoutSession::Flag::f_message_megagroups) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  message_channels: "); ++stages.back(); if (flag & MTPaccount_initTakeoutSession::Flag::f_message_channels) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  files: "); ++stages.back(); if (flag & MTPaccount_initTakeoutSession::Flag::f_files) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 7: to.add("  file_max_size: "); ++stages.back(); if (flag & MTPaccount_initTakeoutSession::Flag::f_file_max_size) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getNotifyExceptions(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_getNotifyExceptions::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getNotifyExceptions");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  compare_sound: "); ++stages.back(); if (flag & MTPaccount_getNotifyExceptions::Flag::f_compare_sound) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); if (flag & MTPaccount_getNotifyExceptions::Flag::f_peer) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_deleteContacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_deleteContacts");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_addContact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPcontacts_addContact::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_addContact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  add_phone_privacy_exception: "); ++stages.back(); if (flag & MTPcontacts_addContact::Flag::f_add_phone_privacy_exception) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  first_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  last_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  phone: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_acceptContact(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_acceptContact");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_getLocated(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPcontacts_getLocated::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_getLocated");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  background: "); ++stages.back(); if (flag & MTPcontacts_getLocated::Flag::f_background) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  geo_point: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  self_expires: "); ++stages.back(); if (flag & MTPcontacts_getLocated::Flag::f_self_expires) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_blockFromReplies(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPcontacts_blockFromReplies::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_blockFromReplies");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  delete_message: "); ++stages.back(); if (flag & MTPcontacts_blockFromReplies::Flag::f_delete_message) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  delete_history: "); ++stages.back(); if (flag & MTPcontacts_blockFromReplies::Flag::f_delete_history) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  report_spam: "); ++stages.back(); if (flag & MTPcontacts_blockFromReplies::Flag::f_report_spam) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sendMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_sendMessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sendMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  no_webpage: "); ++stages.back(); if (flag & MTPmessages_sendMessage::Flag::f_no_webpage) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  silent: "); ++stages.back(); if (flag & MTPmessages_sendMessage::Flag::f_silent) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 3: to.add("  background: "); ++stages.back(); if (flag & MTPmessages_sendMessage::Flag::f_background) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 4: to.add("  clear_draft: "); ++stages.back(); if (flag & MTPmessages_sendMessage::Flag::f_clear_draft) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 5: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  reply_to_msg_id: "); ++stages.back(); if (flag & MTPmessages_sendMessage::Flag::f_reply_to_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 7: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPmessages_sendMessage::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 10: to.add("  entities: "); ++stages.back(); if (flag & MTPmessages_sendMessage::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 11: to.add("  schedule_date: "); ++stages.back(); if (flag & MTPmessages_sendMessage::Flag::f_schedule_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sendMedia(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_sendMedia::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sendMedia");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  silent: "); ++stages.back(); if (flag & MTPmessages_sendMedia::Flag::f_silent) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 2: to.add("  background: "); ++stages.back(); if (flag & MTPmessages_sendMedia::Flag::f_background) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 3: to.add("  clear_draft: "); ++stages.back(); if (flag & MTPmessages_sendMedia::Flag::f_clear_draft) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 4: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  reply_to_msg_id: "); ++stages.back(); if (flag & MTPmessages_sendMedia::Flag::f_reply_to_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  media: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPmessages_sendMedia::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 10: to.add("  entities: "); ++stages.back(); if (flag & MTPmessages_sendMedia::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 11: to.add("  schedule_date: "); ++stages.back(); if (flag & MTPmessages_sendMedia::Flag::f_schedule_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_forwardMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_forwardMessages::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_forwardMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  silent: "); ++stages.back(); if (flag & MTPmessages_forwardMessages::Flag::f_silent) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 2: to.add("  background: "); ++stages.back(); if (flag & MTPmessages_forwardMessages::Flag::f_background) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 3: to.add("  with_my_score: "); ++stages.back(); if (flag & MTPmessages_forwardMessages::Flag::f_with_my_score) { to.add("YES [ BY BIT 8 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 8 IN FIELD flags ]"); } break;
	case 4: to.add("  drop_author: "); ++stages.back(); if (flag & MTPmessages_forwardMessages::Flag::f_drop_author) { to.add("YES [ BY BIT 11 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 5: to.add("  drop_media_captions: "); ++stages.back(); if (flag & MTPmessages_forwardMessages::Flag::f_drop_media_captions) { to.add("YES [ BY BIT 12 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 12 IN FIELD flags ]"); } break;
	case 6: to.add("  from_peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  random_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_long+0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  to_peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  schedule_date: "); ++stages.back(); if (flag & MTPmessages_forwardMessages::Flag::f_schedule_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_editChatTitle(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_editChatTitle");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_editChatPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_editChatPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_addChatUser(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_addChatUser");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  fwd_limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_deleteChatUser(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_deleteChatUser::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_deleteChatUser");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  revoke_history: "); ++stages.back(); if (flag & MTPmessages_deleteChatUser::Flag::f_revoke_history) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_createChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_createChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_importChatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_importChatInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_startBot(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_startBot");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  bot: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  start_param: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_migrateChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_migrateChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sendInlineBotResult(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_sendInlineBotResult::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sendInlineBotResult");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  silent: "); ++stages.back(); if (flag & MTPmessages_sendInlineBotResult::Flag::f_silent) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 2: to.add("  background: "); ++stages.back(); if (flag & MTPmessages_sendInlineBotResult::Flag::f_background) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 3: to.add("  clear_draft: "); ++stages.back(); if (flag & MTPmessages_sendInlineBotResult::Flag::f_clear_draft) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 4: to.add("  hide_via: "); ++stages.back(); if (flag & MTPmessages_sendInlineBotResult::Flag::f_hide_via) { to.add("YES [ BY BIT 11 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 5: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  reply_to_msg_id: "); ++stages.back(); if (flag & MTPmessages_sendInlineBotResult::Flag::f_reply_to_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 7: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  query_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  id: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  schedule_date: "); ++stages.back(); if (flag & MTPmessages_sendInlineBotResult::Flag::f_schedule_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_editMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_editMessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_editMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  no_webpage: "); ++stages.back(); if (flag & MTPmessages_editMessage::Flag::f_no_webpage) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  message: "); ++stages.back(); if (flag & MTPmessages_editMessage::Flag::f_message) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 11 IN FIELD flags ]"); } break;
	case 5: to.add("  media: "); ++stages.back(); if (flag & MTPmessages_editMessage::Flag::f_media) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 14 IN FIELD flags ]"); } break;
	case 6: to.add("  reply_markup: "); ++stages.back(); if (flag & MTPmessages_editMessage::Flag::f_reply_markup) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 7: to.add("  entities: "); ++stages.back(); if (flag & MTPmessages_editMessage::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 8: to.add("  schedule_date: "); ++stages.back(); if (flag & MTPmessages_editMessage::Flag::f_schedule_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getAllDrafts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_getAllDrafts }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_setGameScore(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_setGameScore::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_setGameScore");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  edit_message: "); ++stages.back(); if (flag & MTPmessages_setGameScore::Flag::f_edit_message) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  force: "); ++stages.back(); if (flag & MTPmessages_setGameScore::Flag::f_force) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  score: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sendScreenshotNotification(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sendScreenshotNotification");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  reply_to_msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sendMultiMedia(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_sendMultiMedia::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sendMultiMedia");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  silent: "); ++stages.back(); if (flag & MTPmessages_sendMultiMedia::Flag::f_silent) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 2: to.add("  background: "); ++stages.back(); if (flag & MTPmessages_sendMultiMedia::Flag::f_background) { to.add("YES [ BY BIT 6 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 6 IN FIELD flags ]"); } break;
	case 3: to.add("  clear_draft: "); ++stages.back(); if (flag & MTPmessages_sendMultiMedia::Flag::f_clear_draft) { to.add("YES [ BY BIT 7 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 7 IN FIELD flags ]"); } break;
	case 4: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  reply_to_msg_id: "); ++stages.back(); if (flag & MTPmessages_sendMultiMedia::Flag::f_reply_to_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 6: to.add("  multi_media: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  schedule_date: "); ++stages.back(); if (flag & MTPmessages_sendMultiMedia::Flag::f_schedule_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_updatePinnedMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_updatePinnedMessage::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_updatePinnedMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  silent: "); ++stages.back(); if (flag & MTPmessages_updatePinnedMessage::Flag::f_silent) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  unpin: "); ++stages.back(); if (flag & MTPmessages_updatePinnedMessage::Flag::f_unpin) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  pm_oneside: "); ++stages.back(); if (flag & MTPmessages_updatePinnedMessage::Flag::f_pm_oneside) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sendVote(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sendVote");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  options: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_bytes+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getPollResults(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getPollResults");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_editChatDefaultBannedRights(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_editChatDefaultBannedRights");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  banned_rights: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sendScheduledMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sendScheduledMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_deleteScheduledMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_deleteScheduledMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_setHistoryTTL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_setHistoryTTL");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  period: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_setChatTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_setChatTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  emoticon: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_getAppChangelog(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_getAppChangelog");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  prev_app_version: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_createChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPchannels_createChannel::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_createChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  broadcast: "); ++stages.back(); if (flag & MTPchannels_createChannel::Flag::f_broadcast) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  megagroup: "); ++stages.back(); if (flag & MTPchannels_createChannel::Flag::f_megagroup) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  for_import: "); ++stages.back(); if (flag & MTPchannels_createChannel::Flag::f_for_import) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 4: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  about: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  geo_point: "); ++stages.back(); if (flag & MTPchannels_createChannel::Flag::f_geo_point) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 7: to.add("  address: "); ++stages.back(); if (flag & MTPchannels_createChannel::Flag::f_address) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_editAdmin(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_editAdmin");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  admin_rights: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  rank: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_editTitle(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_editTitle");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_editPhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_editPhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  photo: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_joinChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_joinChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_leaveChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_leaveChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_inviteToChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_inviteToChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_deleteChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_deleteChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_toggleSignatures(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_toggleSignatures");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  enabled: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_editBanned(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_editBanned");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  banned_rights: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_togglePreHistoryHidden(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_togglePreHistoryHidden");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  enabled: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_editCreator(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_editCreator");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  password: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_toggleSlowMode(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_toggleSlowMode");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  seconds: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_convertToGigagroup(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_convertToGigagroup");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_discardCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPphone_discardCall::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_discardCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  video: "); ++stages.back(); if (flag & MTPphone_discardCall::Flag::f_video) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  duration: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  reason: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  connection_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_setCallRating(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPphone_setCallRating::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_setCallRating");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_initiative: "); ++stages.back(); if (flag & MTPphone_setCallRating::Flag::f_user_initiative) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  rating: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  comment: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_createGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPphone_createGroupCall::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_createGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  title: "); ++stages.back(); if (flag & MTPphone_createGroupCall::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  schedule_date: "); ++stages.back(); if (flag & MTPphone_createGroupCall::Flag::f_schedule_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_joinGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPphone_joinGroupCall::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_joinGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  muted: "); ++stages.back(); if (flag & MTPphone_joinGroupCall::Flag::f_muted) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  video_stopped: "); ++stages.back(); if (flag & MTPphone_joinGroupCall::Flag::f_video_stopped) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 3: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  join_as: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  invite_hash: "); ++stages.back(); if (flag & MTPphone_joinGroupCall::Flag::f_invite_hash) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 6: to.add("  params: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_leaveGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_leaveGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  source: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_inviteToGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_inviteToGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  users: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_discardGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_discardGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_toggleGroupCallSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPphone_toggleGroupCallSettings::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_toggleGroupCallSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  reset_invite_hash: "); ++stages.back(); if (flag & MTPphone_toggleGroupCallSettings::Flag::f_reset_invite_hash) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  join_muted: "); ++stages.back(); if (flag & MTPphone_toggleGroupCallSettings::Flag::f_join_muted) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_toggleGroupCallRecord(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPphone_toggleGroupCallRecord::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_toggleGroupCallRecord");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  start: "); ++stages.back(); if (flag & MTPphone_toggleGroupCallRecord::Flag::f_start) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  video: "); ++stages.back(); if (flag & MTPphone_toggleGroupCallRecord::Flag::f_video) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 3: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  title: "); ++stages.back(); if (flag & MTPphone_toggleGroupCallRecord::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  video_portrait: "); ++stages.back(); if (flag & MTPphone_toggleGroupCallRecord::Flag::f_video_portrait) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_editGroupCallParticipant(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPphone_editGroupCallParticipant::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_editGroupCallParticipant");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  muted: "); ++stages.back(); if (flag & MTPphone_editGroupCallParticipant::Flag::f_muted) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  volume: "); ++stages.back(); if (flag & MTPphone_editGroupCallParticipant::Flag::f_volume) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  raise_hand: "); ++stages.back(); if (flag & MTPphone_editGroupCallParticipant::Flag::f_raise_hand) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 6: to.add("  video_stopped: "); ++stages.back(); if (flag & MTPphone_editGroupCallParticipant::Flag::f_video_stopped) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 7: to.add("  video_paused: "); ++stages.back(); if (flag & MTPphone_editGroupCallParticipant::Flag::f_video_paused) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 8: to.add("  presentation_paused: "); ++stages.back(); if (flag & MTPphone_editGroupCallParticipant::Flag::f_presentation_paused) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_editGroupCallTitle(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_editGroupCallTitle");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_toggleGroupCallStartSubscription(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_toggleGroupCallStartSubscription");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  subscribed: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_startScheduledGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_startScheduledGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_joinGroupCallPresentation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_joinGroupCallPresentation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  params: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_leaveGroupCallPresentation(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_leaveGroupCallPresentation");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_folders_editPeerFolders(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ folders_editPeerFolders");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  folder_peers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_folders_deleteFolder(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ folders_deleteFolder");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  folder_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getWallPaper(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getWallPaper");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  wallpaper: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_uploadWallPaper(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_uploadWallPaper");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  file: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  mime_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getAutoDownloadSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_getAutoDownloadSettings }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_uploadTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_uploadTheme::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_uploadTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  thumb: "); ++stages.back(); if (flag & MTPaccount_uploadTheme::Flag::f_thumb) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  file_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  mime_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getDocumentByHash(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getDocumentByHash");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  sha256: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  size: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  mime_type: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_createTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_createTheme::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_createTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  slug: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  document: "); ++stages.back(); if (flag & MTPaccount_createTheme::Flag::f_document) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  settings: "); ++stages.back(); if (flag & MTPaccount_createTheme::Flag::f_settings) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_updateTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPaccount_updateTheme::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_updateTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  format: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  theme: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  slug: "); ++stages.back(); if (flag & MTPaccount_updateTheme::Flag::f_slug) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  title: "); ++stages.back(); if (flag & MTPaccount_updateTheme::Flag::f_title) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  document: "); ++stages.back(); if (flag & MTPaccount_updateTheme::Flag::f_document) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 6: to.add("  settings: "); ++stages.back(); if (flag & MTPaccount_updateTheme::Flag::f_settings) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getTheme(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getTheme");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  format: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  theme: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  document_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getThemes(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getThemes");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  format: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getContentSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_getContentSettings }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_getMultiWallPapers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getMultiWallPapers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  wallpapers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_getGlobalPrivacySettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_getGlobalPrivacySettings }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_setGlobalPrivacySettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_setGlobalPrivacySettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  settings: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_account_resetPassword(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ account_resetPassword }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_account_getChatThemes(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ account_getChatThemes");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_users_getUsers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ users_getUsers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_users_getFullUser(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ users_getFullUser");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_getContactIDs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_getContactIDs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_checkGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_checkGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  sources: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_getStatuses(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ contacts_getStatuses }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_contacts_getContacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_getContacts");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_importContacts(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_importContacts");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  contacts: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_getBlocked(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_getBlocked");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_search(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_search");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_resolveUsername(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_resolveUsername");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  username: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_getTopPeers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPcontacts_getTopPeers::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ contacts_getTopPeers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  correspondents: "); ++stages.back(); if (flag & MTPcontacts_getTopPeers::Flag::f_correspondents) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  bots_pm: "); ++stages.back(); if (flag & MTPcontacts_getTopPeers::Flag::f_bots_pm) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  bots_inline: "); ++stages.back(); if (flag & MTPcontacts_getTopPeers::Flag::f_bots_inline) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 4: to.add("  phone_calls: "); ++stages.back(); if (flag & MTPcontacts_getTopPeers::Flag::f_phone_calls) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 5: to.add("  forward_users: "); ++stages.back(); if (flag & MTPcontacts_getTopPeers::Flag::f_forward_users) { to.add("YES [ BY BIT 4 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 4 IN FIELD flags ]"); } break;
	case 6: to.add("  forward_chats: "); ++stages.back(); if (flag & MTPcontacts_getTopPeers::Flag::f_forward_chats) { to.add("YES [ BY BIT 5 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 5 IN FIELD flags ]"); } break;
	case 7: to.add("  groups: "); ++stages.back(); if (flag & MTPcontacts_getTopPeers::Flag::f_groups) { to.add("YES [ BY BIT 10 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 10 IN FIELD flags ]"); } break;
	case 8: to.add("  channels: "); ++stages.back(); if (flag & MTPcontacts_getTopPeers::Flag::f_channels) { to.add("YES [ BY BIT 15 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 15 IN FIELD flags ]"); } break;
	case 9: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_contacts_getSaved(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ contacts_getSaved }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_getMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getHistory(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getHistory");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  offset_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  offset_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  add_offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  min_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_search(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_search::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_search");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  from_id: "); ++stages.back(); if (flag & MTPmessages_search::Flag::f_from_id) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  top_msg_id: "); ++stages.back(); if (flag & MTPmessages_search::Flag::f_top_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  filter: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  min_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  max_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  offset_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  add_offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 10: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 11: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 12: to.add("  min_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 13: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_searchGlobal(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_searchGlobal::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_searchGlobal");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  folder_id: "); ++stages.back(); if (flag & MTPmessages_searchGlobal::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  filter: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  min_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  max_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  offset_rate: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  offset_peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  offset_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 9: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getUnreadMentions(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getUnreadMentions");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  offset_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  add_offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  min_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getRecentLocations(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getRecentLocations");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getScheduledHistory(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getScheduledHistory");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getScheduledMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getScheduledMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getReplies(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getReplies");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  offset_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  offset_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  add_offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  min_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_getMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_getMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stats_getMessagePublicForwards(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stats_getMessagePublicForwards");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  offset_rate: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  offset_peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  offset_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getDialogs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_getDialogs::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getDialogs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  exclude_pinned: "); ++stages.back(); if (flag & MTPmessages_getDialogs::Flag::f_exclude_pinned) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  folder_id: "); ++stages.back(); if (flag & MTPmessages_getDialogs::Flag::f_folder_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  offset_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  offset_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  offset_peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_readHistory(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_readHistory");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_deleteMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_deleteMessages::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_deleteMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  revoke: "); ++stages.back(); if (flag & MTPmessages_deleteMessages::Flag::f_revoke) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_readMessageContents(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_readMessageContents");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_deleteMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_deleteMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_deleteHistory(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_deleteHistory::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_deleteHistory");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  just_clear: "); ++stages.back(); if (flag & MTPmessages_deleteHistory::Flag::f_just_clear) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  revoke: "); ++stages.back(); if (flag & MTPmessages_deleteHistory::Flag::f_revoke) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_readMentions(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_readMentions");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_unpinAllMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_unpinAllMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_deleteUserHistory(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_deleteUserHistory");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_receivedMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_receivedMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getPeerSettings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getPeerSettings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getChats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getChats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getCommonChats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getCommonChats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getAllChats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getAllChats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  except_ids: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_getChannels(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_getChannels");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_getAdminedPublicChannels(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPchannels_getAdminedPublicChannels::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_getAdminedPublicChannels");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  by_location: "); ++stages.back(); if (flag & MTPchannels_getAdminedPublicChannels::Flag::f_by_location) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  check_limit: "); ++stages.back(); if (flag & MTPchannels_getAdminedPublicChannels::Flag::f_check_limit) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_getLeftChannels(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_getLeftChannels");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_getGroupsForDiscussion(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ channels_getGroupsForDiscussion }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_getFullChat(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getFullChat");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  chat_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_getFullChannel(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_getFullChannel");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getDhConfig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getDhConfig");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  random_length: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_requestEncryption(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_requestEncryption");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  g_a: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_acceptEncryption(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_acceptEncryption");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  g_b: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  key_fingerprint: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sendEncrypted(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_sendEncrypted::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sendEncrypted");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  silent: "); ++stages.back(); if (flag & MTPmessages_sendEncrypted::Flag::f_silent) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  data: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sendEncryptedFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_sendEncryptedFile::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sendEncryptedFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  silent: "); ++stages.back(); if (flag & MTPmessages_sendEncryptedFile::Flag::f_silent) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  data: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  file: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_sendEncryptedService(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_sendEncryptedService");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  data: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_receivedQueue(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_receivedQueue");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  max_qts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photos_deletePhotos(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photos_deletePhotos");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  emoticon: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getAllStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getAllStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getMaskStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getMaskStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getWebPagePreview(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_getWebPagePreview::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getWebPagePreview");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  entities: "); ++stages.back(); if (flag & MTPmessages_getWebPagePreview::Flag::f_entities) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_uploadMedia(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_uploadMedia");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  media: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_uploadImportedMedia(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_uploadImportedMedia");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  import_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  file_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  media: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_exportChatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_exportChatInvite::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_exportChatInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  legacy_revoke_permanent: "); ++stages.back(); if (flag & MTPmessages_exportChatInvite::Flag::f_legacy_revoke_permanent) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  expire_date: "); ++stages.back(); if (flag & MTPmessages_exportChatInvite::Flag::f_expire_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  usage_limit: "); ++stages.back(); if (flag & MTPmessages_exportChatInvite::Flag::f_usage_limit) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_checkChatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_checkChatInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getStickerSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getStickerSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickers_createStickerSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPstickers_createStickerSet::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickers_createStickerSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  masks: "); ++stages.back(); if (flag & MTPstickers_createStickerSet::Flag::f_masks) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  animated: "); ++stages.back(); if (flag & MTPstickers_createStickerSet::Flag::f_animated) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  short_name: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  thumb: "); ++stages.back(); if (flag & MTPstickers_createStickerSet::Flag::f_thumb) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 7: to.add("  stickers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 8: to.add("  software: "); ++stages.back(); if (flag & MTPstickers_createStickerSet::Flag::f_software) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickers_removeStickerFromSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickers_removeStickerFromSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  sticker: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickers_changeStickerPosition(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickers_changeStickerPosition");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  sticker: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  position: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickers_addStickerToSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickers_addStickerToSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  sticker: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickers_setStickerSetThumb(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickers_setStickerSetThumb");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  thumb: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_installStickerSet(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_installStickerSet");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  stickerset: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  archived: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getMessagesViews(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getMessagesViews");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  increment: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getSavedGifs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getSavedGifs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getInlineBotResults(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_getInlineBotResults::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getInlineBotResults");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  bot: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  geo_point: "); ++stages.back(); if (flag & MTPmessages_getInlineBotResults::Flag::f_geo_point) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  query: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getMessageEditData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getMessageEditData");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getBotCallbackAnswer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_getBotCallbackAnswer::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getBotCallbackAnswer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  game: "); ++stages.back(); if (flag & MTPmessages_getBotCallbackAnswer::Flag::f_game) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  data: "); ++stages.back(); if (flag & MTPmessages_getBotCallbackAnswer::Flag::f_data) { types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  password: "); ++stages.back(); if (flag & MTPmessages_getBotCallbackAnswer::Flag::f_password) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getPeerDialogs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getPeerDialogs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peers: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getPinnedDialogs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getPinnedDialogs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  folder_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getFeaturedStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getFeaturedStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getOldFeaturedStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getOldFeaturedStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getRecentStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_getRecentStickers::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getRecentStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  attached: "); ++stages.back(); if (flag & MTPmessages_getRecentStickers::Flag::f_attached) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getArchivedStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_getArchivedStickers::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getArchivedStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  masks: "); ++stages.back(); if (flag & MTPmessages_getArchivedStickers::Flag::f_masks) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  offset_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getAttachedStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getAttachedStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  media: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getGameHighScores(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getGameHighScores");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getInlineGameHighScores(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getInlineGameHighScores");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getWebPage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getWebPage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  url: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getFavedStickers(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getFavedStickers");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_uploadEncryptedFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_uploadEncryptedFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_searchStickerSets(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_searchStickerSets::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_searchStickerSets");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  exclude_featured: "); ++stages.back(); if (flag & MTPmessages_searchStickerSets::Flag::f_exclude_featured) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getSplitRanges(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_getSplitRanges }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_getDialogUnreadMarks(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_getDialogUnreadMarks }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_getOnlines(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getOnlines");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getStatsURL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_getStatsURL::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getStatsURL");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  dark: "); ++stages.back(); if (flag & MTPmessages_getStatsURL::Flag::f_dark) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  params: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getEmojiKeywords(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getEmojiKeywords");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getEmojiKeywordsDifference(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getEmojiKeywordsDifference");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  from_version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getEmojiKeywordsLanguages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getEmojiKeywordsLanguages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_codes: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_string+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getEmojiURL(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getEmojiURL");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getSearchCounters(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getSearchCounters");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  filters: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_requestUrlAuth(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_requestUrlAuth::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_requestUrlAuth");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  peer: "); ++stages.back(); if (flag & MTPmessages_requestUrlAuth::Flag::f_peer) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 2: to.add("  msg_id: "); ++stages.back(); if (flag & MTPmessages_requestUrlAuth::Flag::f_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  button_id: "); ++stages.back(); if (flag & MTPmessages_requestUrlAuth::Flag::f_button_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  url: "); ++stages.back(); if (flag & MTPmessages_requestUrlAuth::Flag::f_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_acceptUrlAuth(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_acceptUrlAuth::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_acceptUrlAuth");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  write_allowed: "); ++stages.back(); if (flag & MTPmessages_acceptUrlAuth::Flag::f_write_allowed) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); if (flag & MTPmessages_acceptUrlAuth::Flag::f_peer) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  msg_id: "); ++stages.back(); if (flag & MTPmessages_acceptUrlAuth::Flag::f_msg_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 4: to.add("  button_id: "); ++stages.back(); if (flag & MTPmessages_acceptUrlAuth::Flag::f_button_id) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  url: "); ++stages.back(); if (flag & MTPmessages_acceptUrlAuth::Flag::f_url) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getPollVotes(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_getPollVotes::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getPollVotes");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  option: "); ++stages.back(); if (flag & MTPmessages_getPollVotes::Flag::f_option) { types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  offset: "); ++stages.back(); if (flag & MTPmessages_getPollVotes::Flag::f_offset) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getDialogFilters(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_getDialogFilters }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_getSuggestedDialogFilters(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ messages_getSuggestedDialogFilters }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_messages_getDiscussionMessage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getDiscussionMessage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_deletePhoneCallHistory(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_deletePhoneCallHistory::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_deletePhoneCallHistory");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  revoke: "); ++stages.back(); if (flag & MTPmessages_deletePhoneCallHistory::Flag::f_revoke) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_checkHistoryImport(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_checkHistoryImport");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  import_head: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_initHistoryImport(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_initHistoryImport");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  media_count: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getExportedChatInvites(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_getExportedChatInvites::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getExportedChatInvites");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  revoked: "); ++stages.back(); if (flag & MTPmessages_getExportedChatInvites::Flag::f_revoked) { to.add("YES [ BY BIT 3 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 3 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  admin_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  offset_date: "); ++stages.back(); if (flag & MTPmessages_getExportedChatInvites::Flag::f_offset_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 5: to.add("  offset_link: "); ++stages.back(); if (flag & MTPmessages_getExportedChatInvites::Flag::f_offset_link) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 6: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getExportedChatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getExportedChatInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  link: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_editExportedChatInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPmessages_editExportedChatInvite::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_editExportedChatInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  revoked: "); ++stages.back(); if (flag & MTPmessages_editExportedChatInvite::Flag::f_revoked) { to.add("YES [ BY BIT 2 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  link: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  expire_date: "); ++stages.back(); if (flag & MTPmessages_editExportedChatInvite::Flag::f_expire_date) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  usage_limit: "); ++stages.back(); if (flag & MTPmessages_editExportedChatInvite::Flag::f_usage_limit) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getAdminsWithInvites(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getAdminsWithInvites");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_getChatInviteImporters(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_getChatInviteImporters");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  link: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  offset_date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  offset_user: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_messages_checkHistoryImportPeer(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ messages_checkHistoryImportPeer");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates_getState(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ updates_getState }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_updates_getDifference(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPupdates_getDifference::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates_getDifference");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  pts_total_limit: "); ++stages.back(); if (flag & MTPupdates_getDifference::Flag::f_pts_total_limit) { types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 3: to.add("  date: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  qts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_updates_getChannelDifference(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPupdates_getChannelDifference::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ updates_getChannelDifference");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  force: "); ++stages.back(); if (flag & MTPupdates_getChannelDifference::Flag::f_force) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  filter: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  pts: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photos_updateProfilePhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photos_updateProfilePhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photos_uploadProfilePhoto(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPphotos_uploadProfilePhoto::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photos_uploadProfilePhoto");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  file: "); ++stages.back(); if (flag & MTPphotos_uploadProfilePhoto::Flag::f_file) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  video: "); ++stages.back(); if (flag & MTPphotos_uploadProfilePhoto::Flag::f_video) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  video_start_ts: "); ++stages.back(); if (flag & MTPphotos_uploadProfilePhoto::Flag::f_video_start_ts) { types.push_back(mtpc_double+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_photos_getUserPhotos(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ photos_getUserPhotos");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_getFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPupload_getFile::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_getFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  precise: "); ++stages.back(); if (flag & MTPupload_getFile::Flag::f_precise) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  cdn_supported: "); ++stages.back(); if (flag & MTPupload_getFile::Flag::f_cdn_supported) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  location: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_getWebFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_getWebFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  location: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_getCdnFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_getCdnFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  file_token: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_reuploadCdnFile(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_reuploadCdnFile");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  file_token: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  request_token: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_getCdnFileHashes(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_getCdnFileHashes");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  file_token: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_upload_getFileHashes(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ upload_getFileHashes");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  location: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_getConfig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_getConfig }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_getNearestDc(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_getNearestDc }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_getAppUpdate(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_getAppUpdate");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  source: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_getInviteText(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_getInviteText }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_getSupport(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_getSupport }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_getCdnConfig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_getCdnConfig }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_getRecentMeUrls(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_getRecentMeUrls");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  referer: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_getTermsOfServiceUpdate(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_getTermsOfServiceUpdate }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_getDeepLinkInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_getDeepLinkInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  path: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_getAppConfig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_getAppConfig }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_getPassportConfig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_getPassportConfig");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_getSupportName(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_getSupportName }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_getUserInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_getUserInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_editUserInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_editUserInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  message: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  entities: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_help_getPromoData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ help_getPromoData }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_help_getCountriesList(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ help_getCountriesList");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_getParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_getParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  filter: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  hash: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_getParticipant(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_getParticipant");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  participant: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_exportMessageLink(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPchannels_exportMessageLink::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_exportMessageLink");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  grouped: "); ++stages.back(); if (flag & MTPchannels_exportMessageLink::Flag::f_grouped) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  thread: "); ++stages.back(); if (flag & MTPchannels_exportMessageLink::Flag::f_thread) { to.add("YES [ BY BIT 1 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 3: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_getAdminLog(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPchannels_getAdminLog::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_getAdminLog");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  q: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  events_filter: "); ++stages.back(); if (flag & MTPchannels_getAdminLog::Flag::f_events_filter) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 4: to.add("  admins: "); ++stages.back(); if (flag & MTPchannels_getAdminLog::Flag::f_admins) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 5: to.add("  max_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 6: to.add("  min_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_channels_getInactiveChannels(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ channels_getInactiveChannels }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_channels_getSponsoredMessages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ channels_getSponsoredMessages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_bots_sendCustomRequest(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ bots_sendCustomRequest");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  custom_method: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  params: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_getCallConfig(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ phone_getCallConfig }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_bots_getBotCommands(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ bots_getBotCommands");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  scope: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_getPaymentForm(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPpayments_getPaymentForm::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_getPaymentForm");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  theme_params: "); ++stages.back(); if (flag & MTPpayments_getPaymentForm::Flag::f_theme_params) { types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_getPaymentReceipt(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_getPaymentReceipt");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_validateRequestedInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPpayments_validateRequestedInfo::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_validateRequestedInfo");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  save: "); ++stages.back(); if (flag & MTPpayments_validateRequestedInfo::Flag::f_save) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  info: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_sendPaymentForm(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPpayments_sendPaymentForm::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_sendPaymentForm");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  form_id: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  requested_info_id: "); ++stages.back(); if (flag & MTPpayments_sendPaymentForm::Flag::f_requested_info_id) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 5: to.add("  shipping_option_id: "); ++stages.back(); if (flag & MTPpayments_sendPaymentForm::Flag::f_shipping_option_id) { types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 1 IN FIELD flags ]"); } break;
	case 6: to.add("  credentials: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 7: to.add("  tip_amount: "); ++stages.back(); if (flag & MTPpayments_sendPaymentForm::Flag::f_tip_amount) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 2 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_payments_getSavedInfo(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	to.add("{ payments_getSavedInfo }"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back();
	return true;
}

bool Serialize_payments_getBankCardData(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ payments_getBankCardData");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  number: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stickers_suggestShortName(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stickers_suggestShortName");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  title: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_requestCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPphone_requestCall::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_requestCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  video: "); ++stages.back(); if (flag & MTPphone_requestCall::Flag::f_video) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  user_id: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  random_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  g_a_hash: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 5: to.add("  protocol: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_acceptCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_acceptCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  g_b: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  protocol: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_confirmCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_confirmCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  g_a: "); ++stages.back(); types.push_back(mtpc_bytes+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  key_fingerprint: "); ++stages.back(); types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  protocol: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_getGroupCall(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_getGroupCall");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_getGroupParticipants(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_getGroupParticipants");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  ids: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  sources: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_int+0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  offset: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 4: to.add("  limit: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_getGroupCallJoinAs(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_getGroupCallJoinAs");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  peer: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_phone_exportGroupCallInvite(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPphone_exportGroupCallInvite::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ phone_exportGroupCallInvite");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  can_self_unmute: "); ++stages.back(); if (flag & MTPphone_exportGroupCallInvite::Flag::f_can_self_unmute) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  call: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_langpack_getLangPack(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ langpack_getLangPack");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_pack: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_langpack_getDifference(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ langpack_getDifference");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_pack: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  from_version: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_langpack_getStrings(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ langpack_getStrings");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_pack: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  keys: "); ++stages.back(); types.push_back(0); vtypes.push_back(mtpc_string+0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_langpack_getLanguages(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ langpack_getLanguages");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_pack: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_langpack_getLanguage(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ langpack_getLanguage");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  lang_pack: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  lang_code: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stats_getBroadcastStats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPstats_getBroadcastStats::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stats_getBroadcastStats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  dark: "); ++stages.back(); if (flag & MTPstats_getBroadcastStats::Flag::f_dark) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stats_loadAsyncGraph(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPstats_loadAsyncGraph::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stats_loadAsyncGraph");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  token: "); ++stages.back(); types.push_back(mtpc_string+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  x: "); ++stages.back(); if (flag & MTPstats_loadAsyncGraph::Flag::f_x) { types.push_back(mtpc_long+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stats_getMegagroupStats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPstats_getMegagroupStats::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stats_getMegagroupStats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  dark: "); ++stages.back(); if (flag & MTPstats_getMegagroupStats::Flag::f_dark) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_stats_getMessageStats(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	auto flag = MTPstats_getMessageStats::Flags::from_raw(uint32(iflag));

	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ stats_getMessageStats");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  flags: "); ++stages.back(); if (start >= end) return false; else flags.back() = *start; types.push_back(mtpc_flags); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  dark: "); ++stages.back(); if (flag & MTPstats_getMessageStats::Flag::f_dark) { to.add("YES [ BY BIT 0 IN FIELD flags ]"); } else { to.add("[ SKIPPED BY BIT 0 IN FIELD flags ]"); } break;
	case 2: to.add("  channel: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_int+0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_rpc_result(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ rpc_result");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  req_msg_id: "); ++stages.back(); types.push_back(mtpc_long); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  result: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_msg_container(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ msg_container");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  messages: "); ++stages.back(); types.push_back(mtpc_vector); vtypes.push_back(mtpc_core_message); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}

bool Serialize_core_message(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag) {
	if (stage) {
		to.add(",\n").addSpaces(lev);
	} else {
		to.add("{ core_message");
		to.add("\n").addSpaces(lev);
	}
	switch (stage) {
	case 0: to.add("  msg_id: "); ++stages.back(); types.push_back(mtpc_long); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 1: to.add("  seq_no: "); ++stages.back(); types.push_back(mtpc_int); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 2: to.add("  bytes: "); ++stages.back(); types.push_back(mtpc_int); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	case 3: to.add("  body: "); ++stages.back(); types.push_back(0); vtypes.push_back(0); stages.push_back(0); flags.push_back(0); break;
	default: to.add("}"); types.pop_back(); vtypes.pop_back(); stages.pop_back(); flags.pop_back(); break;
	}
	return true;
}



using TextSerializer = bool (*)(DumpToTextBuffer &to, int32 stage, int32 lev, Types &types, Types &vtypes, Stages &stages, Flags &flags, const mtpPrime *start, const mtpPrime *end, uint64 iflag);

std::map<mtpTypeId, TextSerializer> CreateTextSerializers() {
	return {
		{ mtpc_resPQ, Serialize_resPQ },
		{ mtpc_p_q_inner_data, Serialize_p_q_inner_data },
		{ mtpc_p_q_inner_data_dc, Serialize_p_q_inner_data_dc },
		{ mtpc_p_q_inner_data_temp, Serialize_p_q_inner_data_temp },
		{ mtpc_p_q_inner_data_temp_dc, Serialize_p_q_inner_data_temp_dc },
		{ mtpc_bind_auth_key_inner, Serialize_bind_auth_key_inner },
		{ mtpc_server_DH_params_fail, Serialize_server_DH_params_fail },
		{ mtpc_server_DH_params_ok, Serialize_server_DH_params_ok },
		{ mtpc_server_DH_inner_data, Serialize_server_DH_inner_data },
		{ mtpc_client_DH_inner_data, Serialize_client_DH_inner_data },
		{ mtpc_dh_gen_ok, Serialize_dh_gen_ok },
		{ mtpc_dh_gen_retry, Serialize_dh_gen_retry },
		{ mtpc_dh_gen_fail, Serialize_dh_gen_fail },
		{ mtpc_destroy_auth_key_ok, Serialize_destroy_auth_key_ok },
		{ mtpc_destroy_auth_key_none, Serialize_destroy_auth_key_none },
		{ mtpc_destroy_auth_key_fail, Serialize_destroy_auth_key_fail },
		{ mtpc_msgs_ack, Serialize_msgs_ack },
		{ mtpc_bad_msg_notification, Serialize_bad_msg_notification },
		{ mtpc_bad_server_salt, Serialize_bad_server_salt },
		{ mtpc_msgs_state_req, Serialize_msgs_state_req },
		{ mtpc_msgs_state_info, Serialize_msgs_state_info },
		{ mtpc_msgs_all_info, Serialize_msgs_all_info },
		{ mtpc_msg_detailed_info, Serialize_msg_detailed_info },
		{ mtpc_msg_new_detailed_info, Serialize_msg_new_detailed_info },
		{ mtpc_msg_resend_req, Serialize_msg_resend_req },
		{ mtpc_rpc_error, Serialize_rpc_error },
		{ mtpc_rpc_answer_unknown, Serialize_rpc_answer_unknown },
		{ mtpc_rpc_answer_dropped_running, Serialize_rpc_answer_dropped_running },
		{ mtpc_rpc_answer_dropped, Serialize_rpc_answer_dropped },
		{ mtpc_future_salt, Serialize_future_salt },
		{ mtpc_future_salts, Serialize_future_salts },
		{ mtpc_pong, Serialize_pong },
		{ mtpc_destroy_session_ok, Serialize_destroy_session_ok },
		{ mtpc_destroy_session_none, Serialize_destroy_session_none },
		{ mtpc_new_session_created, Serialize_new_session_created },
		{ mtpc_http_wait, Serialize_http_wait },
		{ mtpc_ipPort, Serialize_ipPort },
		{ mtpc_ipPortSecret, Serialize_ipPortSecret },
		{ mtpc_accessPointRule, Serialize_accessPointRule },
		{ mtpc_help_configSimple, Serialize_help_configSimple },
		{ mtpc_tlsClientHello, Serialize_tlsClientHello },
		{ mtpc_tlsBlockString, Serialize_tlsBlockString },
		{ mtpc_tlsBlockRandom, Serialize_tlsBlockRandom },
		{ mtpc_tlsBlockZero, Serialize_tlsBlockZero },
		{ mtpc_tlsBlockDomain, Serialize_tlsBlockDomain },
		{ mtpc_tlsBlockGrease, Serialize_tlsBlockGrease },
		{ mtpc_tlsBlockPublicKey, Serialize_tlsBlockPublicKey },
		{ mtpc_tlsBlockScope, Serialize_tlsBlockScope },
		{ mtpc_boolFalse, Serialize_boolFalse },
		{ mtpc_boolTrue, Serialize_boolTrue },
		{ mtpc_true, Serialize_true },
		{ mtpc_error, Serialize_error },
		{ mtpc_null, Serialize_null },
		{ mtpc_inputPeerEmpty, Serialize_inputPeerEmpty },
		{ mtpc_inputPeerSelf, Serialize_inputPeerSelf },
		{ mtpc_inputPeerChat, Serialize_inputPeerChat },
		{ mtpc_inputPeerUser, Serialize_inputPeerUser },
		{ mtpc_inputPeerChannel, Serialize_inputPeerChannel },
		{ mtpc_inputPeerUserFromMessage, Serialize_inputPeerUserFromMessage },
		{ mtpc_inputPeerChannelFromMessage, Serialize_inputPeerChannelFromMessage },
		{ mtpc_inputUserEmpty, Serialize_inputUserEmpty },
		{ mtpc_inputUserSelf, Serialize_inputUserSelf },
		{ mtpc_inputUser, Serialize_inputUser },
		{ mtpc_inputUserFromMessage, Serialize_inputUserFromMessage },
		{ mtpc_inputPhoneContact, Serialize_inputPhoneContact },
		{ mtpc_inputFile, Serialize_inputFile },
		{ mtpc_inputFileBig, Serialize_inputFileBig },
		{ mtpc_inputMediaEmpty, Serialize_inputMediaEmpty },
		{ mtpc_inputMediaUploadedPhoto, Serialize_inputMediaUploadedPhoto },
		{ mtpc_inputMediaPhoto, Serialize_inputMediaPhoto },
		{ mtpc_inputMediaGeoPoint, Serialize_inputMediaGeoPoint },
		{ mtpc_inputMediaContact, Serialize_inputMediaContact },
		{ mtpc_inputMediaUploadedDocument, Serialize_inputMediaUploadedDocument },
		{ mtpc_inputMediaDocument, Serialize_inputMediaDocument },
		{ mtpc_inputMediaVenue, Serialize_inputMediaVenue },
		{ mtpc_inputMediaPhotoExternal, Serialize_inputMediaPhotoExternal },
		{ mtpc_inputMediaDocumentExternal, Serialize_inputMediaDocumentExternal },
		{ mtpc_inputMediaGame, Serialize_inputMediaGame },
		{ mtpc_inputMediaInvoice, Serialize_inputMediaInvoice },
		{ mtpc_inputMediaGeoLive, Serialize_inputMediaGeoLive },
		{ mtpc_inputMediaPoll, Serialize_inputMediaPoll },
		{ mtpc_inputMediaDice, Serialize_inputMediaDice },
		{ mtpc_inputChatPhotoEmpty, Serialize_inputChatPhotoEmpty },
		{ mtpc_inputChatUploadedPhoto, Serialize_inputChatUploadedPhoto },
		{ mtpc_inputChatPhoto, Serialize_inputChatPhoto },
		{ mtpc_inputGeoPointEmpty, Serialize_inputGeoPointEmpty },
		{ mtpc_inputGeoPoint, Serialize_inputGeoPoint },
		{ mtpc_inputPhotoEmpty, Serialize_inputPhotoEmpty },
		{ mtpc_inputPhoto, Serialize_inputPhoto },
		{ mtpc_inputFileLocation, Serialize_inputFileLocation },
		{ mtpc_inputEncryptedFileLocation, Serialize_inputEncryptedFileLocation },
		{ mtpc_inputDocumentFileLocation, Serialize_inputDocumentFileLocation },
		{ mtpc_inputSecureFileLocation, Serialize_inputSecureFileLocation },
		{ mtpc_inputTakeoutFileLocation, Serialize_inputTakeoutFileLocation },
		{ mtpc_inputPhotoFileLocation, Serialize_inputPhotoFileLocation },
		{ mtpc_inputPhotoLegacyFileLocation, Serialize_inputPhotoLegacyFileLocation },
		{ mtpc_inputPeerPhotoFileLocation, Serialize_inputPeerPhotoFileLocation },
		{ mtpc_inputStickerSetThumb, Serialize_inputStickerSetThumb },
		{ mtpc_inputGroupCallStream, Serialize_inputGroupCallStream },
		{ mtpc_peerUser, Serialize_peerUser },
		{ mtpc_peerChat, Serialize_peerChat },
		{ mtpc_peerChannel, Serialize_peerChannel },
		{ mtpc_storage_fileUnknown, Serialize_storage_fileUnknown },
		{ mtpc_storage_filePartial, Serialize_storage_filePartial },
		{ mtpc_storage_fileJpeg, Serialize_storage_fileJpeg },
		{ mtpc_storage_fileGif, Serialize_storage_fileGif },
		{ mtpc_storage_filePng, Serialize_storage_filePng },
		{ mtpc_storage_filePdf, Serialize_storage_filePdf },
		{ mtpc_storage_fileMp3, Serialize_storage_fileMp3 },
		{ mtpc_storage_fileMov, Serialize_storage_fileMov },
		{ mtpc_storage_fileMp4, Serialize_storage_fileMp4 },
		{ mtpc_storage_fileWebp, Serialize_storage_fileWebp },
		{ mtpc_userEmpty, Serialize_userEmpty },
		{ mtpc_user, Serialize_user },
		{ mtpc_userProfilePhotoEmpty, Serialize_userProfilePhotoEmpty },
		{ mtpc_userProfilePhoto, Serialize_userProfilePhoto },
		{ mtpc_userStatusEmpty, Serialize_userStatusEmpty },
		{ mtpc_userStatusOnline, Serialize_userStatusOnline },
		{ mtpc_userStatusOffline, Serialize_userStatusOffline },
		{ mtpc_userStatusRecently, Serialize_userStatusRecently },
		{ mtpc_userStatusLastWeek, Serialize_userStatusLastWeek },
		{ mtpc_userStatusLastMonth, Serialize_userStatusLastMonth },
		{ mtpc_chatEmpty, Serialize_chatEmpty },
		{ mtpc_chat, Serialize_chat },
		{ mtpc_chatForbidden, Serialize_chatForbidden },
		{ mtpc_channel, Serialize_channel },
		{ mtpc_channelForbidden, Serialize_channelForbidden },
		{ mtpc_chatFull, Serialize_chatFull },
		{ mtpc_channelFull, Serialize_channelFull },
		{ mtpc_chatParticipant, Serialize_chatParticipant },
		{ mtpc_chatParticipantCreator, Serialize_chatParticipantCreator },
		{ mtpc_chatParticipantAdmin, Serialize_chatParticipantAdmin },
		{ mtpc_chatParticipantsForbidden, Serialize_chatParticipantsForbidden },
		{ mtpc_chatParticipants, Serialize_chatParticipants },
		{ mtpc_chatPhotoEmpty, Serialize_chatPhotoEmpty },
		{ mtpc_chatPhoto, Serialize_chatPhoto },
		{ mtpc_messageEmpty, Serialize_messageEmpty },
		{ mtpc_message, Serialize_message },
		{ mtpc_messageService, Serialize_messageService },
		{ mtpc_messageMediaEmpty, Serialize_messageMediaEmpty },
		{ mtpc_messageMediaPhoto, Serialize_messageMediaPhoto },
		{ mtpc_messageMediaGeo, Serialize_messageMediaGeo },
		{ mtpc_messageMediaContact, Serialize_messageMediaContact },
		{ mtpc_messageMediaUnsupported, Serialize_messageMediaUnsupported },
		{ mtpc_messageMediaDocument, Serialize_messageMediaDocument },
		{ mtpc_messageMediaWebPage, Serialize_messageMediaWebPage },
		{ mtpc_messageMediaVenue, Serialize_messageMediaVenue },
		{ mtpc_messageMediaGame, Serialize_messageMediaGame },
		{ mtpc_messageMediaInvoice, Serialize_messageMediaInvoice },
		{ mtpc_messageMediaGeoLive, Serialize_messageMediaGeoLive },
		{ mtpc_messageMediaPoll, Serialize_messageMediaPoll },
		{ mtpc_messageMediaDice, Serialize_messageMediaDice },
		{ mtpc_messageActionEmpty, Serialize_messageActionEmpty },
		{ mtpc_messageActionChatCreate, Serialize_messageActionChatCreate },
		{ mtpc_messageActionChatEditTitle, Serialize_messageActionChatEditTitle },
		{ mtpc_messageActionChatEditPhoto, Serialize_messageActionChatEditPhoto },
		{ mtpc_messageActionChatDeletePhoto, Serialize_messageActionChatDeletePhoto },
		{ mtpc_messageActionChatAddUser, Serialize_messageActionChatAddUser },
		{ mtpc_messageActionChatDeleteUser, Serialize_messageActionChatDeleteUser },
		{ mtpc_messageActionChatJoinedByLink, Serialize_messageActionChatJoinedByLink },
		{ mtpc_messageActionChannelCreate, Serialize_messageActionChannelCreate },
		{ mtpc_messageActionChatMigrateTo, Serialize_messageActionChatMigrateTo },
		{ mtpc_messageActionChannelMigrateFrom, Serialize_messageActionChannelMigrateFrom },
		{ mtpc_messageActionPinMessage, Serialize_messageActionPinMessage },
		{ mtpc_messageActionHistoryClear, Serialize_messageActionHistoryClear },
		{ mtpc_messageActionGameScore, Serialize_messageActionGameScore },
		{ mtpc_messageActionPaymentSentMe, Serialize_messageActionPaymentSentMe },
		{ mtpc_messageActionPaymentSent, Serialize_messageActionPaymentSent },
		{ mtpc_messageActionPhoneCall, Serialize_messageActionPhoneCall },
		{ mtpc_messageActionScreenshotTaken, Serialize_messageActionScreenshotTaken },
		{ mtpc_messageActionCustomAction, Serialize_messageActionCustomAction },
		{ mtpc_messageActionBotAllowed, Serialize_messageActionBotAllowed },
		{ mtpc_messageActionSecureValuesSentMe, Serialize_messageActionSecureValuesSentMe },
		{ mtpc_messageActionSecureValuesSent, Serialize_messageActionSecureValuesSent },
		{ mtpc_messageActionContactSignUp, Serialize_messageActionContactSignUp },
		{ mtpc_messageActionGeoProximityReached, Serialize_messageActionGeoProximityReached },
		{ mtpc_messageActionGroupCall, Serialize_messageActionGroupCall },
		{ mtpc_messageActionInviteToGroupCall, Serialize_messageActionInviteToGroupCall },
		{ mtpc_messageActionSetMessagesTTL, Serialize_messageActionSetMessagesTTL },
		{ mtpc_messageActionGroupCallScheduled, Serialize_messageActionGroupCallScheduled },
		{ mtpc_messageActionSetChatTheme, Serialize_messageActionSetChatTheme },
		{ mtpc_dialog, Serialize_dialog },
		{ mtpc_dialogFolder, Serialize_dialogFolder },
		{ mtpc_photoEmpty, Serialize_photoEmpty },
		{ mtpc_photo, Serialize_photo },
		{ mtpc_photoSizeEmpty, Serialize_photoSizeEmpty },
		{ mtpc_photoSize, Serialize_photoSize },
		{ mtpc_photoCachedSize, Serialize_photoCachedSize },
		{ mtpc_photoStrippedSize, Serialize_photoStrippedSize },
		{ mtpc_photoSizeProgressive, Serialize_photoSizeProgressive },
		{ mtpc_photoPathSize, Serialize_photoPathSize },
		{ mtpc_geoPointEmpty, Serialize_geoPointEmpty },
		{ mtpc_geoPoint, Serialize_geoPoint },
		{ mtpc_auth_sentCode, Serialize_auth_sentCode },
		{ mtpc_auth_authorization, Serialize_auth_authorization },
		{ mtpc_auth_authorizationSignUpRequired, Serialize_auth_authorizationSignUpRequired },
		{ mtpc_auth_exportedAuthorization, Serialize_auth_exportedAuthorization },
		{ mtpc_inputNotifyPeer, Serialize_inputNotifyPeer },
		{ mtpc_inputNotifyUsers, Serialize_inputNotifyUsers },
		{ mtpc_inputNotifyChats, Serialize_inputNotifyChats },
		{ mtpc_inputNotifyBroadcasts, Serialize_inputNotifyBroadcasts },
		{ mtpc_inputPeerNotifySettings, Serialize_inputPeerNotifySettings },
		{ mtpc_peerNotifySettings, Serialize_peerNotifySettings },
		{ mtpc_peerSettings, Serialize_peerSettings },
		{ mtpc_wallPaper, Serialize_wallPaper },
		{ mtpc_wallPaperNoFile, Serialize_wallPaperNoFile },
		{ mtpc_inputReportReasonSpam, Serialize_inputReportReasonSpam },
		{ mtpc_inputReportReasonViolence, Serialize_inputReportReasonViolence },
		{ mtpc_inputReportReasonPornography, Serialize_inputReportReasonPornography },
		{ mtpc_inputReportReasonChildAbuse, Serialize_inputReportReasonChildAbuse },
		{ mtpc_inputReportReasonOther, Serialize_inputReportReasonOther },
		{ mtpc_inputReportReasonCopyright, Serialize_inputReportReasonCopyright },
		{ mtpc_inputReportReasonGeoIrrelevant, Serialize_inputReportReasonGeoIrrelevant },
		{ mtpc_inputReportReasonFake, Serialize_inputReportReasonFake },
		{ mtpc_userFull, Serialize_userFull },
		{ mtpc_contact, Serialize_contact },
		{ mtpc_importedContact, Serialize_importedContact },
		{ mtpc_contactStatus, Serialize_contactStatus },
		{ mtpc_contacts_contactsNotModified, Serialize_contacts_contactsNotModified },
		{ mtpc_contacts_contacts, Serialize_contacts_contacts },
		{ mtpc_contacts_importedContacts, Serialize_contacts_importedContacts },
		{ mtpc_contacts_blocked, Serialize_contacts_blocked },
		{ mtpc_contacts_blockedSlice, Serialize_contacts_blockedSlice },
		{ mtpc_messages_dialogs, Serialize_messages_dialogs },
		{ mtpc_messages_dialogsSlice, Serialize_messages_dialogsSlice },
		{ mtpc_messages_dialogsNotModified, Serialize_messages_dialogsNotModified },
		{ mtpc_messages_messages, Serialize_messages_messages },
		{ mtpc_messages_messagesSlice, Serialize_messages_messagesSlice },
		{ mtpc_messages_channelMessages, Serialize_messages_channelMessages },
		{ mtpc_messages_messagesNotModified, Serialize_messages_messagesNotModified },
		{ mtpc_messages_chats, Serialize_messages_chats },
		{ mtpc_messages_chatsSlice, Serialize_messages_chatsSlice },
		{ mtpc_messages_chatFull, Serialize_messages_chatFull },
		{ mtpc_messages_affectedHistory, Serialize_messages_affectedHistory },
		{ mtpc_inputMessagesFilterEmpty, Serialize_inputMessagesFilterEmpty },
		{ mtpc_inputMessagesFilterPhotos, Serialize_inputMessagesFilterPhotos },
		{ mtpc_inputMessagesFilterVideo, Serialize_inputMessagesFilterVideo },
		{ mtpc_inputMessagesFilterPhotoVideo, Serialize_inputMessagesFilterPhotoVideo },
		{ mtpc_inputMessagesFilterDocument, Serialize_inputMessagesFilterDocument },
		{ mtpc_inputMessagesFilterUrl, Serialize_inputMessagesFilterUrl },
		{ mtpc_inputMessagesFilterGif, Serialize_inputMessagesFilterGif },
		{ mtpc_inputMessagesFilterVoice, Serialize_inputMessagesFilterVoice },
		{ mtpc_inputMessagesFilterMusic, Serialize_inputMessagesFilterMusic },
		{ mtpc_inputMessagesFilterChatPhotos, Serialize_inputMessagesFilterChatPhotos },
		{ mtpc_inputMessagesFilterPhoneCalls, Serialize_inputMessagesFilterPhoneCalls },
		{ mtpc_inputMessagesFilterRoundVoice, Serialize_inputMessagesFilterRoundVoice },
		{ mtpc_inputMessagesFilterRoundVideo, Serialize_inputMessagesFilterRoundVideo },
		{ mtpc_inputMessagesFilterMyMentions, Serialize_inputMessagesFilterMyMentions },
		{ mtpc_inputMessagesFilterGeo, Serialize_inputMessagesFilterGeo },
		{ mtpc_inputMessagesFilterContacts, Serialize_inputMessagesFilterContacts },
		{ mtpc_inputMessagesFilterPinned, Serialize_inputMessagesFilterPinned },
		{ mtpc_updateNewMessage, Serialize_updateNewMessage },
		{ mtpc_updateMessageID, Serialize_updateMessageID },
		{ mtpc_updateDeleteMessages, Serialize_updateDeleteMessages },
		{ mtpc_updateUserTyping, Serialize_updateUserTyping },
		{ mtpc_updateChatUserTyping, Serialize_updateChatUserTyping },
		{ mtpc_updateChatParticipants, Serialize_updateChatParticipants },
		{ mtpc_updateUserStatus, Serialize_updateUserStatus },
		{ mtpc_updateUserName, Serialize_updateUserName },
		{ mtpc_updateUserPhoto, Serialize_updateUserPhoto },
		{ mtpc_updateNewEncryptedMessage, Serialize_updateNewEncryptedMessage },
		{ mtpc_updateEncryptedChatTyping, Serialize_updateEncryptedChatTyping },
		{ mtpc_updateEncryption, Serialize_updateEncryption },
		{ mtpc_updateEncryptedMessagesRead, Serialize_updateEncryptedMessagesRead },
		{ mtpc_updateChatParticipantAdd, Serialize_updateChatParticipantAdd },
		{ mtpc_updateChatParticipantDelete, Serialize_updateChatParticipantDelete },
		{ mtpc_updateDcOptions, Serialize_updateDcOptions },
		{ mtpc_updateNotifySettings, Serialize_updateNotifySettings },
		{ mtpc_updateServiceNotification, Serialize_updateServiceNotification },
		{ mtpc_updatePrivacy, Serialize_updatePrivacy },
		{ mtpc_updateUserPhone, Serialize_updateUserPhone },
		{ mtpc_updateReadHistoryInbox, Serialize_updateReadHistoryInbox },
		{ mtpc_updateReadHistoryOutbox, Serialize_updateReadHistoryOutbox },
		{ mtpc_updateWebPage, Serialize_updateWebPage },
		{ mtpc_updateReadMessagesContents, Serialize_updateReadMessagesContents },
		{ mtpc_updateChannelTooLong, Serialize_updateChannelTooLong },
		{ mtpc_updateChannel, Serialize_updateChannel },
		{ mtpc_updateNewChannelMessage, Serialize_updateNewChannelMessage },
		{ mtpc_updateReadChannelInbox, Serialize_updateReadChannelInbox },
		{ mtpc_updateDeleteChannelMessages, Serialize_updateDeleteChannelMessages },
		{ mtpc_updateChannelMessageViews, Serialize_updateChannelMessageViews },
		{ mtpc_updateChatParticipantAdmin, Serialize_updateChatParticipantAdmin },
		{ mtpc_updateNewStickerSet, Serialize_updateNewStickerSet },
		{ mtpc_updateStickerSetsOrder, Serialize_updateStickerSetsOrder },
		{ mtpc_updateStickerSets, Serialize_updateStickerSets },
		{ mtpc_updateSavedGifs, Serialize_updateSavedGifs },
		{ mtpc_updateBotInlineQuery, Serialize_updateBotInlineQuery },
		{ mtpc_updateBotInlineSend, Serialize_updateBotInlineSend },
		{ mtpc_updateEditChannelMessage, Serialize_updateEditChannelMessage },
		{ mtpc_updateBotCallbackQuery, Serialize_updateBotCallbackQuery },
		{ mtpc_updateEditMessage, Serialize_updateEditMessage },
		{ mtpc_updateInlineBotCallbackQuery, Serialize_updateInlineBotCallbackQuery },
		{ mtpc_updateReadChannelOutbox, Serialize_updateReadChannelOutbox },
		{ mtpc_updateDraftMessage, Serialize_updateDraftMessage },
		{ mtpc_updateReadFeaturedStickers, Serialize_updateReadFeaturedStickers },
		{ mtpc_updateRecentStickers, Serialize_updateRecentStickers },
		{ mtpc_updateConfig, Serialize_updateConfig },
		{ mtpc_updatePtsChanged, Serialize_updatePtsChanged },
		{ mtpc_updateChannelWebPage, Serialize_updateChannelWebPage },
		{ mtpc_updateDialogPinned, Serialize_updateDialogPinned },
		{ mtpc_updatePinnedDialogs, Serialize_updatePinnedDialogs },
		{ mtpc_updateBotWebhookJSON, Serialize_updateBotWebhookJSON },
		{ mtpc_updateBotWebhookJSONQuery, Serialize_updateBotWebhookJSONQuery },
		{ mtpc_updateBotShippingQuery, Serialize_updateBotShippingQuery },
		{ mtpc_updateBotPrecheckoutQuery, Serialize_updateBotPrecheckoutQuery },
		{ mtpc_updatePhoneCall, Serialize_updatePhoneCall },
		{ mtpc_updateLangPackTooLong, Serialize_updateLangPackTooLong },
		{ mtpc_updateLangPack, Serialize_updateLangPack },
		{ mtpc_updateFavedStickers, Serialize_updateFavedStickers },
		{ mtpc_updateChannelReadMessagesContents, Serialize_updateChannelReadMessagesContents },
		{ mtpc_updateContactsReset, Serialize_updateContactsReset },
		{ mtpc_updateChannelAvailableMessages, Serialize_updateChannelAvailableMessages },
		{ mtpc_updateDialogUnreadMark, Serialize_updateDialogUnreadMark },
		{ mtpc_updateMessagePoll, Serialize_updateMessagePoll },
		{ mtpc_updateChatDefaultBannedRights, Serialize_updateChatDefaultBannedRights },
		{ mtpc_updateFolderPeers, Serialize_updateFolderPeers },
		{ mtpc_updatePeerSettings, Serialize_updatePeerSettings },
		{ mtpc_updatePeerLocated, Serialize_updatePeerLocated },
		{ mtpc_updateNewScheduledMessage, Serialize_updateNewScheduledMessage },
		{ mtpc_updateDeleteScheduledMessages, Serialize_updateDeleteScheduledMessages },
		{ mtpc_updateTheme, Serialize_updateTheme },
		{ mtpc_updateGeoLiveViewed, Serialize_updateGeoLiveViewed },
		{ mtpc_updateLoginToken, Serialize_updateLoginToken },
		{ mtpc_updateMessagePollVote, Serialize_updateMessagePollVote },
		{ mtpc_updateDialogFilter, Serialize_updateDialogFilter },
		{ mtpc_updateDialogFilterOrder, Serialize_updateDialogFilterOrder },
		{ mtpc_updateDialogFilters, Serialize_updateDialogFilters },
		{ mtpc_updatePhoneCallSignalingData, Serialize_updatePhoneCallSignalingData },
		{ mtpc_updateChannelMessageForwards, Serialize_updateChannelMessageForwards },
		{ mtpc_updateReadChannelDiscussionInbox, Serialize_updateReadChannelDiscussionInbox },
		{ mtpc_updateReadChannelDiscussionOutbox, Serialize_updateReadChannelDiscussionOutbox },
		{ mtpc_updatePeerBlocked, Serialize_updatePeerBlocked },
		{ mtpc_updateChannelUserTyping, Serialize_updateChannelUserTyping },
		{ mtpc_updatePinnedMessages, Serialize_updatePinnedMessages },
		{ mtpc_updatePinnedChannelMessages, Serialize_updatePinnedChannelMessages },
		{ mtpc_updateChat, Serialize_updateChat },
		{ mtpc_updateGroupCallParticipants, Serialize_updateGroupCallParticipants },
		{ mtpc_updateGroupCall, Serialize_updateGroupCall },
		{ mtpc_updatePeerHistoryTTL, Serialize_updatePeerHistoryTTL },
		{ mtpc_updateChatParticipant, Serialize_updateChatParticipant },
		{ mtpc_updateChannelParticipant, Serialize_updateChannelParticipant },
		{ mtpc_updateBotStopped, Serialize_updateBotStopped },
		{ mtpc_updateGroupCallConnection, Serialize_updateGroupCallConnection },
		{ mtpc_updateBotCommands, Serialize_updateBotCommands },
		{ mtpc_updates_state, Serialize_updates_state },
		{ mtpc_updates_differenceEmpty, Serialize_updates_differenceEmpty },
		{ mtpc_updates_difference, Serialize_updates_difference },
		{ mtpc_updates_differenceSlice, Serialize_updates_differenceSlice },
		{ mtpc_updates_differenceTooLong, Serialize_updates_differenceTooLong },
		{ mtpc_updatesTooLong, Serialize_updatesTooLong },
		{ mtpc_updateShortMessage, Serialize_updateShortMessage },
		{ mtpc_updateShortChatMessage, Serialize_updateShortChatMessage },
		{ mtpc_updateShort, Serialize_updateShort },
		{ mtpc_updatesCombined, Serialize_updatesCombined },
		{ mtpc_updates, Serialize_updates },
		{ mtpc_updateShortSentMessage, Serialize_updateShortSentMessage },
		{ mtpc_photos_photos, Serialize_photos_photos },
		{ mtpc_photos_photosSlice, Serialize_photos_photosSlice },
		{ mtpc_photos_photo, Serialize_photos_photo },
		{ mtpc_upload_file, Serialize_upload_file },
		{ mtpc_upload_fileCdnRedirect, Serialize_upload_fileCdnRedirect },
		{ mtpc_dcOption, Serialize_dcOption },
		{ mtpc_config, Serialize_config },
		{ mtpc_nearestDc, Serialize_nearestDc },
		{ mtpc_help_appUpdate, Serialize_help_appUpdate },
		{ mtpc_help_noAppUpdate, Serialize_help_noAppUpdate },
		{ mtpc_help_inviteText, Serialize_help_inviteText },
		{ mtpc_encryptedChatEmpty, Serialize_encryptedChatEmpty },
		{ mtpc_encryptedChatWaiting, Serialize_encryptedChatWaiting },
		{ mtpc_encryptedChatRequested, Serialize_encryptedChatRequested },
		{ mtpc_encryptedChat, Serialize_encryptedChat },
		{ mtpc_encryptedChatDiscarded, Serialize_encryptedChatDiscarded },
		{ mtpc_inputEncryptedChat, Serialize_inputEncryptedChat },
		{ mtpc_encryptedFileEmpty, Serialize_encryptedFileEmpty },
		{ mtpc_encryptedFile, Serialize_encryptedFile },
		{ mtpc_inputEncryptedFileEmpty, Serialize_inputEncryptedFileEmpty },
		{ mtpc_inputEncryptedFileUploaded, Serialize_inputEncryptedFileUploaded },
		{ mtpc_inputEncryptedFile, Serialize_inputEncryptedFile },
		{ mtpc_inputEncryptedFileBigUploaded, Serialize_inputEncryptedFileBigUploaded },
		{ mtpc_encryptedMessage, Serialize_encryptedMessage },
		{ mtpc_encryptedMessageService, Serialize_encryptedMessageService },
		{ mtpc_messages_dhConfigNotModified, Serialize_messages_dhConfigNotModified },
		{ mtpc_messages_dhConfig, Serialize_messages_dhConfig },
		{ mtpc_messages_sentEncryptedMessage, Serialize_messages_sentEncryptedMessage },
		{ mtpc_messages_sentEncryptedFile, Serialize_messages_sentEncryptedFile },
		{ mtpc_inputDocumentEmpty, Serialize_inputDocumentEmpty },
		{ mtpc_inputDocument, Serialize_inputDocument },
		{ mtpc_documentEmpty, Serialize_documentEmpty },
		{ mtpc_document, Serialize_document },
		{ mtpc_help_support, Serialize_help_support },
		{ mtpc_notifyPeer, Serialize_notifyPeer },
		{ mtpc_notifyUsers, Serialize_notifyUsers },
		{ mtpc_notifyChats, Serialize_notifyChats },
		{ mtpc_notifyBroadcasts, Serialize_notifyBroadcasts },
		{ mtpc_sendMessageTypingAction, Serialize_sendMessageTypingAction },
		{ mtpc_sendMessageCancelAction, Serialize_sendMessageCancelAction },
		{ mtpc_sendMessageRecordVideoAction, Serialize_sendMessageRecordVideoAction },
		{ mtpc_sendMessageUploadVideoAction, Serialize_sendMessageUploadVideoAction },
		{ mtpc_sendMessageRecordAudioAction, Serialize_sendMessageRecordAudioAction },
		{ mtpc_sendMessageUploadAudioAction, Serialize_sendMessageUploadAudioAction },
		{ mtpc_sendMessageUploadPhotoAction, Serialize_sendMessageUploadPhotoAction },
		{ mtpc_sendMessageUploadDocumentAction, Serialize_sendMessageUploadDocumentAction },
		{ mtpc_sendMessageGeoLocationAction, Serialize_sendMessageGeoLocationAction },
		{ mtpc_sendMessageChooseContactAction, Serialize_sendMessageChooseContactAction },
		{ mtpc_sendMessageGamePlayAction, Serialize_sendMessageGamePlayAction },
		{ mtpc_sendMessageRecordRoundAction, Serialize_sendMessageRecordRoundAction },
		{ mtpc_sendMessageUploadRoundAction, Serialize_sendMessageUploadRoundAction },
		{ mtpc_speakingInGroupCallAction, Serialize_speakingInGroupCallAction },
		{ mtpc_sendMessageHistoryImportAction, Serialize_sendMessageHistoryImportAction },
		{ mtpc_sendMessageChooseStickerAction, Serialize_sendMessageChooseStickerAction },
		{ mtpc_contacts_found, Serialize_contacts_found },
		{ mtpc_inputPrivacyKeyStatusTimestamp, Serialize_inputPrivacyKeyStatusTimestamp },
		{ mtpc_inputPrivacyKeyChatInvite, Serialize_inputPrivacyKeyChatInvite },
		{ mtpc_inputPrivacyKeyPhoneCall, Serialize_inputPrivacyKeyPhoneCall },
		{ mtpc_inputPrivacyKeyPhoneP2P, Serialize_inputPrivacyKeyPhoneP2P },
		{ mtpc_inputPrivacyKeyForwards, Serialize_inputPrivacyKeyForwards },
		{ mtpc_inputPrivacyKeyProfilePhoto, Serialize_inputPrivacyKeyProfilePhoto },
		{ mtpc_inputPrivacyKeyPhoneNumber, Serialize_inputPrivacyKeyPhoneNumber },
		{ mtpc_inputPrivacyKeyAddedByPhone, Serialize_inputPrivacyKeyAddedByPhone },
		{ mtpc_privacyKeyStatusTimestamp, Serialize_privacyKeyStatusTimestamp },
		{ mtpc_privacyKeyChatInvite, Serialize_privacyKeyChatInvite },
		{ mtpc_privacyKeyPhoneCall, Serialize_privacyKeyPhoneCall },
		{ mtpc_privacyKeyPhoneP2P, Serialize_privacyKeyPhoneP2P },
		{ mtpc_privacyKeyForwards, Serialize_privacyKeyForwards },
		{ mtpc_privacyKeyProfilePhoto, Serialize_privacyKeyProfilePhoto },
		{ mtpc_privacyKeyPhoneNumber, Serialize_privacyKeyPhoneNumber },
		{ mtpc_privacyKeyAddedByPhone, Serialize_privacyKeyAddedByPhone },
		{ mtpc_inputPrivacyValueAllowContacts, Serialize_inputPrivacyValueAllowContacts },
		{ mtpc_inputPrivacyValueAllowAll, Serialize_inputPrivacyValueAllowAll },
		{ mtpc_inputPrivacyValueAllowUsers, Serialize_inputPrivacyValueAllowUsers },
		{ mtpc_inputPrivacyValueDisallowContacts, Serialize_inputPrivacyValueDisallowContacts },
		{ mtpc_inputPrivacyValueDisallowAll, Serialize_inputPrivacyValueDisallowAll },
		{ mtpc_inputPrivacyValueDisallowUsers, Serialize_inputPrivacyValueDisallowUsers },
		{ mtpc_inputPrivacyValueAllowChatParticipants, Serialize_inputPrivacyValueAllowChatParticipants },
		{ mtpc_inputPrivacyValueDisallowChatParticipants, Serialize_inputPrivacyValueDisallowChatParticipants },
		{ mtpc_privacyValueAllowContacts, Serialize_privacyValueAllowContacts },
		{ mtpc_privacyValueAllowAll, Serialize_privacyValueAllowAll },
		{ mtpc_privacyValueAllowUsers, Serialize_privacyValueAllowUsers },
		{ mtpc_privacyValueDisallowContacts, Serialize_privacyValueDisallowContacts },
		{ mtpc_privacyValueDisallowAll, Serialize_privacyValueDisallowAll },
		{ mtpc_privacyValueDisallowUsers, Serialize_privacyValueDisallowUsers },
		{ mtpc_privacyValueAllowChatParticipants, Serialize_privacyValueAllowChatParticipants },
		{ mtpc_privacyValueDisallowChatParticipants, Serialize_privacyValueDisallowChatParticipants },
		{ mtpc_account_privacyRules, Serialize_account_privacyRules },
		{ mtpc_accountDaysTTL, Serialize_accountDaysTTL },
		{ mtpc_documentAttributeImageSize, Serialize_documentAttributeImageSize },
		{ mtpc_documentAttributeAnimated, Serialize_documentAttributeAnimated },
		{ mtpc_documentAttributeSticker, Serialize_documentAttributeSticker },
		{ mtpc_documentAttributeVideo, Serialize_documentAttributeVideo },
		{ mtpc_documentAttributeAudio, Serialize_documentAttributeAudio },
		{ mtpc_documentAttributeFilename, Serialize_documentAttributeFilename },
		{ mtpc_documentAttributeHasStickers, Serialize_documentAttributeHasStickers },
		{ mtpc_messages_stickersNotModified, Serialize_messages_stickersNotModified },
		{ mtpc_messages_stickers, Serialize_messages_stickers },
		{ mtpc_stickerPack, Serialize_stickerPack },
		{ mtpc_messages_allStickersNotModified, Serialize_messages_allStickersNotModified },
		{ mtpc_messages_allStickers, Serialize_messages_allStickers },
		{ mtpc_messages_affectedMessages, Serialize_messages_affectedMessages },
		{ mtpc_webPageEmpty, Serialize_webPageEmpty },
		{ mtpc_webPagePending, Serialize_webPagePending },
		{ mtpc_webPage, Serialize_webPage },
		{ mtpc_webPageNotModified, Serialize_webPageNotModified },
		{ mtpc_authorization, Serialize_authorization },
		{ mtpc_account_authorizations, Serialize_account_authorizations },
		{ mtpc_account_password, Serialize_account_password },
		{ mtpc_account_passwordSettings, Serialize_account_passwordSettings },
		{ mtpc_account_passwordInputSettings, Serialize_account_passwordInputSettings },
		{ mtpc_auth_passwordRecovery, Serialize_auth_passwordRecovery },
		{ mtpc_receivedNotifyMessage, Serialize_receivedNotifyMessage },
		{ mtpc_chatInviteExported, Serialize_chatInviteExported },
		{ mtpc_chatInviteAlready, Serialize_chatInviteAlready },
		{ mtpc_chatInvite, Serialize_chatInvite },
		{ mtpc_chatInvitePeek, Serialize_chatInvitePeek },
		{ mtpc_inputStickerSetEmpty, Serialize_inputStickerSetEmpty },
		{ mtpc_inputStickerSetID, Serialize_inputStickerSetID },
		{ mtpc_inputStickerSetShortName, Serialize_inputStickerSetShortName },
		{ mtpc_inputStickerSetAnimatedEmoji, Serialize_inputStickerSetAnimatedEmoji },
		{ mtpc_inputStickerSetDice, Serialize_inputStickerSetDice },
		{ mtpc_stickerSet, Serialize_stickerSet },
		{ mtpc_messages_stickerSet, Serialize_messages_stickerSet },
		{ mtpc_botCommand, Serialize_botCommand },
		{ mtpc_botInfo, Serialize_botInfo },
		{ mtpc_keyboardButton, Serialize_keyboardButton },
		{ mtpc_keyboardButtonUrl, Serialize_keyboardButtonUrl },
		{ mtpc_keyboardButtonCallback, Serialize_keyboardButtonCallback },
		{ mtpc_keyboardButtonRequestPhone, Serialize_keyboardButtonRequestPhone },
		{ mtpc_keyboardButtonRequestGeoLocation, Serialize_keyboardButtonRequestGeoLocation },
		{ mtpc_keyboardButtonSwitchInline, Serialize_keyboardButtonSwitchInline },
		{ mtpc_keyboardButtonGame, Serialize_keyboardButtonGame },
		{ mtpc_keyboardButtonBuy, Serialize_keyboardButtonBuy },
		{ mtpc_keyboardButtonUrlAuth, Serialize_keyboardButtonUrlAuth },
		{ mtpc_inputKeyboardButtonUrlAuth, Serialize_inputKeyboardButtonUrlAuth },
		{ mtpc_keyboardButtonRequestPoll, Serialize_keyboardButtonRequestPoll },
		{ mtpc_keyboardButtonRow, Serialize_keyboardButtonRow },
		{ mtpc_replyKeyboardHide, Serialize_replyKeyboardHide },
		{ mtpc_replyKeyboardForceReply, Serialize_replyKeyboardForceReply },
		{ mtpc_replyKeyboardMarkup, Serialize_replyKeyboardMarkup },
		{ mtpc_replyInlineMarkup, Serialize_replyInlineMarkup },
		{ mtpc_messageEntityUnknown, Serialize_messageEntityUnknown },
		{ mtpc_messageEntityMention, Serialize_messageEntityMention },
		{ mtpc_messageEntityHashtag, Serialize_messageEntityHashtag },
		{ mtpc_messageEntityBotCommand, Serialize_messageEntityBotCommand },
		{ mtpc_messageEntityUrl, Serialize_messageEntityUrl },
		{ mtpc_messageEntityEmail, Serialize_messageEntityEmail },
		{ mtpc_messageEntityBold, Serialize_messageEntityBold },
		{ mtpc_messageEntityItalic, Serialize_messageEntityItalic },
		{ mtpc_messageEntityCode, Serialize_messageEntityCode },
		{ mtpc_messageEntityPre, Serialize_messageEntityPre },
		{ mtpc_messageEntityTextUrl, Serialize_messageEntityTextUrl },
		{ mtpc_messageEntityMentionName, Serialize_messageEntityMentionName },
		{ mtpc_inputMessageEntityMentionName, Serialize_inputMessageEntityMentionName },
		{ mtpc_messageEntityPhone, Serialize_messageEntityPhone },
		{ mtpc_messageEntityCashtag, Serialize_messageEntityCashtag },
		{ mtpc_messageEntityUnderline, Serialize_messageEntityUnderline },
		{ mtpc_messageEntityStrike, Serialize_messageEntityStrike },
		{ mtpc_messageEntityBlockquote, Serialize_messageEntityBlockquote },
		{ mtpc_messageEntityBankCard, Serialize_messageEntityBankCard },
		{ mtpc_inputChannelEmpty, Serialize_inputChannelEmpty },
		{ mtpc_inputChannel, Serialize_inputChannel },
		{ mtpc_inputChannelFromMessage, Serialize_inputChannelFromMessage },
		{ mtpc_contacts_resolvedPeer, Serialize_contacts_resolvedPeer },
		{ mtpc_messageRange, Serialize_messageRange },
		{ mtpc_updates_channelDifferenceEmpty, Serialize_updates_channelDifferenceEmpty },
		{ mtpc_updates_channelDifferenceTooLong, Serialize_updates_channelDifferenceTooLong },
		{ mtpc_updates_channelDifference, Serialize_updates_channelDifference },
		{ mtpc_channelMessagesFilterEmpty, Serialize_channelMessagesFilterEmpty },
		{ mtpc_channelMessagesFilter, Serialize_channelMessagesFilter },
		{ mtpc_channelParticipant, Serialize_channelParticipant },
		{ mtpc_channelParticipantSelf, Serialize_channelParticipantSelf },
		{ mtpc_channelParticipantCreator, Serialize_channelParticipantCreator },
		{ mtpc_channelParticipantAdmin, Serialize_channelParticipantAdmin },
		{ mtpc_channelParticipantBanned, Serialize_channelParticipantBanned },
		{ mtpc_channelParticipantLeft, Serialize_channelParticipantLeft },
		{ mtpc_channelParticipantsRecent, Serialize_channelParticipantsRecent },
		{ mtpc_channelParticipantsAdmins, Serialize_channelParticipantsAdmins },
		{ mtpc_channelParticipantsKicked, Serialize_channelParticipantsKicked },
		{ mtpc_channelParticipantsBots, Serialize_channelParticipantsBots },
		{ mtpc_channelParticipantsBanned, Serialize_channelParticipantsBanned },
		{ mtpc_channelParticipantsSearch, Serialize_channelParticipantsSearch },
		{ mtpc_channelParticipantsContacts, Serialize_channelParticipantsContacts },
		{ mtpc_channelParticipantsMentions, Serialize_channelParticipantsMentions },
		{ mtpc_channels_channelParticipants, Serialize_channels_channelParticipants },
		{ mtpc_channels_channelParticipantsNotModified, Serialize_channels_channelParticipantsNotModified },
		{ mtpc_channels_channelParticipant, Serialize_channels_channelParticipant },
		{ mtpc_help_termsOfService, Serialize_help_termsOfService },
		{ mtpc_messages_savedGifsNotModified, Serialize_messages_savedGifsNotModified },
		{ mtpc_messages_savedGifs, Serialize_messages_savedGifs },
		{ mtpc_inputBotInlineMessageMediaAuto, Serialize_inputBotInlineMessageMediaAuto },
		{ mtpc_inputBotInlineMessageText, Serialize_inputBotInlineMessageText },
		{ mtpc_inputBotInlineMessageMediaGeo, Serialize_inputBotInlineMessageMediaGeo },
		{ mtpc_inputBotInlineMessageMediaVenue, Serialize_inputBotInlineMessageMediaVenue },
		{ mtpc_inputBotInlineMessageMediaContact, Serialize_inputBotInlineMessageMediaContact },
		{ mtpc_inputBotInlineMessageGame, Serialize_inputBotInlineMessageGame },
		{ mtpc_inputBotInlineMessageMediaInvoice, Serialize_inputBotInlineMessageMediaInvoice },
		{ mtpc_inputBotInlineResult, Serialize_inputBotInlineResult },
		{ mtpc_inputBotInlineResultPhoto, Serialize_inputBotInlineResultPhoto },
		{ mtpc_inputBotInlineResultDocument, Serialize_inputBotInlineResultDocument },
		{ mtpc_inputBotInlineResultGame, Serialize_inputBotInlineResultGame },
		{ mtpc_botInlineMessageMediaAuto, Serialize_botInlineMessageMediaAuto },
		{ mtpc_botInlineMessageText, Serialize_botInlineMessageText },
		{ mtpc_botInlineMessageMediaGeo, Serialize_botInlineMessageMediaGeo },
		{ mtpc_botInlineMessageMediaVenue, Serialize_botInlineMessageMediaVenue },
		{ mtpc_botInlineMessageMediaContact, Serialize_botInlineMessageMediaContact },
		{ mtpc_botInlineMessageMediaInvoice, Serialize_botInlineMessageMediaInvoice },
		{ mtpc_botInlineResult, Serialize_botInlineResult },
		{ mtpc_botInlineMediaResult, Serialize_botInlineMediaResult },
		{ mtpc_messages_botResults, Serialize_messages_botResults },
		{ mtpc_exportedMessageLink, Serialize_exportedMessageLink },
		{ mtpc_messageFwdHeader, Serialize_messageFwdHeader },
		{ mtpc_auth_codeTypeSms, Serialize_auth_codeTypeSms },
		{ mtpc_auth_codeTypeCall, Serialize_auth_codeTypeCall },
		{ mtpc_auth_codeTypeFlashCall, Serialize_auth_codeTypeFlashCall },
		{ mtpc_auth_sentCodeTypeApp, Serialize_auth_sentCodeTypeApp },
		{ mtpc_auth_sentCodeTypeSms, Serialize_auth_sentCodeTypeSms },
		{ mtpc_auth_sentCodeTypeCall, Serialize_auth_sentCodeTypeCall },
		{ mtpc_auth_sentCodeTypeFlashCall, Serialize_auth_sentCodeTypeFlashCall },
		{ mtpc_messages_botCallbackAnswer, Serialize_messages_botCallbackAnswer },
		{ mtpc_messages_messageEditData, Serialize_messages_messageEditData },
		{ mtpc_inputBotInlineMessageID, Serialize_inputBotInlineMessageID },
		{ mtpc_inlineBotSwitchPM, Serialize_inlineBotSwitchPM },
		{ mtpc_messages_peerDialogs, Serialize_messages_peerDialogs },
		{ mtpc_topPeer, Serialize_topPeer },
		{ mtpc_topPeerCategoryBotsPM, Serialize_topPeerCategoryBotsPM },
		{ mtpc_topPeerCategoryBotsInline, Serialize_topPeerCategoryBotsInline },
		{ mtpc_topPeerCategoryCorrespondents, Serialize_topPeerCategoryCorrespondents },
		{ mtpc_topPeerCategoryGroups, Serialize_topPeerCategoryGroups },
		{ mtpc_topPeerCategoryChannels, Serialize_topPeerCategoryChannels },
		{ mtpc_topPeerCategoryPhoneCalls, Serialize_topPeerCategoryPhoneCalls },
		{ mtpc_topPeerCategoryForwardUsers, Serialize_topPeerCategoryForwardUsers },
		{ mtpc_topPeerCategoryForwardChats, Serialize_topPeerCategoryForwardChats },
		{ mtpc_topPeerCategoryPeers, Serialize_topPeerCategoryPeers },
		{ mtpc_contacts_topPeersNotModified, Serialize_contacts_topPeersNotModified },
		{ mtpc_contacts_topPeers, Serialize_contacts_topPeers },
		{ mtpc_contacts_topPeersDisabled, Serialize_contacts_topPeersDisabled },
		{ mtpc_draftMessageEmpty, Serialize_draftMessageEmpty },
		{ mtpc_draftMessage, Serialize_draftMessage },
		{ mtpc_messages_featuredStickersNotModified, Serialize_messages_featuredStickersNotModified },
		{ mtpc_messages_featuredStickers, Serialize_messages_featuredStickers },
		{ mtpc_messages_recentStickersNotModified, Serialize_messages_recentStickersNotModified },
		{ mtpc_messages_recentStickers, Serialize_messages_recentStickers },
		{ mtpc_messages_archivedStickers, Serialize_messages_archivedStickers },
		{ mtpc_messages_stickerSetInstallResultSuccess, Serialize_messages_stickerSetInstallResultSuccess },
		{ mtpc_messages_stickerSetInstallResultArchive, Serialize_messages_stickerSetInstallResultArchive },
		{ mtpc_stickerSetCovered, Serialize_stickerSetCovered },
		{ mtpc_stickerSetMultiCovered, Serialize_stickerSetMultiCovered },
		{ mtpc_maskCoords, Serialize_maskCoords },
		{ mtpc_inputStickeredMediaPhoto, Serialize_inputStickeredMediaPhoto },
		{ mtpc_inputStickeredMediaDocument, Serialize_inputStickeredMediaDocument },
		{ mtpc_game, Serialize_game },
		{ mtpc_inputGameID, Serialize_inputGameID },
		{ mtpc_inputGameShortName, Serialize_inputGameShortName },
		{ mtpc_highScore, Serialize_highScore },
		{ mtpc_messages_highScores, Serialize_messages_highScores },
		{ mtpc_textEmpty, Serialize_textEmpty },
		{ mtpc_textPlain, Serialize_textPlain },
		{ mtpc_textBold, Serialize_textBold },
		{ mtpc_textItalic, Serialize_textItalic },
		{ mtpc_textUnderline, Serialize_textUnderline },
		{ mtpc_textStrike, Serialize_textStrike },
		{ mtpc_textFixed, Serialize_textFixed },
		{ mtpc_textUrl, Serialize_textUrl },
		{ mtpc_textEmail, Serialize_textEmail },
		{ mtpc_textConcat, Serialize_textConcat },
		{ mtpc_textSubscript, Serialize_textSubscript },
		{ mtpc_textSuperscript, Serialize_textSuperscript },
		{ mtpc_textMarked, Serialize_textMarked },
		{ mtpc_textPhone, Serialize_textPhone },
		{ mtpc_textImage, Serialize_textImage },
		{ mtpc_textAnchor, Serialize_textAnchor },
		{ mtpc_pageBlockUnsupported, Serialize_pageBlockUnsupported },
		{ mtpc_pageBlockTitle, Serialize_pageBlockTitle },
		{ mtpc_pageBlockSubtitle, Serialize_pageBlockSubtitle },
		{ mtpc_pageBlockAuthorDate, Serialize_pageBlockAuthorDate },
		{ mtpc_pageBlockHeader, Serialize_pageBlockHeader },
		{ mtpc_pageBlockSubheader, Serialize_pageBlockSubheader },
		{ mtpc_pageBlockParagraph, Serialize_pageBlockParagraph },
		{ mtpc_pageBlockPreformatted, Serialize_pageBlockPreformatted },
		{ mtpc_pageBlockFooter, Serialize_pageBlockFooter },
		{ mtpc_pageBlockDivider, Serialize_pageBlockDivider },
		{ mtpc_pageBlockAnchor, Serialize_pageBlockAnchor },
		{ mtpc_pageBlockList, Serialize_pageBlockList },
		{ mtpc_pageBlockBlockquote, Serialize_pageBlockBlockquote },
		{ mtpc_pageBlockPullquote, Serialize_pageBlockPullquote },
		{ mtpc_pageBlockPhoto, Serialize_pageBlockPhoto },
		{ mtpc_pageBlockVideo, Serialize_pageBlockVideo },
		{ mtpc_pageBlockCover, Serialize_pageBlockCover },
		{ mtpc_pageBlockEmbed, Serialize_pageBlockEmbed },
		{ mtpc_pageBlockEmbedPost, Serialize_pageBlockEmbedPost },
		{ mtpc_pageBlockCollage, Serialize_pageBlockCollage },
		{ mtpc_pageBlockSlideshow, Serialize_pageBlockSlideshow },
		{ mtpc_pageBlockChannel, Serialize_pageBlockChannel },
		{ mtpc_pageBlockAudio, Serialize_pageBlockAudio },
		{ mtpc_pageBlockKicker, Serialize_pageBlockKicker },
		{ mtpc_pageBlockTable, Serialize_pageBlockTable },
		{ mtpc_pageBlockOrderedList, Serialize_pageBlockOrderedList },
		{ mtpc_pageBlockDetails, Serialize_pageBlockDetails },
		{ mtpc_pageBlockRelatedArticles, Serialize_pageBlockRelatedArticles },
		{ mtpc_pageBlockMap, Serialize_pageBlockMap },
		{ mtpc_phoneCallDiscardReasonMissed, Serialize_phoneCallDiscardReasonMissed },
		{ mtpc_phoneCallDiscardReasonDisconnect, Serialize_phoneCallDiscardReasonDisconnect },
		{ mtpc_phoneCallDiscardReasonHangup, Serialize_phoneCallDiscardReasonHangup },
		{ mtpc_phoneCallDiscardReasonBusy, Serialize_phoneCallDiscardReasonBusy },
		{ mtpc_dataJSON, Serialize_dataJSON },
		{ mtpc_labeledPrice, Serialize_labeledPrice },
		{ mtpc_invoice, Serialize_invoice },
		{ mtpc_paymentCharge, Serialize_paymentCharge },
		{ mtpc_postAddress, Serialize_postAddress },
		{ mtpc_paymentRequestedInfo, Serialize_paymentRequestedInfo },
		{ mtpc_paymentSavedCredentialsCard, Serialize_paymentSavedCredentialsCard },
		{ mtpc_webDocument, Serialize_webDocument },
		{ mtpc_webDocumentNoProxy, Serialize_webDocumentNoProxy },
		{ mtpc_inputWebDocument, Serialize_inputWebDocument },
		{ mtpc_inputWebFileLocation, Serialize_inputWebFileLocation },
		{ mtpc_inputWebFileGeoPointLocation, Serialize_inputWebFileGeoPointLocation },
		{ mtpc_upload_webFile, Serialize_upload_webFile },
		{ mtpc_payments_paymentForm, Serialize_payments_paymentForm },
		{ mtpc_payments_validatedRequestedInfo, Serialize_payments_validatedRequestedInfo },
		{ mtpc_payments_paymentResult, Serialize_payments_paymentResult },
		{ mtpc_payments_paymentVerificationNeeded, Serialize_payments_paymentVerificationNeeded },
		{ mtpc_payments_paymentReceipt, Serialize_payments_paymentReceipt },
		{ mtpc_payments_savedInfo, Serialize_payments_savedInfo },
		{ mtpc_inputPaymentCredentialsSaved, Serialize_inputPaymentCredentialsSaved },
		{ mtpc_inputPaymentCredentials, Serialize_inputPaymentCredentials },
		{ mtpc_inputPaymentCredentialsApplePay, Serialize_inputPaymentCredentialsApplePay },
		{ mtpc_inputPaymentCredentialsGooglePay, Serialize_inputPaymentCredentialsGooglePay },
		{ mtpc_account_tmpPassword, Serialize_account_tmpPassword },
		{ mtpc_shippingOption, Serialize_shippingOption },
		{ mtpc_inputStickerSetItem, Serialize_inputStickerSetItem },
		{ mtpc_inputPhoneCall, Serialize_inputPhoneCall },
		{ mtpc_phoneCallEmpty, Serialize_phoneCallEmpty },
		{ mtpc_phoneCallWaiting, Serialize_phoneCallWaiting },
		{ mtpc_phoneCallRequested, Serialize_phoneCallRequested },
		{ mtpc_phoneCallAccepted, Serialize_phoneCallAccepted },
		{ mtpc_phoneCall, Serialize_phoneCall },
		{ mtpc_phoneCallDiscarded, Serialize_phoneCallDiscarded },
		{ mtpc_phoneConnection, Serialize_phoneConnection },
		{ mtpc_phoneConnectionWebrtc, Serialize_phoneConnectionWebrtc },
		{ mtpc_phoneCallProtocol, Serialize_phoneCallProtocol },
		{ mtpc_phone_phoneCall, Serialize_phone_phoneCall },
		{ mtpc_upload_cdnFileReuploadNeeded, Serialize_upload_cdnFileReuploadNeeded },
		{ mtpc_upload_cdnFile, Serialize_upload_cdnFile },
		{ mtpc_cdnPublicKey, Serialize_cdnPublicKey },
		{ mtpc_cdnConfig, Serialize_cdnConfig },
		{ mtpc_langPackString, Serialize_langPackString },
		{ mtpc_langPackStringPluralized, Serialize_langPackStringPluralized },
		{ mtpc_langPackStringDeleted, Serialize_langPackStringDeleted },
		{ mtpc_langPackDifference, Serialize_langPackDifference },
		{ mtpc_langPackLanguage, Serialize_langPackLanguage },
		{ mtpc_channelAdminLogEventActionChangeTitle, Serialize_channelAdminLogEventActionChangeTitle },
		{ mtpc_channelAdminLogEventActionChangeAbout, Serialize_channelAdminLogEventActionChangeAbout },
		{ mtpc_channelAdminLogEventActionChangeUsername, Serialize_channelAdminLogEventActionChangeUsername },
		{ mtpc_channelAdminLogEventActionChangePhoto, Serialize_channelAdminLogEventActionChangePhoto },
		{ mtpc_channelAdminLogEventActionToggleInvites, Serialize_channelAdminLogEventActionToggleInvites },
		{ mtpc_channelAdminLogEventActionToggleSignatures, Serialize_channelAdminLogEventActionToggleSignatures },
		{ mtpc_channelAdminLogEventActionUpdatePinned, Serialize_channelAdminLogEventActionUpdatePinned },
		{ mtpc_channelAdminLogEventActionEditMessage, Serialize_channelAdminLogEventActionEditMessage },
		{ mtpc_channelAdminLogEventActionDeleteMessage, Serialize_channelAdminLogEventActionDeleteMessage },
		{ mtpc_channelAdminLogEventActionParticipantJoin, Serialize_channelAdminLogEventActionParticipantJoin },
		{ mtpc_channelAdminLogEventActionParticipantLeave, Serialize_channelAdminLogEventActionParticipantLeave },
		{ mtpc_channelAdminLogEventActionParticipantInvite, Serialize_channelAdminLogEventActionParticipantInvite },
		{ mtpc_channelAdminLogEventActionParticipantToggleBan, Serialize_channelAdminLogEventActionParticipantToggleBan },
		{ mtpc_channelAdminLogEventActionParticipantToggleAdmin, Serialize_channelAdminLogEventActionParticipantToggleAdmin },
		{ mtpc_channelAdminLogEventActionChangeStickerSet, Serialize_channelAdminLogEventActionChangeStickerSet },
		{ mtpc_channelAdminLogEventActionTogglePreHistoryHidden, Serialize_channelAdminLogEventActionTogglePreHistoryHidden },
		{ mtpc_channelAdminLogEventActionDefaultBannedRights, Serialize_channelAdminLogEventActionDefaultBannedRights },
		{ mtpc_channelAdminLogEventActionStopPoll, Serialize_channelAdminLogEventActionStopPoll },
		{ mtpc_channelAdminLogEventActionChangeLinkedChat, Serialize_channelAdminLogEventActionChangeLinkedChat },
		{ mtpc_channelAdminLogEventActionChangeLocation, Serialize_channelAdminLogEventActionChangeLocation },
		{ mtpc_channelAdminLogEventActionToggleSlowMode, Serialize_channelAdminLogEventActionToggleSlowMode },
		{ mtpc_channelAdminLogEventActionStartGroupCall, Serialize_channelAdminLogEventActionStartGroupCall },
		{ mtpc_channelAdminLogEventActionDiscardGroupCall, Serialize_channelAdminLogEventActionDiscardGroupCall },
		{ mtpc_channelAdminLogEventActionParticipantMute, Serialize_channelAdminLogEventActionParticipantMute },
		{ mtpc_channelAdminLogEventActionParticipantUnmute, Serialize_channelAdminLogEventActionParticipantUnmute },
		{ mtpc_channelAdminLogEventActionToggleGroupCallSetting, Serialize_channelAdminLogEventActionToggleGroupCallSetting },
		{ mtpc_channelAdminLogEventActionParticipantJoinByInvite, Serialize_channelAdminLogEventActionParticipantJoinByInvite },
		{ mtpc_channelAdminLogEventActionExportedInviteDelete, Serialize_channelAdminLogEventActionExportedInviteDelete },
		{ mtpc_channelAdminLogEventActionExportedInviteRevoke, Serialize_channelAdminLogEventActionExportedInviteRevoke },
		{ mtpc_channelAdminLogEventActionExportedInviteEdit, Serialize_channelAdminLogEventActionExportedInviteEdit },
		{ mtpc_channelAdminLogEventActionParticipantVolume, Serialize_channelAdminLogEventActionParticipantVolume },
		{ mtpc_channelAdminLogEventActionChangeHistoryTTL, Serialize_channelAdminLogEventActionChangeHistoryTTL },
		{ mtpc_channelAdminLogEvent, Serialize_channelAdminLogEvent },
		{ mtpc_channels_adminLogResults, Serialize_channels_adminLogResults },
		{ mtpc_channelAdminLogEventsFilter, Serialize_channelAdminLogEventsFilter },
		{ mtpc_popularContact, Serialize_popularContact },
		{ mtpc_messages_favedStickersNotModified, Serialize_messages_favedStickersNotModified },
		{ mtpc_messages_favedStickers, Serialize_messages_favedStickers },
		{ mtpc_recentMeUrlUnknown, Serialize_recentMeUrlUnknown },
		{ mtpc_recentMeUrlUser, Serialize_recentMeUrlUser },
		{ mtpc_recentMeUrlChat, Serialize_recentMeUrlChat },
		{ mtpc_recentMeUrlChatInvite, Serialize_recentMeUrlChatInvite },
		{ mtpc_recentMeUrlStickerSet, Serialize_recentMeUrlStickerSet },
		{ mtpc_help_recentMeUrls, Serialize_help_recentMeUrls },
		{ mtpc_inputSingleMedia, Serialize_inputSingleMedia },
		{ mtpc_webAuthorization, Serialize_webAuthorization },
		{ mtpc_account_webAuthorizations, Serialize_account_webAuthorizations },
		{ mtpc_inputMessageID, Serialize_inputMessageID },
		{ mtpc_inputMessageReplyTo, Serialize_inputMessageReplyTo },
		{ mtpc_inputMessagePinned, Serialize_inputMessagePinned },
		{ mtpc_inputMessageCallbackQuery, Serialize_inputMessageCallbackQuery },
		{ mtpc_inputDialogPeer, Serialize_inputDialogPeer },
		{ mtpc_inputDialogPeerFolder, Serialize_inputDialogPeerFolder },
		{ mtpc_dialogPeer, Serialize_dialogPeer },
		{ mtpc_dialogPeerFolder, Serialize_dialogPeerFolder },
		{ mtpc_messages_foundStickerSetsNotModified, Serialize_messages_foundStickerSetsNotModified },
		{ mtpc_messages_foundStickerSets, Serialize_messages_foundStickerSets },
		{ mtpc_fileHash, Serialize_fileHash },
		{ mtpc_inputClientProxy, Serialize_inputClientProxy },
		{ mtpc_help_termsOfServiceUpdateEmpty, Serialize_help_termsOfServiceUpdateEmpty },
		{ mtpc_help_termsOfServiceUpdate, Serialize_help_termsOfServiceUpdate },
		{ mtpc_inputSecureFileUploaded, Serialize_inputSecureFileUploaded },
		{ mtpc_inputSecureFile, Serialize_inputSecureFile },
		{ mtpc_secureFileEmpty, Serialize_secureFileEmpty },
		{ mtpc_secureFile, Serialize_secureFile },
		{ mtpc_secureData, Serialize_secureData },
		{ mtpc_securePlainPhone, Serialize_securePlainPhone },
		{ mtpc_securePlainEmail, Serialize_securePlainEmail },
		{ mtpc_secureValueTypePersonalDetails, Serialize_secureValueTypePersonalDetails },
		{ mtpc_secureValueTypePassport, Serialize_secureValueTypePassport },
		{ mtpc_secureValueTypeDriverLicense, Serialize_secureValueTypeDriverLicense },
		{ mtpc_secureValueTypeIdentityCard, Serialize_secureValueTypeIdentityCard },
		{ mtpc_secureValueTypeInternalPassport, Serialize_secureValueTypeInternalPassport },
		{ mtpc_secureValueTypeAddress, Serialize_secureValueTypeAddress },
		{ mtpc_secureValueTypeUtilityBill, Serialize_secureValueTypeUtilityBill },
		{ mtpc_secureValueTypeBankStatement, Serialize_secureValueTypeBankStatement },
		{ mtpc_secureValueTypeRentalAgreement, Serialize_secureValueTypeRentalAgreement },
		{ mtpc_secureValueTypePassportRegistration, Serialize_secureValueTypePassportRegistration },
		{ mtpc_secureValueTypeTemporaryRegistration, Serialize_secureValueTypeTemporaryRegistration },
		{ mtpc_secureValueTypePhone, Serialize_secureValueTypePhone },
		{ mtpc_secureValueTypeEmail, Serialize_secureValueTypeEmail },
		{ mtpc_secureValue, Serialize_secureValue },
		{ mtpc_inputSecureValue, Serialize_inputSecureValue },
		{ mtpc_secureValueHash, Serialize_secureValueHash },
		{ mtpc_secureValueErrorData, Serialize_secureValueErrorData },
		{ mtpc_secureValueErrorFrontSide, Serialize_secureValueErrorFrontSide },
		{ mtpc_secureValueErrorReverseSide, Serialize_secureValueErrorReverseSide },
		{ mtpc_secureValueErrorSelfie, Serialize_secureValueErrorSelfie },
		{ mtpc_secureValueErrorFile, Serialize_secureValueErrorFile },
		{ mtpc_secureValueErrorFiles, Serialize_secureValueErrorFiles },
		{ mtpc_secureValueError, Serialize_secureValueError },
		{ mtpc_secureValueErrorTranslationFile, Serialize_secureValueErrorTranslationFile },
		{ mtpc_secureValueErrorTranslationFiles, Serialize_secureValueErrorTranslationFiles },
		{ mtpc_secureCredentialsEncrypted, Serialize_secureCredentialsEncrypted },
		{ mtpc_account_authorizationForm, Serialize_account_authorizationForm },
		{ mtpc_account_sentEmailCode, Serialize_account_sentEmailCode },
		{ mtpc_help_deepLinkInfoEmpty, Serialize_help_deepLinkInfoEmpty },
		{ mtpc_help_deepLinkInfo, Serialize_help_deepLinkInfo },
		{ mtpc_savedPhoneContact, Serialize_savedPhoneContact },
		{ mtpc_account_takeout, Serialize_account_takeout },
		{ mtpc_passwordKdfAlgoUnknown, Serialize_passwordKdfAlgoUnknown },
		{ mtpc_passwordKdfAlgoModPow, Serialize_passwordKdfAlgoModPow },
		{ mtpc_securePasswordKdfAlgoUnknown, Serialize_securePasswordKdfAlgoUnknown },
		{ mtpc_securePasswordKdfAlgoPBKDF2HMACSHA512iter100000, Serialize_securePasswordKdfAlgoPBKDF2HMACSHA512iter100000 },
		{ mtpc_securePasswordKdfAlgoSHA512, Serialize_securePasswordKdfAlgoSHA512 },
		{ mtpc_secureSecretSettings, Serialize_secureSecretSettings },
		{ mtpc_inputCheckPasswordEmpty, Serialize_inputCheckPasswordEmpty },
		{ mtpc_inputCheckPasswordSRP, Serialize_inputCheckPasswordSRP },
		{ mtpc_secureRequiredType, Serialize_secureRequiredType },
		{ mtpc_secureRequiredTypeOneOf, Serialize_secureRequiredTypeOneOf },
		{ mtpc_help_passportConfigNotModified, Serialize_help_passportConfigNotModified },
		{ mtpc_help_passportConfig, Serialize_help_passportConfig },
		{ mtpc_inputAppEvent, Serialize_inputAppEvent },
		{ mtpc_jsonObjectValue, Serialize_jsonObjectValue },
		{ mtpc_jsonNull, Serialize_jsonNull },
		{ mtpc_jsonBool, Serialize_jsonBool },
		{ mtpc_jsonNumber, Serialize_jsonNumber },
		{ mtpc_jsonString, Serialize_jsonString },
		{ mtpc_jsonArray, Serialize_jsonArray },
		{ mtpc_jsonObject, Serialize_jsonObject },
		{ mtpc_pageTableCell, Serialize_pageTableCell },
		{ mtpc_pageTableRow, Serialize_pageTableRow },
		{ mtpc_pageCaption, Serialize_pageCaption },
		{ mtpc_pageListItemText, Serialize_pageListItemText },
		{ mtpc_pageListItemBlocks, Serialize_pageListItemBlocks },
		{ mtpc_pageListOrderedItemText, Serialize_pageListOrderedItemText },
		{ mtpc_pageListOrderedItemBlocks, Serialize_pageListOrderedItemBlocks },
		{ mtpc_pageRelatedArticle, Serialize_pageRelatedArticle },
		{ mtpc_page, Serialize_page },
		{ mtpc_help_supportName, Serialize_help_supportName },
		{ mtpc_help_userInfoEmpty, Serialize_help_userInfoEmpty },
		{ mtpc_help_userInfo, Serialize_help_userInfo },
		{ mtpc_pollAnswer, Serialize_pollAnswer },
		{ mtpc_poll, Serialize_poll },
		{ mtpc_pollAnswerVoters, Serialize_pollAnswerVoters },
		{ mtpc_pollResults, Serialize_pollResults },
		{ mtpc_chatOnlines, Serialize_chatOnlines },
		{ mtpc_statsURL, Serialize_statsURL },
		{ mtpc_chatAdminRights, Serialize_chatAdminRights },
		{ mtpc_chatBannedRights, Serialize_chatBannedRights },
		{ mtpc_inputWallPaper, Serialize_inputWallPaper },
		{ mtpc_inputWallPaperSlug, Serialize_inputWallPaperSlug },
		{ mtpc_inputWallPaperNoFile, Serialize_inputWallPaperNoFile },
		{ mtpc_account_wallPapersNotModified, Serialize_account_wallPapersNotModified },
		{ mtpc_account_wallPapers, Serialize_account_wallPapers },
		{ mtpc_codeSettings, Serialize_codeSettings },
		{ mtpc_wallPaperSettings, Serialize_wallPaperSettings },
		{ mtpc_autoDownloadSettings, Serialize_autoDownloadSettings },
		{ mtpc_account_autoDownloadSettings, Serialize_account_autoDownloadSettings },
		{ mtpc_emojiKeyword, Serialize_emojiKeyword },
		{ mtpc_emojiKeywordDeleted, Serialize_emojiKeywordDeleted },
		{ mtpc_emojiKeywordsDifference, Serialize_emojiKeywordsDifference },
		{ mtpc_emojiURL, Serialize_emojiURL },
		{ mtpc_emojiLanguage, Serialize_emojiLanguage },
		{ mtpc_folder, Serialize_folder },
		{ mtpc_inputFolderPeer, Serialize_inputFolderPeer },
		{ mtpc_folderPeer, Serialize_folderPeer },
		{ mtpc_messages_searchCounter, Serialize_messages_searchCounter },
		{ mtpc_urlAuthResultRequest, Serialize_urlAuthResultRequest },
		{ mtpc_urlAuthResultAccepted, Serialize_urlAuthResultAccepted },
		{ mtpc_urlAuthResultDefault, Serialize_urlAuthResultDefault },
		{ mtpc_channelLocationEmpty, Serialize_channelLocationEmpty },
		{ mtpc_channelLocation, Serialize_channelLocation },
		{ mtpc_peerLocated, Serialize_peerLocated },
		{ mtpc_peerSelfLocated, Serialize_peerSelfLocated },
		{ mtpc_restrictionReason, Serialize_restrictionReason },
		{ mtpc_inputTheme, Serialize_inputTheme },
		{ mtpc_inputThemeSlug, Serialize_inputThemeSlug },
		{ mtpc_theme, Serialize_theme },
		{ mtpc_account_themesNotModified, Serialize_account_themesNotModified },
		{ mtpc_account_themes, Serialize_account_themes },
		{ mtpc_auth_loginToken, Serialize_auth_loginToken },
		{ mtpc_auth_loginTokenMigrateTo, Serialize_auth_loginTokenMigrateTo },
		{ mtpc_auth_loginTokenSuccess, Serialize_auth_loginTokenSuccess },
		{ mtpc_account_contentSettings, Serialize_account_contentSettings },
		{ mtpc_messages_inactiveChats, Serialize_messages_inactiveChats },
		{ mtpc_baseThemeClassic, Serialize_baseThemeClassic },
		{ mtpc_baseThemeDay, Serialize_baseThemeDay },
		{ mtpc_baseThemeNight, Serialize_baseThemeNight },
		{ mtpc_baseThemeTinted, Serialize_baseThemeTinted },
		{ mtpc_baseThemeArctic, Serialize_baseThemeArctic },
		{ mtpc_inputThemeSettings, Serialize_inputThemeSettings },
		{ mtpc_themeSettings, Serialize_themeSettings },
		{ mtpc_webPageAttributeTheme, Serialize_webPageAttributeTheme },
		{ mtpc_messageUserVote, Serialize_messageUserVote },
		{ mtpc_messageUserVoteInputOption, Serialize_messageUserVoteInputOption },
		{ mtpc_messageUserVoteMultiple, Serialize_messageUserVoteMultiple },
		{ mtpc_messages_votesList, Serialize_messages_votesList },
		{ mtpc_bankCardOpenUrl, Serialize_bankCardOpenUrl },
		{ mtpc_payments_bankCardData, Serialize_payments_bankCardData },
		{ mtpc_dialogFilter, Serialize_dialogFilter },
		{ mtpc_dialogFilterSuggested, Serialize_dialogFilterSuggested },
		{ mtpc_statsDateRangeDays, Serialize_statsDateRangeDays },
		{ mtpc_statsAbsValueAndPrev, Serialize_statsAbsValueAndPrev },
		{ mtpc_statsPercentValue, Serialize_statsPercentValue },
		{ mtpc_statsGraphAsync, Serialize_statsGraphAsync },
		{ mtpc_statsGraphError, Serialize_statsGraphError },
		{ mtpc_statsGraph, Serialize_statsGraph },
		{ mtpc_messageInteractionCounters, Serialize_messageInteractionCounters },
		{ mtpc_stats_broadcastStats, Serialize_stats_broadcastStats },
		{ mtpc_help_promoDataEmpty, Serialize_help_promoDataEmpty },
		{ mtpc_help_promoData, Serialize_help_promoData },
		{ mtpc_videoSize, Serialize_videoSize },
		{ mtpc_statsGroupTopPoster, Serialize_statsGroupTopPoster },
		{ mtpc_statsGroupTopAdmin, Serialize_statsGroupTopAdmin },
		{ mtpc_statsGroupTopInviter, Serialize_statsGroupTopInviter },
		{ mtpc_stats_megagroupStats, Serialize_stats_megagroupStats },
		{ mtpc_globalPrivacySettings, Serialize_globalPrivacySettings },
		{ mtpc_help_countryCode, Serialize_help_countryCode },
		{ mtpc_help_country, Serialize_help_country },
		{ mtpc_help_countriesListNotModified, Serialize_help_countriesListNotModified },
		{ mtpc_help_countriesList, Serialize_help_countriesList },
		{ mtpc_messageViews, Serialize_messageViews },
		{ mtpc_messages_messageViews, Serialize_messages_messageViews },
		{ mtpc_messages_discussionMessage, Serialize_messages_discussionMessage },
		{ mtpc_messageReplyHeader, Serialize_messageReplyHeader },
		{ mtpc_messageReplies, Serialize_messageReplies },
		{ mtpc_peerBlocked, Serialize_peerBlocked },
		{ mtpc_stats_messageStats, Serialize_stats_messageStats },
		{ mtpc_groupCallDiscarded, Serialize_groupCallDiscarded },
		{ mtpc_groupCall, Serialize_groupCall },
		{ mtpc_inputGroupCall, Serialize_inputGroupCall },
		{ mtpc_groupCallParticipant, Serialize_groupCallParticipant },
		{ mtpc_phone_groupCall, Serialize_phone_groupCall },
		{ mtpc_phone_groupParticipants, Serialize_phone_groupParticipants },
		{ mtpc_inlineQueryPeerTypeSameBotPM, Serialize_inlineQueryPeerTypeSameBotPM },
		{ mtpc_inlineQueryPeerTypePM, Serialize_inlineQueryPeerTypePM },
		{ mtpc_inlineQueryPeerTypeChat, Serialize_inlineQueryPeerTypeChat },
		{ mtpc_inlineQueryPeerTypeMegagroup, Serialize_inlineQueryPeerTypeMegagroup },
		{ mtpc_inlineQueryPeerTypeBroadcast, Serialize_inlineQueryPeerTypeBroadcast },
		{ mtpc_messages_historyImport, Serialize_messages_historyImport },
		{ mtpc_messages_historyImportParsed, Serialize_messages_historyImportParsed },
		{ mtpc_messages_affectedFoundMessages, Serialize_messages_affectedFoundMessages },
		{ mtpc_chatInviteImporter, Serialize_chatInviteImporter },
		{ mtpc_messages_exportedChatInvites, Serialize_messages_exportedChatInvites },
		{ mtpc_messages_exportedChatInvite, Serialize_messages_exportedChatInvite },
		{ mtpc_messages_exportedChatInviteReplaced, Serialize_messages_exportedChatInviteReplaced },
		{ mtpc_messages_chatInviteImporters, Serialize_messages_chatInviteImporters },
		{ mtpc_chatAdminWithInvites, Serialize_chatAdminWithInvites },
		{ mtpc_messages_chatAdminsWithInvites, Serialize_messages_chatAdminsWithInvites },
		{ mtpc_messages_checkedHistoryImportPeer, Serialize_messages_checkedHistoryImportPeer },
		{ mtpc_phone_joinAsPeers, Serialize_phone_joinAsPeers },
		{ mtpc_phone_exportedGroupCallInvite, Serialize_phone_exportedGroupCallInvite },
		{ mtpc_groupCallParticipantVideoSourceGroup, Serialize_groupCallParticipantVideoSourceGroup },
		{ mtpc_groupCallParticipantVideo, Serialize_groupCallParticipantVideo },
		{ mtpc_stickers_suggestedShortName, Serialize_stickers_suggestedShortName },
		{ mtpc_botCommandScopeDefault, Serialize_botCommandScopeDefault },
		{ mtpc_botCommandScopeUsers, Serialize_botCommandScopeUsers },
		{ mtpc_botCommandScopeChats, Serialize_botCommandScopeChats },
		{ mtpc_botCommandScopeChatAdmins, Serialize_botCommandScopeChatAdmins },
		{ mtpc_botCommandScopePeer, Serialize_botCommandScopePeer },
		{ mtpc_botCommandScopePeerAdmins, Serialize_botCommandScopePeerAdmins },
		{ mtpc_botCommandScopePeerUser, Serialize_botCommandScopePeerUser },
		{ mtpc_account_resetPasswordFailedWait, Serialize_account_resetPasswordFailedWait },
		{ mtpc_account_resetPasswordRequestedWait, Serialize_account_resetPasswordRequestedWait },
		{ mtpc_account_resetPasswordOk, Serialize_account_resetPasswordOk },
		{ mtpc_chatTheme, Serialize_chatTheme },
		{ mtpc_account_chatThemesNotModified, Serialize_account_chatThemesNotModified },
		{ mtpc_account_chatThemes, Serialize_account_chatThemes },
		{ mtpc_sponsoredMessage, Serialize_sponsoredMessage },
		{ mtpc_messages_sponsoredMessages, Serialize_messages_sponsoredMessages },

		{ mtpc_req_pq, Serialize_req_pq },
		{ mtpc_req_pq_multi, Serialize_req_pq_multi },
		{ mtpc_req_DH_params, Serialize_req_DH_params },
		{ mtpc_set_client_DH_params, Serialize_set_client_DH_params },
		{ mtpc_destroy_auth_key, Serialize_destroy_auth_key },
		{ mtpc_rpc_drop_answer, Serialize_rpc_drop_answer },
		{ mtpc_get_future_salts, Serialize_get_future_salts },
		{ mtpc_ping, Serialize_ping },
		{ mtpc_ping_delay_disconnect, Serialize_ping_delay_disconnect },
		{ mtpc_destroy_session, Serialize_destroy_session },
		{ mtpc_invokeAfterMsg, Serialize_invokeAfterMsg },
		{ mtpc_invokeAfterMsgs, Serialize_invokeAfterMsgs },
		{ mtpc_initConnection, Serialize_initConnection },
		{ mtpc_invokeWithLayer, Serialize_invokeWithLayer },
		{ mtpc_invokeWithoutUpdates, Serialize_invokeWithoutUpdates },
		{ mtpc_invokeWithMessagesRange, Serialize_invokeWithMessagesRange },
		{ mtpc_invokeWithTakeout, Serialize_invokeWithTakeout },
		{ mtpc_auth_sendCode, Serialize_auth_sendCode },
		{ mtpc_auth_resendCode, Serialize_auth_resendCode },
		{ mtpc_account_sendChangePhoneCode, Serialize_account_sendChangePhoneCode },
		{ mtpc_account_sendConfirmPhoneCode, Serialize_account_sendConfirmPhoneCode },
		{ mtpc_account_sendVerifyPhoneCode, Serialize_account_sendVerifyPhoneCode },
		{ mtpc_auth_signUp, Serialize_auth_signUp },
		{ mtpc_auth_signIn, Serialize_auth_signIn },
		{ mtpc_auth_importAuthorization, Serialize_auth_importAuthorization },
		{ mtpc_auth_importBotAuthorization, Serialize_auth_importBotAuthorization },
		{ mtpc_auth_checkPassword, Serialize_auth_checkPassword },
		{ mtpc_auth_recoverPassword, Serialize_auth_recoverPassword },
		{ mtpc_auth_logOut, Serialize_auth_logOut },
		{ mtpc_auth_resetAuthorizations, Serialize_auth_resetAuthorizations },
		{ mtpc_auth_bindTempAuthKey, Serialize_auth_bindTempAuthKey },
		{ mtpc_auth_cancelCode, Serialize_auth_cancelCode },
		{ mtpc_auth_dropTempAuthKeys, Serialize_auth_dropTempAuthKeys },
		{ mtpc_auth_checkRecoveryPassword, Serialize_auth_checkRecoveryPassword },
		{ mtpc_account_registerDevice, Serialize_account_registerDevice },
		{ mtpc_account_unregisterDevice, Serialize_account_unregisterDevice },
		{ mtpc_account_updateNotifySettings, Serialize_account_updateNotifySettings },
		{ mtpc_account_resetNotifySettings, Serialize_account_resetNotifySettings },
		{ mtpc_account_updateStatus, Serialize_account_updateStatus },
		{ mtpc_account_reportPeer, Serialize_account_reportPeer },
		{ mtpc_account_checkUsername, Serialize_account_checkUsername },
		{ mtpc_account_deleteAccount, Serialize_account_deleteAccount },
		{ mtpc_account_setAccountTTL, Serialize_account_setAccountTTL },
		{ mtpc_account_updateDeviceLocked, Serialize_account_updateDeviceLocked },
		{ mtpc_account_resetAuthorization, Serialize_account_resetAuthorization },
		{ mtpc_account_updatePasswordSettings, Serialize_account_updatePasswordSettings },
		{ mtpc_account_confirmPhone, Serialize_account_confirmPhone },
		{ mtpc_account_resetWebAuthorization, Serialize_account_resetWebAuthorization },
		{ mtpc_account_resetWebAuthorizations, Serialize_account_resetWebAuthorizations },
		{ mtpc_account_deleteSecureValue, Serialize_account_deleteSecureValue },
		{ mtpc_account_acceptAuthorization, Serialize_account_acceptAuthorization },
		{ mtpc_account_verifyPhone, Serialize_account_verifyPhone },
		{ mtpc_account_verifyEmail, Serialize_account_verifyEmail },
		{ mtpc_account_finishTakeoutSession, Serialize_account_finishTakeoutSession },
		{ mtpc_account_confirmPasswordEmail, Serialize_account_confirmPasswordEmail },
		{ mtpc_account_resendPasswordEmail, Serialize_account_resendPasswordEmail },
		{ mtpc_account_cancelPasswordEmail, Serialize_account_cancelPasswordEmail },
		{ mtpc_account_getContactSignUpNotification, Serialize_account_getContactSignUpNotification },
		{ mtpc_account_setContactSignUpNotification, Serialize_account_setContactSignUpNotification },
		{ mtpc_account_saveWallPaper, Serialize_account_saveWallPaper },
		{ mtpc_account_installWallPaper, Serialize_account_installWallPaper },
		{ mtpc_account_resetWallPapers, Serialize_account_resetWallPapers },
		{ mtpc_account_saveAutoDownloadSettings, Serialize_account_saveAutoDownloadSettings },
		{ mtpc_account_saveTheme, Serialize_account_saveTheme },
		{ mtpc_account_installTheme, Serialize_account_installTheme },
		{ mtpc_account_setContentSettings, Serialize_account_setContentSettings },
		{ mtpc_account_reportProfilePhoto, Serialize_account_reportProfilePhoto },
		{ mtpc_account_declinePasswordReset, Serialize_account_declinePasswordReset },
		{ mtpc_users_setSecureValueErrors, Serialize_users_setSecureValueErrors },
		{ mtpc_contacts_deleteByPhones, Serialize_contacts_deleteByPhones },
		{ mtpc_contacts_block, Serialize_contacts_block },
		{ mtpc_contacts_unblock, Serialize_contacts_unblock },
		{ mtpc_contacts_resetTopPeerRating, Serialize_contacts_resetTopPeerRating },
		{ mtpc_contacts_resetSaved, Serialize_contacts_resetSaved },
		{ mtpc_contacts_toggleTopPeers, Serialize_contacts_toggleTopPeers },
		{ mtpc_messages_setTyping, Serialize_messages_setTyping },
		{ mtpc_messages_reportSpam, Serialize_messages_reportSpam },
		{ mtpc_messages_report, Serialize_messages_report },
		{ mtpc_messages_discardEncryption, Serialize_messages_discardEncryption },
		{ mtpc_messages_setEncryptedTyping, Serialize_messages_setEncryptedTyping },
		{ mtpc_messages_readEncryptedHistory, Serialize_messages_readEncryptedHistory },
		{ mtpc_messages_reportEncryptedSpam, Serialize_messages_reportEncryptedSpam },
		{ mtpc_messages_uninstallStickerSet, Serialize_messages_uninstallStickerSet },
		{ mtpc_messages_editChatAdmin, Serialize_messages_editChatAdmin },
		{ mtpc_messages_reorderStickerSets, Serialize_messages_reorderStickerSets },
		{ mtpc_messages_saveGif, Serialize_messages_saveGif },
		{ mtpc_messages_setInlineBotResults, Serialize_messages_setInlineBotResults },
		{ mtpc_messages_editInlineBotMessage, Serialize_messages_editInlineBotMessage },
		{ mtpc_messages_setBotCallbackAnswer, Serialize_messages_setBotCallbackAnswer },
		{ mtpc_messages_saveDraft, Serialize_messages_saveDraft },
		{ mtpc_messages_readFeaturedStickers, Serialize_messages_readFeaturedStickers },
		{ mtpc_messages_saveRecentSticker, Serialize_messages_saveRecentSticker },
		{ mtpc_messages_clearRecentStickers, Serialize_messages_clearRecentStickers },
		{ mtpc_messages_setInlineGameScore, Serialize_messages_setInlineGameScore },
		{ mtpc_messages_toggleDialogPin, Serialize_messages_toggleDialogPin },
		{ mtpc_messages_reorderPinnedDialogs, Serialize_messages_reorderPinnedDialogs },
		{ mtpc_messages_setBotShippingResults, Serialize_messages_setBotShippingResults },
		{ mtpc_messages_setBotPrecheckoutResults, Serialize_messages_setBotPrecheckoutResults },
		{ mtpc_messages_faveSticker, Serialize_messages_faveSticker },
		{ mtpc_messages_markDialogUnread, Serialize_messages_markDialogUnread },
		{ mtpc_messages_clearAllDrafts, Serialize_messages_clearAllDrafts },
		{ mtpc_messages_editChatAbout, Serialize_messages_editChatAbout },
		{ mtpc_messages_hidePeerSettingsBar, Serialize_messages_hidePeerSettingsBar },
		{ mtpc_messages_toggleStickerSets, Serialize_messages_toggleStickerSets },
		{ mtpc_messages_updateDialogFilter, Serialize_messages_updateDialogFilter },
		{ mtpc_messages_updateDialogFiltersOrder, Serialize_messages_updateDialogFiltersOrder },
		{ mtpc_messages_readDiscussion, Serialize_messages_readDiscussion },
		{ mtpc_messages_deleteChat, Serialize_messages_deleteChat },
		{ mtpc_messages_startHistoryImport, Serialize_messages_startHistoryImport },
		{ mtpc_messages_deleteRevokedExportedChatInvites, Serialize_messages_deleteRevokedExportedChatInvites },
		{ mtpc_messages_deleteExportedChatInvite, Serialize_messages_deleteExportedChatInvite },
		{ mtpc_upload_saveFilePart, Serialize_upload_saveFilePart },
		{ mtpc_upload_saveBigFilePart, Serialize_upload_saveBigFilePart },
		{ mtpc_help_setBotUpdatesStatus, Serialize_help_setBotUpdatesStatus },
		{ mtpc_help_acceptTermsOfService, Serialize_help_acceptTermsOfService },
		{ mtpc_help_saveAppLog, Serialize_help_saveAppLog },
		{ mtpc_help_hidePromoData, Serialize_help_hidePromoData },
		{ mtpc_help_dismissSuggestion, Serialize_help_dismissSuggestion },
		{ mtpc_channels_readHistory, Serialize_channels_readHistory },
		{ mtpc_channels_reportSpam, Serialize_channels_reportSpam },
		{ mtpc_channels_checkUsername, Serialize_channels_checkUsername },
		{ mtpc_channels_updateUsername, Serialize_channels_updateUsername },
		{ mtpc_channels_setStickers, Serialize_channels_setStickers },
		{ mtpc_channels_readMessageContents, Serialize_channels_readMessageContents },
		{ mtpc_channels_deleteHistory, Serialize_channels_deleteHistory },
		{ mtpc_channels_setDiscussionGroup, Serialize_channels_setDiscussionGroup },
		{ mtpc_channels_editLocation, Serialize_channels_editLocation },
		{ mtpc_channels_viewSponsoredMessage, Serialize_channels_viewSponsoredMessage },
		{ mtpc_bots_answerWebhookJSONQuery, Serialize_bots_answerWebhookJSONQuery },
		{ mtpc_bots_setBotCommands, Serialize_bots_setBotCommands },
		{ mtpc_bots_resetBotCommands, Serialize_bots_resetBotCommands },
		{ mtpc_payments_clearSavedInfo, Serialize_payments_clearSavedInfo },
		{ mtpc_stickers_checkShortName, Serialize_stickers_checkShortName },
		{ mtpc_phone_receivedCall, Serialize_phone_receivedCall },
		{ mtpc_phone_saveCallDebug, Serialize_phone_saveCallDebug },
		{ mtpc_phone_sendSignalingData, Serialize_phone_sendSignalingData },
		{ mtpc_phone_saveDefaultGroupCallJoinAs, Serialize_phone_saveDefaultGroupCallJoinAs },
		{ mtpc_auth_exportAuthorization, Serialize_auth_exportAuthorization },
		{ mtpc_auth_requestPasswordRecovery, Serialize_auth_requestPasswordRecovery },
		{ mtpc_auth_exportLoginToken, Serialize_auth_exportLoginToken },
		{ mtpc_auth_importLoginToken, Serialize_auth_importLoginToken },
		{ mtpc_auth_acceptLoginToken, Serialize_auth_acceptLoginToken },
		{ mtpc_account_getNotifySettings, Serialize_account_getNotifySettings },
		{ mtpc_account_updateProfile, Serialize_account_updateProfile },
		{ mtpc_account_updateUsername, Serialize_account_updateUsername },
		{ mtpc_account_changePhone, Serialize_account_changePhone },
		{ mtpc_account_getWallPapers, Serialize_account_getWallPapers },
		{ mtpc_account_getPrivacy, Serialize_account_getPrivacy },
		{ mtpc_account_setPrivacy, Serialize_account_setPrivacy },
		{ mtpc_account_getAccountTTL, Serialize_account_getAccountTTL },
		{ mtpc_account_getAuthorizations, Serialize_account_getAuthorizations },
		{ mtpc_account_getPassword, Serialize_account_getPassword },
		{ mtpc_account_getPasswordSettings, Serialize_account_getPasswordSettings },
		{ mtpc_account_getTmpPassword, Serialize_account_getTmpPassword },
		{ mtpc_account_getWebAuthorizations, Serialize_account_getWebAuthorizations },
		{ mtpc_account_getAllSecureValues, Serialize_account_getAllSecureValues },
		{ mtpc_account_getSecureValue, Serialize_account_getSecureValue },
		{ mtpc_account_saveSecureValue, Serialize_account_saveSecureValue },
		{ mtpc_account_getAuthorizationForm, Serialize_account_getAuthorizationForm },
		{ mtpc_account_sendVerifyEmailCode, Serialize_account_sendVerifyEmailCode },
		{ mtpc_account_initTakeoutSession, Serialize_account_initTakeoutSession },
		{ mtpc_account_getNotifyExceptions, Serialize_account_getNotifyExceptions },
		{ mtpc_contacts_deleteContacts, Serialize_contacts_deleteContacts },
		{ mtpc_contacts_addContact, Serialize_contacts_addContact },
		{ mtpc_contacts_acceptContact, Serialize_contacts_acceptContact },
		{ mtpc_contacts_getLocated, Serialize_contacts_getLocated },
		{ mtpc_contacts_blockFromReplies, Serialize_contacts_blockFromReplies },
		{ mtpc_messages_sendMessage, Serialize_messages_sendMessage },
		{ mtpc_messages_sendMedia, Serialize_messages_sendMedia },
		{ mtpc_messages_forwardMessages, Serialize_messages_forwardMessages },
		{ mtpc_messages_editChatTitle, Serialize_messages_editChatTitle },
		{ mtpc_messages_editChatPhoto, Serialize_messages_editChatPhoto },
		{ mtpc_messages_addChatUser, Serialize_messages_addChatUser },
		{ mtpc_messages_deleteChatUser, Serialize_messages_deleteChatUser },
		{ mtpc_messages_createChat, Serialize_messages_createChat },
		{ mtpc_messages_importChatInvite, Serialize_messages_importChatInvite },
		{ mtpc_messages_startBot, Serialize_messages_startBot },
		{ mtpc_messages_migrateChat, Serialize_messages_migrateChat },
		{ mtpc_messages_sendInlineBotResult, Serialize_messages_sendInlineBotResult },
		{ mtpc_messages_editMessage, Serialize_messages_editMessage },
		{ mtpc_messages_getAllDrafts, Serialize_messages_getAllDrafts },
		{ mtpc_messages_setGameScore, Serialize_messages_setGameScore },
		{ mtpc_messages_sendScreenshotNotification, Serialize_messages_sendScreenshotNotification },
		{ mtpc_messages_sendMultiMedia, Serialize_messages_sendMultiMedia },
		{ mtpc_messages_updatePinnedMessage, Serialize_messages_updatePinnedMessage },
		{ mtpc_messages_sendVote, Serialize_messages_sendVote },
		{ mtpc_messages_getPollResults, Serialize_messages_getPollResults },
		{ mtpc_messages_editChatDefaultBannedRights, Serialize_messages_editChatDefaultBannedRights },
		{ mtpc_messages_sendScheduledMessages, Serialize_messages_sendScheduledMessages },
		{ mtpc_messages_deleteScheduledMessages, Serialize_messages_deleteScheduledMessages },
		{ mtpc_messages_setHistoryTTL, Serialize_messages_setHistoryTTL },
		{ mtpc_messages_setChatTheme, Serialize_messages_setChatTheme },
		{ mtpc_help_getAppChangelog, Serialize_help_getAppChangelog },
		{ mtpc_channels_createChannel, Serialize_channels_createChannel },
		{ mtpc_channels_editAdmin, Serialize_channels_editAdmin },
		{ mtpc_channels_editTitle, Serialize_channels_editTitle },
		{ mtpc_channels_editPhoto, Serialize_channels_editPhoto },
		{ mtpc_channels_joinChannel, Serialize_channels_joinChannel },
		{ mtpc_channels_leaveChannel, Serialize_channels_leaveChannel },
		{ mtpc_channels_inviteToChannel, Serialize_channels_inviteToChannel },
		{ mtpc_channels_deleteChannel, Serialize_channels_deleteChannel },
		{ mtpc_channels_toggleSignatures, Serialize_channels_toggleSignatures },
		{ mtpc_channels_editBanned, Serialize_channels_editBanned },
		{ mtpc_channels_togglePreHistoryHidden, Serialize_channels_togglePreHistoryHidden },
		{ mtpc_channels_editCreator, Serialize_channels_editCreator },
		{ mtpc_channels_toggleSlowMode, Serialize_channels_toggleSlowMode },
		{ mtpc_channels_convertToGigagroup, Serialize_channels_convertToGigagroup },
		{ mtpc_phone_discardCall, Serialize_phone_discardCall },
		{ mtpc_phone_setCallRating, Serialize_phone_setCallRating },
		{ mtpc_phone_createGroupCall, Serialize_phone_createGroupCall },
		{ mtpc_phone_joinGroupCall, Serialize_phone_joinGroupCall },
		{ mtpc_phone_leaveGroupCall, Serialize_phone_leaveGroupCall },
		{ mtpc_phone_inviteToGroupCall, Serialize_phone_inviteToGroupCall },
		{ mtpc_phone_discardGroupCall, Serialize_phone_discardGroupCall },
		{ mtpc_phone_toggleGroupCallSettings, Serialize_phone_toggleGroupCallSettings },
		{ mtpc_phone_toggleGroupCallRecord, Serialize_phone_toggleGroupCallRecord },
		{ mtpc_phone_editGroupCallParticipant, Serialize_phone_editGroupCallParticipant },
		{ mtpc_phone_editGroupCallTitle, Serialize_phone_editGroupCallTitle },
		{ mtpc_phone_toggleGroupCallStartSubscription, Serialize_phone_toggleGroupCallStartSubscription },
		{ mtpc_phone_startScheduledGroupCall, Serialize_phone_startScheduledGroupCall },
		{ mtpc_phone_joinGroupCallPresentation, Serialize_phone_joinGroupCallPresentation },
		{ mtpc_phone_leaveGroupCallPresentation, Serialize_phone_leaveGroupCallPresentation },
		{ mtpc_folders_editPeerFolders, Serialize_folders_editPeerFolders },
		{ mtpc_folders_deleteFolder, Serialize_folders_deleteFolder },
		{ mtpc_account_getWallPaper, Serialize_account_getWallPaper },
		{ mtpc_account_uploadWallPaper, Serialize_account_uploadWallPaper },
		{ mtpc_account_getAutoDownloadSettings, Serialize_account_getAutoDownloadSettings },
		{ mtpc_account_uploadTheme, Serialize_account_uploadTheme },
		{ mtpc_messages_getDocumentByHash, Serialize_messages_getDocumentByHash },
		{ mtpc_account_createTheme, Serialize_account_createTheme },
		{ mtpc_account_updateTheme, Serialize_account_updateTheme },
		{ mtpc_account_getTheme, Serialize_account_getTheme },
		{ mtpc_account_getThemes, Serialize_account_getThemes },
		{ mtpc_account_getContentSettings, Serialize_account_getContentSettings },
		{ mtpc_account_getMultiWallPapers, Serialize_account_getMultiWallPapers },
		{ mtpc_account_getGlobalPrivacySettings, Serialize_account_getGlobalPrivacySettings },
		{ mtpc_account_setGlobalPrivacySettings, Serialize_account_setGlobalPrivacySettings },
		{ mtpc_account_resetPassword, Serialize_account_resetPassword },
		{ mtpc_account_getChatThemes, Serialize_account_getChatThemes },
		{ mtpc_users_getUsers, Serialize_users_getUsers },
		{ mtpc_users_getFullUser, Serialize_users_getFullUser },
		{ mtpc_contacts_getContactIDs, Serialize_contacts_getContactIDs },
		{ mtpc_phone_checkGroupCall, Serialize_phone_checkGroupCall },
		{ mtpc_contacts_getStatuses, Serialize_contacts_getStatuses },
		{ mtpc_contacts_getContacts, Serialize_contacts_getContacts },
		{ mtpc_contacts_importContacts, Serialize_contacts_importContacts },
		{ mtpc_contacts_getBlocked, Serialize_contacts_getBlocked },
		{ mtpc_contacts_search, Serialize_contacts_search },
		{ mtpc_contacts_resolveUsername, Serialize_contacts_resolveUsername },
		{ mtpc_contacts_getTopPeers, Serialize_contacts_getTopPeers },
		{ mtpc_contacts_getSaved, Serialize_contacts_getSaved },
		{ mtpc_messages_getMessages, Serialize_messages_getMessages },
		{ mtpc_messages_getHistory, Serialize_messages_getHistory },
		{ mtpc_messages_search, Serialize_messages_search },
		{ mtpc_messages_searchGlobal, Serialize_messages_searchGlobal },
		{ mtpc_messages_getUnreadMentions, Serialize_messages_getUnreadMentions },
		{ mtpc_messages_getRecentLocations, Serialize_messages_getRecentLocations },
		{ mtpc_messages_getScheduledHistory, Serialize_messages_getScheduledHistory },
		{ mtpc_messages_getScheduledMessages, Serialize_messages_getScheduledMessages },
		{ mtpc_messages_getReplies, Serialize_messages_getReplies },
		{ mtpc_channels_getMessages, Serialize_channels_getMessages },
		{ mtpc_stats_getMessagePublicForwards, Serialize_stats_getMessagePublicForwards },
		{ mtpc_messages_getDialogs, Serialize_messages_getDialogs },
		{ mtpc_messages_readHistory, Serialize_messages_readHistory },
		{ mtpc_messages_deleteMessages, Serialize_messages_deleteMessages },
		{ mtpc_messages_readMessageContents, Serialize_messages_readMessageContents },
		{ mtpc_channels_deleteMessages, Serialize_channels_deleteMessages },
		{ mtpc_messages_deleteHistory, Serialize_messages_deleteHistory },
		{ mtpc_messages_readMentions, Serialize_messages_readMentions },
		{ mtpc_messages_unpinAllMessages, Serialize_messages_unpinAllMessages },
		{ mtpc_channels_deleteUserHistory, Serialize_channels_deleteUserHistory },
		{ mtpc_messages_receivedMessages, Serialize_messages_receivedMessages },
		{ mtpc_messages_getPeerSettings, Serialize_messages_getPeerSettings },
		{ mtpc_messages_getChats, Serialize_messages_getChats },
		{ mtpc_messages_getCommonChats, Serialize_messages_getCommonChats },
		{ mtpc_messages_getAllChats, Serialize_messages_getAllChats },
		{ mtpc_channels_getChannels, Serialize_channels_getChannels },
		{ mtpc_channels_getAdminedPublicChannels, Serialize_channels_getAdminedPublicChannels },
		{ mtpc_channels_getLeftChannels, Serialize_channels_getLeftChannels },
		{ mtpc_channels_getGroupsForDiscussion, Serialize_channels_getGroupsForDiscussion },
		{ mtpc_messages_getFullChat, Serialize_messages_getFullChat },
		{ mtpc_channels_getFullChannel, Serialize_channels_getFullChannel },
		{ mtpc_messages_getDhConfig, Serialize_messages_getDhConfig },
		{ mtpc_messages_requestEncryption, Serialize_messages_requestEncryption },
		{ mtpc_messages_acceptEncryption, Serialize_messages_acceptEncryption },
		{ mtpc_messages_sendEncrypted, Serialize_messages_sendEncrypted },
		{ mtpc_messages_sendEncryptedFile, Serialize_messages_sendEncryptedFile },
		{ mtpc_messages_sendEncryptedService, Serialize_messages_sendEncryptedService },
		{ mtpc_messages_receivedQueue, Serialize_messages_receivedQueue },
		{ mtpc_photos_deletePhotos, Serialize_photos_deletePhotos },
		{ mtpc_messages_getStickers, Serialize_messages_getStickers },
		{ mtpc_messages_getAllStickers, Serialize_messages_getAllStickers },
		{ mtpc_messages_getMaskStickers, Serialize_messages_getMaskStickers },
		{ mtpc_messages_getWebPagePreview, Serialize_messages_getWebPagePreview },
		{ mtpc_messages_uploadMedia, Serialize_messages_uploadMedia },
		{ mtpc_messages_uploadImportedMedia, Serialize_messages_uploadImportedMedia },
		{ mtpc_messages_exportChatInvite, Serialize_messages_exportChatInvite },
		{ mtpc_messages_checkChatInvite, Serialize_messages_checkChatInvite },
		{ mtpc_messages_getStickerSet, Serialize_messages_getStickerSet },
		{ mtpc_stickers_createStickerSet, Serialize_stickers_createStickerSet },
		{ mtpc_stickers_removeStickerFromSet, Serialize_stickers_removeStickerFromSet },
		{ mtpc_stickers_changeStickerPosition, Serialize_stickers_changeStickerPosition },
		{ mtpc_stickers_addStickerToSet, Serialize_stickers_addStickerToSet },
		{ mtpc_stickers_setStickerSetThumb, Serialize_stickers_setStickerSetThumb },
		{ mtpc_messages_installStickerSet, Serialize_messages_installStickerSet },
		{ mtpc_messages_getMessagesViews, Serialize_messages_getMessagesViews },
		{ mtpc_messages_getSavedGifs, Serialize_messages_getSavedGifs },
		{ mtpc_messages_getInlineBotResults, Serialize_messages_getInlineBotResults },
		{ mtpc_messages_getMessageEditData, Serialize_messages_getMessageEditData },
		{ mtpc_messages_getBotCallbackAnswer, Serialize_messages_getBotCallbackAnswer },
		{ mtpc_messages_getPeerDialogs, Serialize_messages_getPeerDialogs },
		{ mtpc_messages_getPinnedDialogs, Serialize_messages_getPinnedDialogs },
		{ mtpc_messages_getFeaturedStickers, Serialize_messages_getFeaturedStickers },
		{ mtpc_messages_getOldFeaturedStickers, Serialize_messages_getOldFeaturedStickers },
		{ mtpc_messages_getRecentStickers, Serialize_messages_getRecentStickers },
		{ mtpc_messages_getArchivedStickers, Serialize_messages_getArchivedStickers },
		{ mtpc_messages_getAttachedStickers, Serialize_messages_getAttachedStickers },
		{ mtpc_messages_getGameHighScores, Serialize_messages_getGameHighScores },
		{ mtpc_messages_getInlineGameHighScores, Serialize_messages_getInlineGameHighScores },
		{ mtpc_messages_getWebPage, Serialize_messages_getWebPage },
		{ mtpc_messages_getFavedStickers, Serialize_messages_getFavedStickers },
		{ mtpc_messages_uploadEncryptedFile, Serialize_messages_uploadEncryptedFile },
		{ mtpc_messages_searchStickerSets, Serialize_messages_searchStickerSets },
		{ mtpc_messages_getSplitRanges, Serialize_messages_getSplitRanges },
		{ mtpc_messages_getDialogUnreadMarks, Serialize_messages_getDialogUnreadMarks },
		{ mtpc_messages_getOnlines, Serialize_messages_getOnlines },
		{ mtpc_messages_getStatsURL, Serialize_messages_getStatsURL },
		{ mtpc_messages_getEmojiKeywords, Serialize_messages_getEmojiKeywords },
		{ mtpc_messages_getEmojiKeywordsDifference, Serialize_messages_getEmojiKeywordsDifference },
		{ mtpc_messages_getEmojiKeywordsLanguages, Serialize_messages_getEmojiKeywordsLanguages },
		{ mtpc_messages_getEmojiURL, Serialize_messages_getEmojiURL },
		{ mtpc_messages_getSearchCounters, Serialize_messages_getSearchCounters },
		{ mtpc_messages_requestUrlAuth, Serialize_messages_requestUrlAuth },
		{ mtpc_messages_acceptUrlAuth, Serialize_messages_acceptUrlAuth },
		{ mtpc_messages_getPollVotes, Serialize_messages_getPollVotes },
		{ mtpc_messages_getDialogFilters, Serialize_messages_getDialogFilters },
		{ mtpc_messages_getSuggestedDialogFilters, Serialize_messages_getSuggestedDialogFilters },
		{ mtpc_messages_getDiscussionMessage, Serialize_messages_getDiscussionMessage },
		{ mtpc_messages_deletePhoneCallHistory, Serialize_messages_deletePhoneCallHistory },
		{ mtpc_messages_checkHistoryImport, Serialize_messages_checkHistoryImport },
		{ mtpc_messages_initHistoryImport, Serialize_messages_initHistoryImport },
		{ mtpc_messages_getExportedChatInvites, Serialize_messages_getExportedChatInvites },
		{ mtpc_messages_getExportedChatInvite, Serialize_messages_getExportedChatInvite },
		{ mtpc_messages_editExportedChatInvite, Serialize_messages_editExportedChatInvite },
		{ mtpc_messages_getAdminsWithInvites, Serialize_messages_getAdminsWithInvites },
		{ mtpc_messages_getChatInviteImporters, Serialize_messages_getChatInviteImporters },
		{ mtpc_messages_checkHistoryImportPeer, Serialize_messages_checkHistoryImportPeer },
		{ mtpc_updates_getState, Serialize_updates_getState },
		{ mtpc_updates_getDifference, Serialize_updates_getDifference },
		{ mtpc_updates_getChannelDifference, Serialize_updates_getChannelDifference },
		{ mtpc_photos_updateProfilePhoto, Serialize_photos_updateProfilePhoto },
		{ mtpc_photos_uploadProfilePhoto, Serialize_photos_uploadProfilePhoto },
		{ mtpc_photos_getUserPhotos, Serialize_photos_getUserPhotos },
		{ mtpc_upload_getFile, Serialize_upload_getFile },
		{ mtpc_upload_getWebFile, Serialize_upload_getWebFile },
		{ mtpc_upload_getCdnFile, Serialize_upload_getCdnFile },
		{ mtpc_upload_reuploadCdnFile, Serialize_upload_reuploadCdnFile },
		{ mtpc_upload_getCdnFileHashes, Serialize_upload_getCdnFileHashes },
		{ mtpc_upload_getFileHashes, Serialize_upload_getFileHashes },
		{ mtpc_help_getConfig, Serialize_help_getConfig },
		{ mtpc_help_getNearestDc, Serialize_help_getNearestDc },
		{ mtpc_help_getAppUpdate, Serialize_help_getAppUpdate },
		{ mtpc_help_getInviteText, Serialize_help_getInviteText },
		{ mtpc_help_getSupport, Serialize_help_getSupport },
		{ mtpc_help_getCdnConfig, Serialize_help_getCdnConfig },
		{ mtpc_help_getRecentMeUrls, Serialize_help_getRecentMeUrls },
		{ mtpc_help_getTermsOfServiceUpdate, Serialize_help_getTermsOfServiceUpdate },
		{ mtpc_help_getDeepLinkInfo, Serialize_help_getDeepLinkInfo },
		{ mtpc_help_getAppConfig, Serialize_help_getAppConfig },
		{ mtpc_help_getPassportConfig, Serialize_help_getPassportConfig },
		{ mtpc_help_getSupportName, Serialize_help_getSupportName },
		{ mtpc_help_getUserInfo, Serialize_help_getUserInfo },
		{ mtpc_help_editUserInfo, Serialize_help_editUserInfo },
		{ mtpc_help_getPromoData, Serialize_help_getPromoData },
		{ mtpc_help_getCountriesList, Serialize_help_getCountriesList },
		{ mtpc_channels_getParticipants, Serialize_channels_getParticipants },
		{ mtpc_channels_getParticipant, Serialize_channels_getParticipant },
		{ mtpc_channels_exportMessageLink, Serialize_channels_exportMessageLink },
		{ mtpc_channels_getAdminLog, Serialize_channels_getAdminLog },
		{ mtpc_channels_getInactiveChannels, Serialize_channels_getInactiveChannels },
		{ mtpc_channels_getSponsoredMessages, Serialize_channels_getSponsoredMessages },
		{ mtpc_bots_sendCustomRequest, Serialize_bots_sendCustomRequest },
		{ mtpc_phone_getCallConfig, Serialize_phone_getCallConfig },
		{ mtpc_bots_getBotCommands, Serialize_bots_getBotCommands },
		{ mtpc_payments_getPaymentForm, Serialize_payments_getPaymentForm },
		{ mtpc_payments_getPaymentReceipt, Serialize_payments_getPaymentReceipt },
		{ mtpc_payments_validateRequestedInfo, Serialize_payments_validateRequestedInfo },
		{ mtpc_payments_sendPaymentForm, Serialize_payments_sendPaymentForm },
		{ mtpc_payments_getSavedInfo, Serialize_payments_getSavedInfo },
		{ mtpc_payments_getBankCardData, Serialize_payments_getBankCardData },
		{ mtpc_stickers_suggestShortName, Serialize_stickers_suggestShortName },
		{ mtpc_phone_requestCall, Serialize_phone_requestCall },
		{ mtpc_phone_acceptCall, Serialize_phone_acceptCall },
		{ mtpc_phone_confirmCall, Serialize_phone_confirmCall },
		{ mtpc_phone_getGroupCall, Serialize_phone_getGroupCall },
		{ mtpc_phone_getGroupParticipants, Serialize_phone_getGroupParticipants },
		{ mtpc_phone_getGroupCallJoinAs, Serialize_phone_getGroupCallJoinAs },
		{ mtpc_phone_exportGroupCallInvite, Serialize_phone_exportGroupCallInvite },
		{ mtpc_langpack_getLangPack, Serialize_langpack_getLangPack },
		{ mtpc_langpack_getDifference, Serialize_langpack_getDifference },
		{ mtpc_langpack_getStrings, Serialize_langpack_getStrings },
		{ mtpc_langpack_getLanguages, Serialize_langpack_getLanguages },
		{ mtpc_langpack_getLanguage, Serialize_langpack_getLanguage },
		{ mtpc_stats_getBroadcastStats, Serialize_stats_getBroadcastStats },
		{ mtpc_stats_loadAsyncGraph, Serialize_stats_loadAsyncGraph },
		{ mtpc_stats_getMegagroupStats, Serialize_stats_getMegagroupStats },
		{ mtpc_stats_getMessageStats, Serialize_stats_getMessageStats },

	    { mtpc_rpc_result, Serialize_rpc_result },
	    { mtpc_msg_container, Serialize_msg_container },
	    { mtpc_core_message, Serialize_core_message },

	};
}

#include "scheme_compatible.hpp"

std::map<mtpTypeId, TextSerializer> CreateSerializers() {
    std::map<mtpTypeId, TextSerializer> ts = CreateTextSerializers();
    std::map<mtpTypeId, TextSerializer> cts = CreateCompatibleTextSerializers();
    ts.insert(cts.begin(), cts.end());
    return ts;
}

} // namespace

bool DumpToTextType(DumpToTextBuffer &to, const mtpPrime *&from, const mtpPrime *end, mtpPrime cons, uint32 level, mtpPrime vcons) {
    static auto kSerializers = CreateSerializers();

    Types types, vtypes;
    Stages stages;
    Flags flags;
    types.reserve(20);
    vtypes.reserve(20);
    stages.reserve(20);
    flags.reserve(20);
    types.push_back(mtpTypeId(cons));
    vtypes.push_back(mtpTypeId(vcons));
    stages.push_back(0);
    flags.push_back(0);

    mtpTypeId type = cons, vtype = vcons;
    int32 stage = 0;
    int64 flag = 0;

    while (!types.empty()) {
        type = types.back();
        vtype = vtypes.back();
        stage = stages.back();
        flag = flags.back();
        if (!type) {
            if (from >= end) {
                to.error("insufficient data");
                return false;
            } else if (stage) {
                to.error("unknown type on stage > 0");
                return false;
            }
            types.back() = type = *from;
            ++from;
        }

        int32 lev = level + types.size() - 1;
        auto it = kSerializers.find(type);
        if (it != kSerializers.end()) {
            if (!(*it->second)(to, stage, lev, types, vtypes, stages, flags, from, end, flag)) {
                to.error();
                return false;
            }
        } else if (DumpToTextCore(to, from, end, type, lev, vtype)) {
            types.pop_back();
            vtypes.pop_back();
            stages.pop_back();
            flags.pop_back();
        } else {
            to.error();
            return false;
        }
    }
    return true;
}

